{"/home/travis/build/npmtest/node-npmtest-stylelint/test.js":"/* istanbul instrument in package npmtest_stylelint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylelint/lib.npmtest_stylelint.js":"/* istanbul instrument in package npmtest_stylelint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_stylelint = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_stylelint = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-stylelint/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-stylelint && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_stylelint */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_stylelint\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_stylelint.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_stylelint.rollup.js'] =\n            local.assetsDict['/assets.npmtest_stylelint.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_stylelint.__dirname +\n                    '/lib.npmtest_stylelint.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/index.js":"\"use strict\"\n\nconst report = require(\"./utils/report\")\nconst ruleMessages = require(\"./utils/ruleMessages\")\nconst validateOptions = require(\"./utils/validateOptions\")\nconst checkAgainstRule = require(\"./utils/checkAgainstRule\")\nconst createPlugin = require(\"./createPlugin\")\nconst createRuleTester = require(\"./testUtils/createRuleTester\")\nconst createStylelint = require(\"./createStylelint\")\nconst postcssPlugin = require(\"./postcssPlugin\")\nconst rules = require(\"./rules\")\nconst formatters = require(\"./formatters\")\nconst standalone = require(\"./standalone\")\n\nconst api = postcssPlugin\n\napi.utils = {\n  report,\n  ruleMessages,\n  validateOptions,\n  checkAgainstRule,\n}\n\napi.lint = standalone\napi.rules = rules\napi.formatters = formatters\napi.createPlugin = createPlugin\napi.createRuleTester = createRuleTester\napi.createLinter = createStylelint\n\nmodule.exports = api\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/report.js":"/* @flow */\n\"use strict\"\n\nconst _ = require(\"lodash\")\n\n/**\n * Report a violation.\n *\n * This function accounts for `disabledRanges` attached to the result.\n * That is, if the reported violation is within a disabledRange,\n * it is ignored. Otherwise, it is attached to the result as a\n * postcss warning.\n *\n * It also accounts for the rule's severity.\n *\n * You *must* pass *either* a node or a line number.\n */\nmodule.exports = function (violation/*: {\n  ruleName: string,\n  result: Object,\n  message: string,\n  node: Object,\n  index?: number,\n  word?: string,\n  line?: number\n}*/) {\n  const ruleName = violation.ruleName\n  const result = violation.result\n  const message = violation.message\n  const line = violation.line\n  const node = violation.node\n  const index = violation.index\n  const word = violation.word\n\n  result.stylelint = result.stylelint || {}\n\n  // In quiet mode, mere warnings are ignored\n  if (result.stylelint.quiet && result.stylelint.ruleSeverities[ruleName] !== \"error\") {\n    return\n  }\n\n  // If a line is not passed, use the node.positionBy method to get the\n  // line number that the complaint pertains to\n  const startLine = line || node.positionBy({ index }).line\n\n  if (result.stylelint.disabledRanges && !result.stylelint.ignoreDisables) {\n    const ranges = result.stylelint.disabledRanges[ruleName] || result.stylelint.disabledRanges.all\n    for (const range of ranges) {\n      if (\n      // If the violation is within a disabledRange,\n      // and that disabledRange's rules include this one,\n      // do not register a warning\n      range.start <= startLine && (range.end >= startLine || range.end === undefined) && (!range.rules || range.rules.indexOf(ruleName) !== -1)) {\n        return\n      }\n    }\n  }\n\n  const severity = _.get(result.stylelint, [ \"ruleSeverities\", ruleName ], \"ignore\")\n\n  if (!result.stylelint.stylelintError && severity === \"error\") {\n    result.stylelint.stylelintError = true\n  }\n\n  const warningProperties/*: Object*/ = {\n    severity,\n    rule: ruleName,\n  }\n  if (node) {\n    warningProperties.node = node\n  }\n  if (index) {\n    warningProperties.index = index\n  }\n  if (word) {\n    warningProperties.word = word\n  }\n\n  const warningMessage = _.get(result.stylelint, [ \"customMessages\", ruleName ], message)\n  result.warn(warningMessage, warningProperties)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/ruleMessages.js":"/* @flow */\n\"use strict\"\n\n/**\n * Given an object of violation messages, return another\n * that provides the same messages postfixed with the rule\n * that has been violated.\n *\n * @param {string} ruleName\n * @param {object} messages - Object whose keys are message identifiers\n *   and values are either message strings or functions that return message strings\n * @return {object} New message object, whose messages will be marked with the rule name\n */\nmodule.exports = function (\n  ruleName/*: string*/,\n  messages/*: Object*/\n)/*: Object*/ {\n  return Object.keys(messages).reduce((newMessages, messageId) => {\n    const messageText = messages[messageId]\n    if (typeof messageText === \"string\") {\n      newMessages[messageId] = `${messageText} (${ruleName})`\n    } else {\n      newMessages[messageId] = function () {\n        return `${messageText.apply(null, arguments)} (${ruleName})`\n      }\n    }\n    return newMessages\n  }, {})\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/validateOptions.js":"/* @flow */\n\"use strict\"\n\nconst _ = require(\"lodash\")\n\nconst ignoredOptions = [ \"severity\", \"message\" ]\n\n/**\n * Validate a rule's options.\n *\n * See existing rules for examples.\n *\n * @param {Result} result - postcss result\n * @param {string} ruleName\n * @param {...object} ...optionDescriptions - Each optionDescription can\n *   have the following properties:\n *   \t- `actual` (required): the actual passed option value or object.\n *   \t- `possible` (required): a schema representation of what values are\n *      valid for those options. `possible` should be an object if the\n *      options are an object, with corresponding keys; if the options are not an\n *      object, `possible` isn't, either. All `possible` value representations\n *      should be **arrays of either values or functions**. Values are === checked\n *      against `actual`. Functions are fed `actual` as an argument and their\n *      return value is interpreted: truthy = valid, falsy = invalid.\n *    - `optional` (optional): If this is `true`, `actual` can be undefined.\n * @return {boolean} Whether or not the options are valid (true = valid)\n */\nmodule.exports = function (\n  result/*: Object*/,\n  ruleName/*: string*/\n)/*: boolean*/ {\n  let noErrors = true\n\n  const optionDescriptions = Array.from(arguments).slice(2)\n\n  optionDescriptions.forEach(optionDescription => {\n    validate(optionDescription, ruleName, complain)\n  })\n\n  function complain(message) {\n    noErrors = false\n    result.warn(message, {\n      stylelintType: \"invalidOption\",\n    })\n    _.set(result, \"stylelint.stylelintError\", true)\n  }\n\n  return noErrors\n}\n\nfunction validate(opts, ruleName, complain) {\n  const possible = opts.possible\n  const actual = opts.actual\n  const optional = opts.optional\n\n  if (actual === null || _.isEqual(actual, [null])) {\n    return\n  }\n\n  const nothingPossible = possible === undefined || Array.isArray(possible) && possible.length === 0\n\n  if (nothingPossible && actual === true) {\n    return\n  }\n\n  if (actual === undefined) {\n    if (nothingPossible || optional) {\n      return\n    }\n    complain(`Expected option value for rule \"${ruleName}\"`)\n    return\n  } else if (nothingPossible) {\n    complain(`Unexpected option value \"${actual}\" for rule \"${ruleName}\"`)\n    return\n  }\n\n  // If `possible` is a function ...\n  if (_.isFunction(possible)) {\n    if (!possible(actual)) {\n      complain(`Invalid option \"${JSON.stringify(actual)}\" for rule ${ruleName}`)\n    }\n    return\n  }\n\n  // If `possible` is an array instead of an object ...\n  if (!_.isPlainObject(possible)) {\n    [].concat(actual).forEach(a => {\n      if (isValid(possible, a)) {\n        return\n      }\n      complain(`Invalid option value \"${a}\" for rule \"${ruleName}\"`)\n    })\n    return\n  }\n\n  // If possible is an object ...\n  if (!_.isPlainObject(actual)) {\n    complain(`Invalid option value ${JSON.stringify(actual)} for rule \"${ruleName}\": ` + \"should be an object\")\n    return\n  }\n\n  Object.keys(actual).forEach(optionName => {\n    if (ignoredOptions.indexOf(optionName) !== -1) {\n      return\n    }\n\n    if (!possible[optionName]) {\n      complain(`Invalid option name \"${optionName}\" for rule \"${ruleName}\"`)\n      return\n    }\n\n    const actualOptionValue = actual[optionName];[].concat(actualOptionValue).forEach(a => {\n      if (isValid(possible[optionName], a)) {\n        return\n      }\n      complain(`Invalid value \"${a}\" for option \"${optionName}\" of rule \"${ruleName}\"`)\n    })\n  })\n}\n\nfunction isValid(possible, actual) {\n  const possibleList = [].concat(possible)\n  for (let i = 0, l = possibleList.length; i < l; i++) {\n    const possibility = possibleList[i]\n    if (typeof possibility === \"function\" && possibility(actual)) {\n      return true\n    }\n    if (actual === possibility) {\n      return true\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/checkAgainstRule.js":"/* @flow */\n\"use strict\"\n\nconst Result = require(\"postcss/lib/result\")\nconst normalizeRuleSettings = require(\"../normalizeRuleSettings\")\nconst rules = require(\"../rules\")\n\n// Useful for third-party code (e.g. plugins) to run a PostCSS Root\n// against a specific rule and do something with the warnings\nmodule.exports = function (\n  options/*: {\n    ruleName: string,\n    ruleSettings: stylelint$configRuleSettings,\n    root: Object,\n  }*/,\n  callback/*: Function*/\n) {\n  if (!options) throw new Error(\"checkAgainstRule requires an options object with 'ruleName', 'ruleSettings', and 'root' properties\")\n  if (!callback) throw new Error(\"checkAgainstRule requires a callback\")\n  if (!options.ruleName) throw new Error(\"checkAgainstRule requires a 'ruleName' option\")\n  if (!rules[options.ruleName]) throw new Error(`Rule '${options.ruleName}' does not exist`)\n  if (!options.ruleSettings) throw new Error(\"checkAgainstRule requires a 'ruleSettings' option\")\n  if (!options.root) throw new Error(\"checkAgainstRule requires a 'root' option\")\n\n  const settings = normalizeRuleSettings(options.ruleSettings, options.ruleName)\n  if (!settings) { return }\n\n  const tmpPostcssResult = new Result()\n  rules[options.ruleName](settings[0], settings[1])(options.root, tmpPostcssResult)\n  tmpPostcssResult.warnings().forEach(callback)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/normalizeRuleSettings.js":"/* @flow */\n\"use strict\"\nconst _ = require(\"lodash\")\nconst rules = require(\"./rules\")\n\n// Rule settings can take a number of forms, e.g.\n// a. \"rule-name\": null\n// b. \"rule-name\": [null, ...]\n// c. \"rule-name\": primaryOption\n// d. \"rule-name\": [primaryOption]\n// e. \"rule-name\": [primaryOption, secondaryOption]\n// Where primaryOption can be anything: primitive, Object, or Array.\n//\n// This function normalizes all the possibilities into the\n// standard form: [primaryOption, secondaryOption]\n// Except in the cases with null, a & b, in which case\n// null is returned\nmodule.exports = function (\n  rawSettings/*: stylelint$configRuleSettings*/,\n  ruleName/*: string*/,\n  // If primaryOptionArray is not provided, we try to get it from the\n  // rules themselves, which will not work for plugins\n  primaryOptionArray/*:: ?: boolean*/\n)/*: [any, Object] | Array<any | [any, Object]> | null*/ {\n  if (rawSettings === null) {\n    return null\n  }\n\n  if (!Array.isArray(rawSettings)) {\n    return [rawSettings]\n  }\n  // Everything below is an array ...\n\n  if (rawSettings[0] === null) {\n    return null\n  }\n\n  // This cursed rule needs a special case\n  if (ruleName === \"declaration-block-properties-order\") {\n    if (rawSettings[0] === \"alphabetical\") {\n      return rawSettings\n    }\n    if (typeof rawSettings[0] === \"string\") {\n      return [rawSettings]\n    }\n  }\n\n  if (primaryOptionArray === undefined) {\n    const rule = rules[ruleName]\n    primaryOptionArray = _.get(rule, \"primaryOptionArray\")\n  }\n\n  if (!primaryOptionArray) {\n    return rawSettings\n  }\n  // Everything below is a rule that CAN have an array for a primary option ...\n  // (they might also have something else, e.g. rule-properties-order can\n  // have the string \"alphabetical\")\n\n  if (rawSettings.length === 1 && Array.isArray(rawSettings[0])) {\n    return rawSettings\n  }\n\n  if (rawSettings.length === 2 && !_.isPlainObject(rawSettings[0]) && _.isPlainObject(rawSettings[1])) {\n    return rawSettings\n  }\n\n  return [rawSettings]\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/index.js":"\"use strict\"\n\nconst atRuleBlacklist = require(\"./at-rule-blacklist\")\nconst atRuleEmptyLineBefore = require(\"./at-rule-empty-line-before\")\nconst atRuleNameCase = require(\"./at-rule-name-case\")\nconst atRuleNameNewlineAfter = require(\"./at-rule-name-newline-after\")\nconst atRuleSemicolonSpaceBefore = require(\"./at-rule-semicolon-space-before\")\nconst atRuleNameSpaceAfter = require(\"./at-rule-name-space-after\")\nconst atRuleNoUnknown = require(\"./at-rule-no-unknown\")\nconst atRuleNoVendorPrefix = require(\"./at-rule-no-vendor-prefix\")\nconst atRuleSemicolonNewlineAfter = require(\"./at-rule-semicolon-newline-after\")\nconst atRuleWhitelist = require(\"./at-rule-whitelist\")\nconst blockClosingBraceEmptyLineBefore = require(\"./block-closing-brace-empty-line-before\")\nconst blockClosingBraceNewlineAfter = require(\"./block-closing-brace-newline-after\")\nconst blockClosingBraceNewlineBefore = require(\"./block-closing-brace-newline-before\")\nconst blockClosingBraceSpaceAfter = require(\"./block-closing-brace-space-after\")\nconst blockClosingBraceSpaceBefore = require(\"./block-closing-brace-space-before\")\nconst blockNoEmpty = require(\"./block-no-empty\")\nconst blockNoSingleLine = require(\"./block-no-single-line\")\nconst blockOpeningBraceNewlineAfter = require(\"./block-opening-brace-newline-after\")\nconst blockOpeningBraceNewlineBefore = require(\"./block-opening-brace-newline-before\")\nconst blockOpeningBraceSpaceAfter = require(\"./block-opening-brace-space-after\")\nconst blockOpeningBraceSpaceBefore = require(\"./block-opening-brace-space-before\")\nconst colorHexCase = require(\"./color-hex-case\")\nconst colorHexLength = require(\"./color-hex-length\")\nconst colorNamed = require(\"./color-named\")\nconst colorNoHex = require(\"./color-no-hex\")\nconst colorNoInvalidHex = require(\"./color-no-invalid-hex\")\nconst commentEmptyLineBefore = require(\"./comment-empty-line-before\")\nconst commentNoEmpty = require(\"./comment-no-empty\")\nconst commentWhitespaceInside = require(\"./comment-whitespace-inside\")\nconst commentWordBlacklist = require(\"./comment-word-blacklist\")\nconst customMediaPattern = require(\"./custom-media-pattern\")\nconst customPropertyEmptyLineBefore = require(\"./custom-property-empty-line-before\")\nconst customPropertyNoOutsideRoot = require(\"./custom-property-no-outside-root\")\nconst customPropertyPattern = require(\"./custom-property-pattern\")\nconst declarationBangSpaceAfter = require(\"./declaration-bang-space-after\")\nconst declarationBangSpaceBefore = require(\"./declaration-bang-space-before\")\nconst declarationBlockNoDuplicateProperties = require(\"./declaration-block-no-duplicate-properties\")\nconst declarationBlockNoIgnoredProperties = require(\"./declaration-block-no-ignored-properties\")\nconst declarationBlockNoRedundantLonghandProperties = require(\"./declaration-block-no-redundant-longhand-properties\")\nconst declarationBlockNoShorthandPropertyOverrides = require(\"./declaration-block-no-shorthand-property-overrides\")\nconst declarationBlockPropertiesOrder = require(\"./declaration-block-properties-order\")\nconst declarationBlockSemicolonNewlineAfter = require(\"./declaration-block-semicolon-newline-after\")\nconst declarationBlockSemicolonNewlineBefore = require(\"./declaration-block-semicolon-newline-before\")\nconst declarationBlockSemicolonSpaceAfter = require(\"./declaration-block-semicolon-space-after\")\nconst declarationBlockSemicolonSpaceBefore = require(\"./declaration-block-semicolon-space-before\")\nconst declarationBlockSingleLineMaxDeclarations = require(\"./declaration-block-single-line-max-declarations\")\nconst declarationBlockTrailingSemicolon = require(\"./declaration-block-trailing-semicolon\")\nconst declarationColonNewlineAfter = require(\"./declaration-colon-newline-after\")\nconst declarationColonSpaceAfter = require(\"./declaration-colon-space-after\")\nconst declarationColonSpaceBefore = require(\"./declaration-colon-space-before\")\nconst declarationEmptyLineBefore = require(\"./declaration-empty-line-before\")\nconst declarationNoImportant = require(\"./declaration-no-important\")\nconst declarationPropertyUnitBlacklist = require(\"./declaration-property-unit-blacklist\")\nconst declarationPropertyUnitWhitelist = require(\"./declaration-property-unit-whitelist\")\nconst declarationPropertyValueBlacklist = require(\"./declaration-property-value-blacklist\")\nconst declarationPropertyValueWhitelist = require(\"./declaration-property-value-whitelist\")\nconst fontFamilyNameQuotes = require(\"./font-family-name-quotes\")\nconst fontFamilyNoDuplicateNames = require(\"./font-family-no-duplicate-names\")\nconst fontWeightNotation = require(\"./font-weight-notation\")\nconst functionBlacklist = require(\"./function-blacklist\")\nconst functionCalcNoUnspacedOperator = require(\"./function-calc-no-unspaced-operator\")\nconst functionCommaNewlineAfter = require(\"./function-comma-newline-after\")\nconst functionCommaNewlineBefore = require(\"./function-comma-newline-before\")\nconst functionCommaSpaceAfter = require(\"./function-comma-space-after\")\nconst functionCommaSpaceBefore = require(\"./function-comma-space-before\")\nconst functionLinearGradientNoNonstandardDirection = require(\"./function-linear-gradient-no-nonstandard-direction\")\nconst functionMaxEmptyLines = require(\"./function-max-empty-lines\")\nconst functionNameCase = require(\"./function-name-case\")\nconst functionParenthesesNewlineInside = require(\"./function-parentheses-newline-inside\")\nconst functionParenthesesSpaceInside = require(\"./function-parentheses-space-inside\")\nconst functionUrlDataUris = require(\"./function-url-data-uris\")\nconst functionUrlNoSchemeRelative = require(\"./function-url-no-scheme-relative\")\nconst functionUrlQuotes = require(\"./function-url-quotes\")\nconst functionUrlSchemeWhitelist = require(\"./function-url-scheme-whitelist\")\nconst functionWhitelist = require(\"./function-whitelist\")\nconst functionWhitespaceAfter = require(\"./function-whitespace-after\")\nconst indentation = require(\"./indentation\")\nconst keyframeDeclarationNoImportant = require(\"./keyframe-declaration-no-important\")\nconst lengthZeroNoUnit = require(\"./length-zero-no-unit\")\nconst maxEmptyLines = require(\"./max-empty-lines\")\nconst maxLineLength = require(\"./max-line-length\")\nconst maxNestingDepth = require(\"./max-nesting-depth\")\nconst mediaFeatureColonSpaceAfter = require(\"./media-feature-colon-space-after\")\nconst mediaFeatureColonSpaceBefore = require(\"./media-feature-colon-space-before\")\nconst mediaFeatureNameBlacklist = require(\"./media-feature-name-blacklist\")\nconst mediaFeatureNameCase = require(\"./media-feature-name-case\")\nconst mediaFeatureNameNoUnknown = require(\"./media-feature-name-no-unknown\")\nconst mediaFeatureNameNoVendorPrefix = require(\"./media-feature-name-no-vendor-prefix\")\nconst mediaFeatureNameWhitelist = require(\"./media-feature-name-whitelist\")\nconst mediaFeatureNoMissingPunctuation = require(\"./media-feature-no-missing-punctuation\")\nconst mediaFeatureParenthesesSpaceInside = require(\"./media-feature-parentheses-space-inside\")\nconst mediaFeatureRangeOperatorSpaceAfter = require(\"./media-feature-range-operator-space-after\")\nconst mediaFeatureRangeOperatorSpaceBefore = require(\"./media-feature-range-operator-space-before\")\nconst mediaQueryListCommaNewlineAfter = require(\"./media-query-list-comma-newline-after\")\nconst mediaQueryListCommaNewlineBefore = require(\"./media-query-list-comma-newline-before\")\nconst mediaQueryListCommaSpaceAfter = require(\"./media-query-list-comma-space-after\")\nconst mediaQueryListCommaSpaceBefore = require(\"./media-query-list-comma-space-before\")\nconst noBrowserHacks = require(\"./no-browser-hacks\")\nconst noDescendingSpecificity = require(\"./no-descending-specificity\")\nconst noDuplicateSelectors = require(\"./no-duplicate-selectors\")\nconst noEmptySource = require(\"./no-empty-source\")\nconst noEolWhitespace = require(\"./no-eol-whitespace\")\nconst noExtraSemicolons = require(\"./no-extra-semicolons\")\nconst noIndistinguishableColors = require(\"./no-indistinguishable-colors\")\nconst noInvalidDoubleSlashComments = require(\"./no-invalid-double-slash-comments\")\nconst noMissingEndOfSourceNewline = require(\"./no-missing-end-of-source-newline\")\nconst noSupportedBrowserFeatures = require(\"./no-unsupported-browser-features\")\nconst noUnknownAnimations = require(\"./no-unknown-animations\")\nconst numberLeadingZero = require(\"./number-leading-zero\")\nconst numberMaxPrecision = require(\"./number-max-precision\")\nconst numberNoTrailingZeros = require(\"./number-no-trailing-zeros\")\nconst propertyBlacklist = require(\"./property-blacklist\")\nconst propertyCase = require(\"./property-case\")\nconst propertyNoUnknown = require(\"./property-no-unknown\")\nconst propertyNoVendorPrefix = require(\"./property-no-vendor-prefix\")\nconst propertyWhitelist = require(\"./property-whitelist\")\nconst rootNoStandardProperties = require(\"./root-no-standard-properties\")\nconst ruleEmptyLineBefore = require(\"./rule-empty-line-before\")\nconst ruleNestedEmptyLineBefore = require(\"./rule-nested-empty-line-before\")\nconst ruleNonNestedEmptyLineBefore = require(\"./rule-non-nested-empty-line-before\")\nconst selectorAttributeBracketsSpaceInside = require(\"./selector-attribute-brackets-space-inside\")\nconst selectorAttributeOperatorBlacklist = require(\"./selector-attribute-operator-blacklist\")\nconst selectorAttributeOperatorSpaceAfter = require(\"./selector-attribute-operator-space-after\")\nconst selectorAttributeOperatorSpaceBefore = require(\"./selector-attribute-operator-space-before\")\nconst selectorAttributeOperatorWhitelist = require(\"./selector-attribute-operator-whitelist\")\nconst selectorAttributeQuotes = require(\"./selector-attribute-quotes\")\nconst selectorClassPattern = require(\"./selector-class-pattern\")\nconst selectorCombinatorSpaceAfter = require(\"./selector-combinator-space-after\")\nconst selectorCombinatorSpaceBefore = require(\"./selector-combinator-space-before\")\nconst selectorDescendantCombinatorNoNonSpace = require(\"./selector-descendant-combinator-no-non-space\")\nconst selectorIdPattern = require(\"./selector-id-pattern\")\nconst selectorListCommaNewlineAfter = require(\"./selector-list-comma-newline-after\")\nconst selectorListCommaNewlineBefore = require(\"./selector-list-comma-newline-before\")\nconst selectorListCommaSpaceAfter = require(\"./selector-list-comma-space-after\")\nconst selectorListCommaSpaceBefore = require(\"./selector-list-comma-space-before\")\nconst selectorMaxCompoundSelectors = require(\"./selector-max-compound-selectors\")\nconst selectorMaxEmptyLines = require(\"./selector-max-empty-lines\")\nconst selectorMaxSpecificity = require(\"./selector-max-specificity\")\nconst selectorNestedPattern = require(\"./selector-nested-pattern\")\nconst selectorNoAttribute = require(\"./selector-no-attribute\")\nconst selectorNoCombinator = require(\"./selector-no-combinator\")\nconst selectorNoEmpty = require(\"./selector-no-empty\")\nconst selectorNoId = require(\"./selector-no-id\")\nconst selectorNoQualifyingType = require(\"./selector-no-qualifying-type\")\nconst selectorNoType = require(\"./selector-no-type\")\nconst selectorNoUniversal = require(\"./selector-no-universal\")\nconst selectorNoVendorPrefix = require(\"./selector-no-vendor-prefix\")\nconst selectorPseudoClassBlacklist = require(\"./selector-pseudo-class-blacklist\")\nconst selectorPseudoClassCase = require(\"./selector-pseudo-class-case\")\nconst selectorPseudoClassNoUnknown = require(\"./selector-pseudo-class-no-unknown\")\nconst selectorPseudoClassParenthesesSpaceInside = require(\"./selector-pseudo-class-parentheses-space-inside\")\nconst selectorPseudoClassWhitelist = require(\"./selector-pseudo-class-whitelist\")\nconst selectorPseudoElementCase = require(\"./selector-pseudo-element-case\")\nconst selectorPseudoElementColonNotation = require(\"./selector-pseudo-element-colon-notation\")\nconst selectorPseudoElementNoUnknown = require(\"./selector-pseudo-element-no-unknown\")\nconst selectorRootNoComposition = require(\"./selector-root-no-composition\")\nconst selectorTypeCase = require(\"./selector-type-case\")\nconst selectorTypeNoUnknown = require(\"./selector-type-no-unknown\")\nconst shorthandPropertyNoRedundantValues = require(\"./shorthand-property-no-redundant-values\")\nconst stringNoNewline = require(\"./string-no-newline\")\nconst stringQuotes = require(\"./string-quotes\")\nconst stylelintDisableReason = require(\"./stylelint-disable-reason\")\nconst timeMinMilliseconds = require(\"./time-min-milliseconds\")\nconst timeNoImperceptible = require(\"./time-no-imperceptible\")\nconst unitBlacklist = require(\"./unit-blacklist\")\nconst unitCase = require(\"./unit-case\")\nconst unitNoUnknown = require(\"./unit-no-unknown\")\nconst unitWhitelist = require(\"./unit-whitelist\")\nconst valueKeywordCase = require(\"./value-keyword-case\")\nconst valueListCommaNewlineAfter = require(\"./value-list-comma-newline-after\")\nconst valueListCommaNewlineBefore = require(\"./value-list-comma-newline-before\")\nconst valueListCommaSpaceAfter = require(\"./value-list-comma-space-after\")\nconst valueListCommaSpaceBefore = require(\"./value-list-comma-space-before\")\nconst valueListMaxEmptyLines = require(\"./value-list-max-empty-lines\")\nconst valueNoVendorPrefix = require(\"./value-no-vendor-prefix\")\n\nmodule.exports = {\n  \"at-rule-blacklist\": atRuleBlacklist,\n  \"at-rule-empty-line-before\": atRuleEmptyLineBefore,\n  \"at-rule-name-case\": atRuleNameCase,\n  \"at-rule-name-newline-after\": atRuleNameNewlineAfter,\n  \"at-rule-semicolon-space-before\": atRuleSemicolonSpaceBefore,\n  \"at-rule-name-space-after\": atRuleNameSpaceAfter,\n  \"at-rule-no-unknown\": atRuleNoUnknown,\n  \"at-rule-no-vendor-prefix\": atRuleNoVendorPrefix,\n  \"at-rule-semicolon-newline-after\": atRuleSemicolonNewlineAfter,\n  \"at-rule-whitelist\": atRuleWhitelist,\n  \"block-closing-brace-empty-line-before\": blockClosingBraceEmptyLineBefore,\n  \"block-closing-brace-newline-after\": blockClosingBraceNewlineAfter,\n  \"block-closing-brace-newline-before\": blockClosingBraceNewlineBefore,\n  \"block-closing-brace-space-after\": blockClosingBraceSpaceAfter,\n  \"block-closing-brace-space-before\": blockClosingBraceSpaceBefore,\n  \"block-no-empty\": blockNoEmpty,\n  \"block-no-single-line\": blockNoSingleLine,\n  \"block-opening-brace-newline-after\": blockOpeningBraceNewlineAfter,\n  \"block-opening-brace-newline-before\": blockOpeningBraceNewlineBefore,\n  \"block-opening-brace-space-after\": blockOpeningBraceSpaceAfter,\n  \"block-opening-brace-space-before\": blockOpeningBraceSpaceBefore,\n  \"color-hex-case\": colorHexCase,\n  \"color-hex-length\": colorHexLength,\n  \"color-named\": colorNamed,\n  \"color-no-hex\": colorNoHex,\n  \"color-no-invalid-hex\": colorNoInvalidHex,\n  \"comment-empty-line-before\": commentEmptyLineBefore,\n  \"comment-no-empty\": commentNoEmpty,\n  \"comment-whitespace-inside\": commentWhitespaceInside,\n  \"comment-word-blacklist\": commentWordBlacklist,\n  \"custom-media-pattern\": customMediaPattern,\n  \"custom-property-empty-line-before\": customPropertyEmptyLineBefore,\n  \"custom-property-no-outside-root\": customPropertyNoOutsideRoot,\n  \"custom-property-pattern\": customPropertyPattern,\n  \"declaration-bang-space-after\": declarationBangSpaceAfter,\n  \"declaration-bang-space-before\": declarationBangSpaceBefore,\n  \"declaration-block-no-duplicate-properties\": declarationBlockNoDuplicateProperties,\n  \"declaration-block-no-ignored-properties\": declarationBlockNoIgnoredProperties,\n  \"declaration-block-no-redundant-longhand-properties\": declarationBlockNoRedundantLonghandProperties,\n  \"declaration-block-no-shorthand-property-overrides\": declarationBlockNoShorthandPropertyOverrides,\n  \"declaration-block-properties-order\": declarationBlockPropertiesOrder,\n  \"declaration-block-semicolon-newline-after\": declarationBlockSemicolonNewlineAfter,\n  \"declaration-block-semicolon-newline-before\": declarationBlockSemicolonNewlineBefore,\n  \"declaration-block-semicolon-space-after\": declarationBlockSemicolonSpaceAfter,\n  \"declaration-block-semicolon-space-before\": declarationBlockSemicolonSpaceBefore,\n  \"declaration-block-single-line-max-declarations\": declarationBlockSingleLineMaxDeclarations,\n  \"declaration-block-trailing-semicolon\": declarationBlockTrailingSemicolon,\n  \"declaration-colon-newline-after\": declarationColonNewlineAfter,\n  \"declaration-colon-space-after\": declarationColonSpaceAfter,\n  \"declaration-colon-space-before\": declarationColonSpaceBefore,\n  \"declaration-empty-line-before\": declarationEmptyLineBefore,\n  \"declaration-no-important\": declarationNoImportant,\n  \"declaration-property-unit-blacklist\": declarationPropertyUnitBlacklist,\n  \"declaration-property-unit-whitelist\": declarationPropertyUnitWhitelist,\n  \"declaration-property-value-blacklist\": declarationPropertyValueBlacklist,\n  \"declaration-property-value-whitelist\": declarationPropertyValueWhitelist,\n  \"font-family-name-quotes\": fontFamilyNameQuotes,\n  \"font-family-no-duplicate-names\": fontFamilyNoDuplicateNames,\n  \"font-weight-notation\": fontWeightNotation,\n  \"function-blacklist\": functionBlacklist,\n  \"function-calc-no-unspaced-operator\": functionCalcNoUnspacedOperator,\n  \"function-comma-newline-after\": functionCommaNewlineAfter,\n  \"function-comma-newline-before\": functionCommaNewlineBefore,\n  \"function-comma-space-after\": functionCommaSpaceAfter,\n  \"function-comma-space-before\": functionCommaSpaceBefore,\n  \"function-linear-gradient-no-nonstandard-direction\": functionLinearGradientNoNonstandardDirection,\n  \"function-max-empty-lines\": functionMaxEmptyLines,\n  \"function-name-case\": functionNameCase,\n  \"function-parentheses-newline-inside\": functionParenthesesNewlineInside,\n  \"function-parentheses-space-inside\": functionParenthesesSpaceInside,\n  \"function-url-data-uris\": functionUrlDataUris,\n  \"function-url-no-scheme-relative\": functionUrlNoSchemeRelative,\n  \"function-url-quotes\": functionUrlQuotes,\n  \"function-url-scheme-whitelist\": functionUrlSchemeWhitelist,\n  \"function-whitelist\": functionWhitelist,\n  \"function-whitespace-after\": functionWhitespaceAfter,\n  \"indentation\": indentation, // eslint-disable-line object-shorthand\n  \"keyframe-declaration-no-important\": keyframeDeclarationNoImportant,\n  \"length-zero-no-unit\": lengthZeroNoUnit,\n  \"max-empty-lines\": maxEmptyLines,\n  \"max-line-length\": maxLineLength,\n  \"max-nesting-depth\": maxNestingDepth,\n  \"media-feature-colon-space-after\": mediaFeatureColonSpaceAfter,\n  \"media-feature-colon-space-before\": mediaFeatureColonSpaceBefore,\n  \"media-feature-name-blacklist\": mediaFeatureNameBlacklist,\n  \"media-feature-name-case\": mediaFeatureNameCase,\n  \"media-feature-name-no-unknown\": mediaFeatureNameNoUnknown,\n  \"media-feature-name-no-vendor-prefix\": mediaFeatureNameNoVendorPrefix,\n  \"media-feature-name-whitelist\": mediaFeatureNameWhitelist,\n  \"media-feature-no-missing-punctuation\": mediaFeatureNoMissingPunctuation,\n  \"media-feature-parentheses-space-inside\": mediaFeatureParenthesesSpaceInside,\n  \"media-feature-range-operator-space-after\": mediaFeatureRangeOperatorSpaceAfter,\n  \"media-feature-range-operator-space-before\": mediaFeatureRangeOperatorSpaceBefore,\n  \"media-query-list-comma-newline-after\": mediaQueryListCommaNewlineAfter,\n  \"media-query-list-comma-newline-before\": mediaQueryListCommaNewlineBefore,\n  \"media-query-list-comma-space-after\": mediaQueryListCommaSpaceAfter,\n  \"media-query-list-comma-space-before\": mediaQueryListCommaSpaceBefore,\n  \"no-browser-hacks\": noBrowserHacks,\n  \"no-descending-specificity\": noDescendingSpecificity,\n  \"no-duplicate-selectors\": noDuplicateSelectors,\n  \"no-empty-source\": noEmptySource,\n  \"no-eol-whitespace\": noEolWhitespace,\n  \"no-extra-semicolons\": noExtraSemicolons,\n  \"no-indistinguishable-colors\": noIndistinguishableColors,\n  \"no-invalid-double-slash-comments\": noInvalidDoubleSlashComments,\n  \"no-missing-end-of-source-newline\": noMissingEndOfSourceNewline,\n  \"no-unknown-animations\": noUnknownAnimations,\n  \"no-unsupported-browser-features\": noSupportedBrowserFeatures,\n  \"number-leading-zero\": numberLeadingZero,\n  \"number-max-precision\": numberMaxPrecision,\n  \"number-no-trailing-zeros\": numberNoTrailingZeros,\n  \"property-blacklist\": propertyBlacklist,\n  \"property-case\": propertyCase,\n  \"property-no-unknown\": propertyNoUnknown,\n  \"property-no-vendor-prefix\": propertyNoVendorPrefix,\n  \"property-whitelist\": propertyWhitelist,\n  \"root-no-standard-properties\": rootNoStandardProperties,\n  \"rule-empty-line-before\": ruleEmptyLineBefore,\n  \"rule-nested-empty-line-before\": ruleNestedEmptyLineBefore,\n  \"rule-non-nested-empty-line-before\": ruleNonNestedEmptyLineBefore,\n  \"selector-attribute-brackets-space-inside\": selectorAttributeBracketsSpaceInside,\n  \"selector-attribute-operator-blacklist\": selectorAttributeOperatorBlacklist,\n  \"selector-attribute-operator-space-after\": selectorAttributeOperatorSpaceAfter,\n  \"selector-attribute-operator-space-before\": selectorAttributeOperatorSpaceBefore,\n  \"selector-attribute-operator-whitelist\": selectorAttributeOperatorWhitelist,\n  \"selector-attribute-quotes\": selectorAttributeQuotes,\n  \"selector-class-pattern\": selectorClassPattern,\n  \"selector-combinator-space-after\": selectorCombinatorSpaceAfter,\n  \"selector-combinator-space-before\": selectorCombinatorSpaceBefore,\n  \"selector-descendant-combinator-no-non-space\": selectorDescendantCombinatorNoNonSpace,\n  \"selector-id-pattern\": selectorIdPattern,\n  \"selector-list-comma-newline-after\": selectorListCommaNewlineAfter,\n  \"selector-list-comma-newline-before\": selectorListCommaNewlineBefore,\n  \"selector-list-comma-space-after\": selectorListCommaSpaceAfter,\n  \"selector-list-comma-space-before\": selectorListCommaSpaceBefore,\n  \"selector-max-compound-selectors\": selectorMaxCompoundSelectors,\n  \"selector-max-empty-lines\": selectorMaxEmptyLines,\n  \"selector-max-specificity\": selectorMaxSpecificity,\n  \"selector-nested-pattern\": selectorNestedPattern,\n  \"selector-no-attribute\": selectorNoAttribute,\n  \"selector-no-empty\": selectorNoEmpty,\n  \"selector-no-combinator\": selectorNoCombinator,\n  \"selector-no-id\": selectorNoId,\n  \"selector-no-qualifying-type\": selectorNoQualifyingType,\n  \"selector-no-type\": selectorNoType,\n  \"selector-no-universal\": selectorNoUniversal,\n  \"selector-no-vendor-prefix\": selectorNoVendorPrefix,\n  \"selector-pseudo-class-blacklist\": selectorPseudoClassBlacklist,\n  \"selector-pseudo-class-case\": selectorPseudoClassCase,\n  \"selector-pseudo-class-no-unknown\": selectorPseudoClassNoUnknown,\n  \"selector-pseudo-class-parentheses-space-inside\": selectorPseudoClassParenthesesSpaceInside,\n  \"selector-pseudo-class-whitelist\": selectorPseudoClassWhitelist,\n  \"selector-pseudo-element-case\": selectorPseudoElementCase,\n  \"selector-pseudo-element-colon-notation\": selectorPseudoElementColonNotation,\n  \"selector-pseudo-element-no-unknown\": selectorPseudoElementNoUnknown,\n  \"selector-root-no-composition\": selectorRootNoComposition,\n  \"selector-type-case\": selectorTypeCase,\n  \"selector-type-no-unknown\": selectorTypeNoUnknown,\n  \"shorthand-property-no-redundant-values\": shorthandPropertyNoRedundantValues,\n  \"string-no-newline\": stringNoNewline,\n  \"string-quotes\": stringQuotes,\n  \"stylelint-disable-reason\": stylelintDisableReason,\n  \"time-min-milliseconds\": timeMinMilliseconds,\n  \"time-no-imperceptible\": timeNoImperceptible,\n  \"unit-blacklist\": unitBlacklist,\n  \"unit-case\": unitCase,\n  \"unit-no-unknown\": unitNoUnknown,\n  \"unit-whitelist\": unitWhitelist,\n  \"value-keyword-case\": valueKeywordCase,\n  \"value-list-comma-newline-after\": valueListCommaNewlineAfter,\n  \"value-list-comma-newline-before\": valueListCommaNewlineBefore,\n  \"value-list-comma-space-after\": valueListCommaSpaceAfter,\n  \"value-list-comma-space-before\": valueListCommaSpaceBefore,\n  \"value-list-max-empty-lines\": valueListMaxEmptyLines,\n  \"value-no-vendor-prefix\": valueNoVendorPrefix,\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-blacklist/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"at-rule-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected at-rule \"${name}\"`,\n})\n\nconst rule = function (blacklistInput) {\n  // To allow for just a string as a parameter (not only arrays of strings)\n  const blacklist = [].concat(blacklistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      const name = atRule.name\n\n      if (blacklist.indexOf(postcss.vendor.unprefixed(name).toLowerCase()) === -1) {\n        return\n      }\n\n      report({\n        message: messages.rejected(name),\n        node: atRule,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-empty-line-before/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyLine = require(\"../../utils/hasEmptyLine\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"at-rule-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before at-rule\",\n  rejected: \"Unexpected empty line before at-rule\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        except: [\n          \"after-same-name\",\n          \"all-nested\",\n          \"inside-block\",\n          \"blockless-after-same-name-blockless\",\n          \"blockless-group\",\n          \"blockless-after-blockless\",\n          \"first-nested\",\n        ],\n        ignore: [\n          \"after-comment\",\n          \"all-nested\",\n          \"inside-block\",\n          \"blockless-after-same-name-blockless\",\n          \"blockless-group\",\n          \"blockless-after-blockless\",\n        ],\n        ignoreAtRules: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    if (\n      optionsMatches(options, \"ignore\", \"all-nested\")\n      || optionsMatches(options, \"except\", \"all-nested\")\n    ) {\n      result.warn((\n        \"'at-rule-empty-line-before\\'s' \\\"all-nested\\\" option has been deprecated and in 8.0 will be removed. \" +\n        \"Instead use the \\\"inside-block\\\" option.\"\n      ), {\n        stylelintType: \"deprecation\",\n        stylelintReference: \"https://stylelint.io/user-guide/rules/at-rule-empty-line-before/\",\n      })\n    }\n\n    if (\n      optionsMatches(options, \"ignore\", \"blockless-group\")\n      || optionsMatches(options, \"except\", \"blockless-group\")\n    ) {\n      result.warn((\n        \"'at-rule-empty-line-before\\'s' \\\"blockless-group\\\" option has been deprecated and in 8.0 will be removed. \" +\n        \"Instead use the \\\"blockless-after-blockless\\\" option.\"\n      ), {\n        stylelintType: \"deprecation\",\n        stylelintReference: \"https://stylelint.io/user-guide/rules/at-rule-empty-line-before/\",\n      })\n    }\n\n    root.walkAtRules(atRule => {\n      // Ignore the first node\n      if (atRule === root.first) {\n        return\n      }\n\n      // Return early if at-rule is to be ignored\n      if (optionsMatches(options, \"ignoreAtRules\", atRule.name)) {\n        return\n      }\n\n      // Optionally ignore the expectation if the node is blockless\n      if (\n        optionsMatches(options, \"ignore\", \"blockless-group\")\n        && !hasBlock(atRule)\n        || optionsMatches(options, \"ignore\", \"blockless-after-blockless\")\n        && !hasBlock(atRule)\n      ) {\n        return\n      }\n\n      const isNested = atRule.parent !== root\n      const previousNode = atRule.prev()\n\n      // Optionally ignore the expection if the node is blockless\n      // and following another blockless at-rule with the same name\n      if (\n        optionsMatches(options, \"ignore\", \"blockless-after-same-name-blockless\")\n        && isBlocklessAfterSameNameBlockless()\n      ) {\n        return\n      }\n\n      // Optionally ignore the expectation if the node is inside a block\n      if (\n        optionsMatches(options, \"ignore\", \"all-nested\")\n        && isNested\n        || optionsMatches(options, \"ignore\", \"inside-block\")\n        && isNested\n      ) {\n        return\n      }\n\n      // Optionally ignore the expectation if a comment precedes this node\n      if (\n        optionsMatches(options, \"ignore\", \"after-comment\")\n        && isAfterComment()\n      ) {\n        return\n      }\n\n      const hasEmptyLineBefore = hasEmptyLine(atRule.raws.before)\n      let expectEmptyLineBefore = expectation === \"always\"\n        ? true\n        : false\n\n      // Optionally reverse the expectation if any exceptions apply\n      if (\n        optionsMatches(options, \"except\", \"after-same-name\")\n        && isAfterSameName()\n        || optionsMatches(options, \"except\", \"all-nested\")\n        && isNested\n        || optionsMatches(options, \"except\", \"inside-block\")\n        && isNested\n        || optionsMatches(options, \"except\", \"first-nested\")\n        && isFirstNested()\n        || optionsMatches(options, \"except\", \"blockless-group\")\n        && isBlocklessAfterBlockless()\n        || optionsMatches(options, \"except\", \"blockless-after-blockless\")\n        && isBlocklessAfterBlockless()\n        || optionsMatches(options, \"except\", \"blockless-after-same-name-blockless\")\n        && isBlocklessAfterSameNameBlockless()\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return\n      }\n\n      const message = expectEmptyLineBefore\n        ? messages.expected\n        : messages.rejected\n\n      report({ message, node: atRule, result, ruleName })\n\n      function isAfterComment() {\n        return previousNode\n          && previousNode.type === \"comment\"\n      }\n\n      function isBlocklessAfterBlockless() {\n        return previousNode\n          && previousNode.type === \"atrule\"\n          && !hasBlock(previousNode)\n          && !hasBlock(atRule)\n      }\n\n      function isBlocklessAfterSameNameBlockless() {\n        return !hasBlock(atRule)\n          && previousNode\n          && !hasBlock(previousNode)\n          && previousNode.type === \"atrule\"\n          && previousNode.name == atRule.name\n      }\n\n      function isAfterSameName() {\n        return previousNode\n          && previousNode.type === \"atrule\"\n          && previousNode.name === atRule.name\n      }\n\n      function isFirstNested() {\n        return isNested\n          && atRule === atRule.parent.first\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasBlock.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a statement has an block (empty or otherwise).\n *\n * @param {Rule|AtRule} statement - postcss rule or at-rule node\n * @return {boolean} True if `statement` has a block (empty or otherwise)\n */\nmodule.exports = function (\n  statement/*: postcss$rule | postcss$atRule*/\n)/*: boolean*/ {\n  return statement.nodes !== undefined\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasEmptyLine.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a string contains at least one empty line\n */\nmodule.exports = function (string/*:: ?: string*/)/*: boolean*/ {\n  if (string === \"\" || string === undefined) return false\n  return string.indexOf(\"\\n\\n\") !== -1 || string.indexOf(\"\\n\\r\\n\") !== -1\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/optionsMatches.js":"/* @flow */\n\"use strict\"\n\nconst matchesStringOrRegExp = require(\"./matchesStringOrRegExp\")\n\n/**\n * Check if an options object's propertyName contains a user-defined string or\n * regex that matches the passed in input.\n */\nmodule.exports = function optionsMatches(\n  options/*: Object*/,\n  propertyName/*: string*/,\n  input/*: string*/\n)/*: boolean*/ {\n  return !!(options && options[propertyName] && typeof input === \"string\" && matchesStringOrRegExp(input.toLowerCase(), options[propertyName]))\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/matchesStringOrRegExp.js":"/* @flow */\n\"use strict\"\n\n/**\n * Compares a string to a second value that, if it fits a certain convention,\n * is converted to a regular expression before the comparison.\n * If it doesn't fit the convention, then two strings are compared.\n *\n * Any strings starting and ending with `/` are interpreted\n * as regular expressions.\n */\nmodule.exports = function matchesStringOrRegExp(\n  input/*: string | Array<string>*/,\n  comparison/*: string | Array<string>*/\n)/*: false | { match: string, pattern: string}*/ {\n  if (!Array.isArray(input)) {\n    return testAgainstStringOrArray(input, comparison)\n  }\n\n  for (const inputItem of input) {\n    const testResult = testAgainstStringOrArray(inputItem, comparison)\n    if (testResult) {\n      return testResult\n    }\n  }\n\n  return false\n}\n\nfunction testAgainstStringOrArray(value, comparison) {\n  if (!Array.isArray(comparison)) {\n    return testAgainstString(value, comparison)\n  }\n\n  for (const comparisonItem of comparison) {\n    const testResult = testAgainstString(value, comparisonItem)\n    if (testResult) {\n      return testResult\n    }\n  }\n  return false\n}\n\nfunction testAgainstString(value, comparison) {\n  const comparisonIsRegex = comparison[0] === \"/\" && comparison[comparison.length - 1] === \"/\"\n\n  if (comparisonIsRegex) {\n    const valueMatches = new RegExp(comparison.slice(1, -1)).test(value)\n    return valueMatches ? { match: value, pattern: comparison } : false\n  }\n\n  return value === comparison ? { match: value, pattern: comparison } : false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-name-case/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"at-rule-name-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      const name = atRule.name\n\n      const expectedName = expectation === \"lower\"\n        ? name.toLowerCase()\n        : name.toUpperCase()\n\n      if (name === expectedName) {\n        return\n      }\n\n      report({\n        message: messages.expected(name, expectedName),\n        node: atRule,\n        ruleName,\n        result,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-name-newline-after/index.js":"\"use strict\"\n\nconst atRuleNameSpaceChecker = require(\"../atRuleNameSpaceChecker\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"at-rule-name-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: name => `Expected newline after at-rule name \\\"${name}\\\"`,\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    atRuleNameSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.afterOneOnly,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/atRuleNameSpaceChecker.js":"\"use strict\"\n\nconst isStandardSyntaxAtRule = require(\"../utils/isStandardSyntaxAtRule\")\nconst report = require(\"../utils/report\")\n\nmodule.exports = function (options) {\n  options.root.walkAtRules(atRule => {\n    if (!isStandardSyntaxAtRule(atRule)) {\n      return\n    }\n\n    checkColon(`@${atRule.name}${(atRule.raws.afterName || \"\")}${atRule.params}`, atRule.name.length, atRule)\n  })\n\n  function checkColon(source, index, node) {\n    options.locationChecker({\n      source,\n      index,\n      err: m => report({\n        message: m,\n        node,\n        index,\n        result: options.result,\n        ruleName: options.checkedRuleName,\n      }),\n      errTarget: `@${node.name}`,\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxAtRule.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a at-rule is standard\n *\n * @param {atRule} postcss at-rule node\n * @return {boolean} If `true`, the declaration is standard\n */\nmodule.exports = function (atRule/*: postcss$atRule*/)/*: boolean*/ {\n  // Ignore scss `@content` inside mixins\n  if (!atRule.nodes && atRule.params === \"\") {\n    return false\n  }\n\n  // Ignore detached ruleset `@detached-ruleset: { background: red; }; .top { @detached-ruleset(); }`\n  if (!atRule.nodes && atRule.raws.afterName === \"\" && atRule.params[0] === \"(\") {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/whitespaceChecker.js":"\"use strict\"\n\nconst configurationError = require(\"./configurationError\")\nconst isSingleLineString = require(\"./isSingleLineString\")\nconst isWhitespace = require(\"./isWhitespace\")\n\n/**\n * Create a whitespaceChecker, which exposes the following functions:\n * - `before()`\n * - `beforeAllowingIndentation()`\n * - `after()`\n * - `afterOneOnly()`\n *\n * @param {\"space\"|\"newline\"} targetWhitespace - This is a keyword instead\n *   of the actual character (e.g. \" \") in order to accommodate\n *   different styles of newline (\"\\n\" vs \"\\r\\n\")\n * @param {\n *     \"always\"|\"never\"\n *     |\"always-single-line\"|\"always-multi-line\"\n *     | \"never-single-line\"|\"never-multi-line\"\n *   } expectation\n * @param {object} messages - An object of message functions;\n *   calling `before*()` or `after*()` and the `expectation` that is passed\n *   determines which message functions are required\n * @param {function} [messages.exectedBefore]\n * @param {function} [messages.rejectedBefore]\n * @param {function} [messages.expectedAfter]\n * @param {function} [messages.rejectedAfter]\n * @param {function} [messages.expectedBeforeSingleLine]\n * @param {function} [messages.rejectedBeforeSingleLine]\n * @param {function} [messages.expectedBeforeMultiLine]\n * @param {function} [messages.rejectedBeforeMultiLine]\n * @return {object} The checker, with its exposed checking functions\n */\nmodule.exports = function (\n  targetWhitespace/*: \"space\" | \"newline\"*/,\n  expectation/*: \"always\" | \"never\" | \"always-single-line\"\n    | \"always-multi-line\" | \"never-single-line\"|\"never-multi-line\"*/,\n  messages/*: Object*/\n)/*: {\n  before: Function,\n  beforeAllowingIndentation: Function,\n  after: Function,\n  afterOneOnly: Function\n}*/ {\n  // Keep track of active arguments in order to avoid passing\n  // too much stuff around, making signatures long and confusing.\n  // This variable gets reset anytime a checking function is called.\n  let activeArgs\n\n  /**\n   * Check for whitespace *before* a character.\n   *\n   * @param {object} args - Named arguments object\n   * @param {string} args.source - The source string\n   * @param {number} args.index - The index of the character to check before\n   * @param {function} args.err - If a violation is found, this callback\n   *   will be invoked with the relevant warning message.\n   *   Typically this callback will report() the violation.\n   * @param {function} args.errTarget - If a violation is found, this string\n   *   will be sent to the relevant warning message.\n   * @param {string} [args.lineCheckStr] - Single- and multi-line checkers\n   *   will use this string to determine whether they should proceed,\n   *   i.e. if this string is one line only, single-line checkers will check,\n   *   multi-line checkers will ignore.\n   *   If none is passed, they will use `source`.\n   * @param {boolean} [args.onlyOneChar=false] - Only check *one* character before.\n   *   By default, \"always-*\" checks will look for the `targetWhitespace` one\n   *   before and then ensure there is no whitespace two before. This option\n   *   bypasses that second check.\n   * @param {boolean} [args.allowIndentation=false] - Allow arbitrary indentation\n   *   between the `targetWhitespace` (almost definitely a newline) and the `index`.\n   *   With this option, the checker will see if a newline *begins* the whitespace before\n   *   the `index`.\n   */\n  function before(args) {\n    const source = args.source\n    const index = args.index\n    const err = args.err\n    const errTarget = args.errTarget\n    const lineCheckStr = args.lineCheckStr\n    const onlyOneChar = args.onlyOneChar === undefined ? false : args.onlyOneChar\n    const allowIndentation = args.allowIndentation === undefined ? false : args.allowIndentation\n\n    activeArgs = { source, index, err, errTarget, onlyOneChar, allowIndentation }\n    switch (expectation) {\n      case \"always\":\n        expectBefore()\n        break\n      case \"never\":\n        rejectBefore()\n        break\n      case \"always-single-line\":\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        expectBefore(messages.expectedBeforeSingleLine)\n        break\n      case \"never-single-line\":\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        rejectBefore(messages.rejectedBeforeSingleLine)\n        break\n      case \"always-multi-line\":\n        if (isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        expectBefore(messages.expectedBeforeMultiLine)\n        break\n      case \"never-multi-line\":\n        if (isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        rejectBefore(messages.rejectedBeforeMultiLine)\n        break\n      default:\n        throw configurationError(`Unknown expectation \"${expectation}\"`)\n    }\n  }\n\n  /**\n   * Check for whitespace *after* a character.\n   *\n   * Parameters are pretty much the same as for `before()`, above, just substitute\n   * the word \"after\" for \"before\".\n   */\n  function after(args) {\n    const source = args.source\n    const index = args.index\n    const err = args.err\n    const errTarget = args.errTarget\n    const lineCheckStr = args.lineCheckStr\n    const onlyOneChar = args.onlyOneChar === undefined ? false : args.onlyOneChar\n\n    activeArgs = { source, index, err, errTarget, onlyOneChar }\n    switch (expectation) {\n      case \"always\":\n        expectAfter()\n        break\n      case \"never\":\n        rejectAfter()\n        break\n      case \"always-single-line\":\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        expectAfter(messages.expectedAfterSingleLine)\n        break\n      case \"never-single-line\":\n        if (!isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        rejectAfter(messages.rejectedAfterSingleLine)\n        break\n      case \"always-multi-line\":\n        if (isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        expectAfter(messages.expectedAfterMultiLine)\n        break\n      case \"never-multi-line\":\n        if (isSingleLineString(lineCheckStr || source)) {\n          return\n        }\n        rejectAfter(messages.rejectedAfterMultiLine)\n        break\n      default:\n        throw configurationError(`Unknown expectation \"${expectation}\"`)\n    }\n  }\n\n  function beforeAllowingIndentation(obj) {\n    before(Object.assign({}, obj, { allowIndentation: true }))\n  }\n\n  function expectBefore() {\n    const messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.expectedBefore\n\n    if (activeArgs.allowIndentation) {\n      expectBeforeAllowingIndentation(messageFunc)\n      return\n    }\n\n    const _activeArgs = activeArgs\n    const source = _activeArgs.source,\n      index = _activeArgs.index\n\n    const oneCharBefore = source[index - 1]\n    const twoCharsBefore = source[index - 2]\n\n    if (!isValue(oneCharBefore)) {\n      return\n    }\n\n    if (targetWhitespace === \"space\" && oneCharBefore === \" \") {\n      if (activeArgs.onlyOneChar || !isWhitespace(twoCharsBefore)) {\n        return\n      }\n    }\n\n    activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]))\n  }\n\n  function expectBeforeAllowingIndentation() {\n    const messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.expectedBefore\n    const _activeArgs2 = activeArgs\n    const source = _activeArgs2.source,\n      index = _activeArgs2.index,\n      err = _activeArgs2.err\n\n    const expectedChar = function () {\n      if (targetWhitespace === \"newline\") {\n        return \"\\n\"\n      }\n    }()\n    let i = index - 1\n    while (source[i] !== expectedChar) {\n      if (source[i] === \"\\t\" || source[i] === \" \") {\n        i--\n        continue\n      }\n      err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]))\n      return\n    }\n  }\n\n  function rejectBefore() {\n    const messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.rejectedBefore\n    const _activeArgs3 = activeArgs\n    const source = _activeArgs3.source,\n      index = _activeArgs3.index\n\n    const oneCharBefore = source[index - 1]\n\n    if (isValue(oneCharBefore) && isWhitespace(oneCharBefore)) {\n      activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]))\n    }\n  }\n\n  function afterOneOnly(obj) {\n    after(Object.assign({}, obj, { onlyOneChar: true }))\n  }\n\n  function expectAfter() {\n    const messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.expectedAfter\n    const _activeArgs4 = activeArgs\n    const source = _activeArgs4.source,\n      index = _activeArgs4.index\n\n    const oneCharAfter = source[index + 1]\n    const twoCharsAfter = source[index + 2]\n\n    if (!isValue(oneCharAfter)) {\n      return\n    }\n\n    if (targetWhitespace === \"newline\") {\n      // If index is followed by a Windows CR-LF ...\n      if (oneCharAfter === \"\\r\" && twoCharsAfter === \"\\n\") {\n        if (activeArgs.onlyOneChar || !isWhitespace(source[index + 3])) {\n          return\n        }\n      }\n\n      // If index is followed by a Unix LF ...\n      if (oneCharAfter === \"\\n\") {\n        if (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {\n          return\n        }\n      }\n    }\n\n    if (targetWhitespace === \"space\" && oneCharAfter === \" \") {\n      if (activeArgs.onlyOneChar || !isWhitespace(twoCharsAfter)) {\n        return\n      }\n    }\n\n    activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]))\n  }\n\n  function rejectAfter() {\n    const messageFunc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : messages.rejectedAfter\n    const _activeArgs5 = activeArgs\n    const source = _activeArgs5.source,\n      index = _activeArgs5.index\n\n    const oneCharAfter = source[index + 1]\n\n    if (isValue(oneCharAfter) && isWhitespace(oneCharAfter)) {\n      activeArgs.err(messageFunc(activeArgs.errTarget ? activeArgs.errTarget : source[index]))\n    }\n  }\n\n  return {\n    before,\n    beforeAllowingIndentation,\n    after,\n    afterOneOnly,\n  }\n}\n\nfunction isValue(x) {\n  return x !== undefined && x !== null\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/configurationError.js":"/* @flow */\n\"use strict\"\n\n/**\n * Create configurationError from text and set CLI exit code\n */\nmodule.exports = function (text/*: string */)/* Object */ {\n  const err/*: Object*/ = new Error(text)\n  err.code = 78\n  return err\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isSingleLineString.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a string is a single line (i.e. does not contain\n * any newline characters).\n *\n * @param {string} input\n * @return {boolean}\n */\nmodule.exports = function (input/*: string*/)/*: boolean*/ {\n  return !/[\\n\\r]/.test(input)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isWhitespace.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a character is whitespace.\n */\nmodule.exports = function (char/*: string*/)/*: boolean*/ {\n  return [ \" \", \"\\n\", \"\\t\", \"\\r\", \"\\f\" ].indexOf(char) !== -1\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-semicolon-space-before/index.js":"\"use strict\"\n\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"at-rule-semicolon-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\";\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\";\\\"\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      if (hasBlock(atRule)) {\n        return\n      }\n      const nodeString = rawNodeString(atRule)\n\n      checker.before({\n        source: nodeString,\n        index: nodeString.length,\n        err: m => {\n          report({\n            message: m,\n            node: atRule,\n            index: nodeString.length - 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/rawNodeString.js":"/* @flow */\n\"use strict\"\n\n/**\n * Stringify PostCSS node including its raw \"before\" string.\n */\nmodule.exports = function (node/*: Object*/)/*: string*/ {\n  let result = \"\"\n  if (node.raws.before) {\n    result += node.raws.before\n  }\n  result += node.toString()\n  return result\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-name-space-after/index.js":"\"use strict\"\n\nconst atRuleNameSpaceChecker = require(\"../atRuleNameSpaceChecker\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"at-rule-name-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: name => `Expected single space after at-rule name \\\"${name}\\\"`,\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    atRuleNameSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-no-unknown/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst postcss = require(\"postcss\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"at-rule-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: atRule => `Unexpected unknown at-rule \"${atRule}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignoreAtRules: [_.isString],\n      },\n      optional: true,\n    })\n\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      const name = atRule.name\n\n      // Return early if at-rule is to be ignored\n      if (optionsMatches(options, \"ignoreAtRules\", atRule.name)) {\n        return\n      }\n\n      if (\n        postcss.vendor.prefix(name)\n        || keywordSets.atRules.has(name.toLowerCase())\n      ) {\n        return\n      }\n\n      report({\n        message: messages.rejected(`@${name}`),\n        node: atRule,\n        ruleName,\n        result,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/reference/keywordSets.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\n\nconst keywordSets = {}\n\nkeywordSets.nonLengthUnits = new Set([\n  // Relative length units\n  \"%\",\n  // Time length units\n  \"s\",\n  \"ms\",\n  // Angle\n  \"deg\",\n  \"grad\",\n  \"turn\",\n  \"rad\",\n  // Frequency\n  \"Hz\",\n  \"kHz\",\n  // Resolution\n  \"dpi\",\n  \"dpcm\",\n  \"dppx\",\n])\n\nkeywordSets.lengthUnits = new Set([\n  // Relative length units\n  \"em\",\n  \"ex\",\n  \"ch\",\n  \"rem\",\n  // Viewport-percentage lengths\n  \"vh\",\n  \"vw\",\n  \"vmin\",\n  \"vmax\",\n  \"vm\",\n  // Absolute length units\n  \"px\",\n  \"mm\",\n  \"cm\",\n  \"in\",\n  \"pt\",\n  \"pc\",\n  \"q\",\n  // Flexible length units\n  \"fr\",\n])\n\nkeywordSets.units = uniteSets(keywordSets.nonLengthUnits, keywordSets.lengthUnits)\n\nkeywordSets.colorFunctionNames = new Set([\n  \"rgb\",\n  \"rgba\",\n  \"hsl\",\n  \"hsla\",\n  \"hwb\",\n  \"gray\",\n])\n\nkeywordSets.camelCaseFunctionNames = new Set([\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scaleX\",\n  \"scaleY\",\n  \"scaleZ\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skewX\",\n  \"skewY\",\n])\n\nkeywordSets.basicKeywords = new Set([\n  \"initial\",\n  \"inherit\",\n  \"unset\",\n])\n\nkeywordSets.fontFamilyKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"serif\",\n  \"sans-serif\",\n  \"cursive\",\n  \"fantasy\",\n  \"monospace\",\n])\n\nkeywordSets.fontWeightRelativeKeywords = new Set([\n  \"bolder\",\n  \"lighter\",\n])\n\nkeywordSets.fontWeightAbsoluteKeywords = new Set([\"bold\"])\n\nkeywordSets.fontWeightNumericKeywords = new Set([\n  \"100\",\n  \"200\",\n  \"300\",\n  \"400\",\n  \"500\",\n  \"600\",\n  \"700\",\n  \"800\",\n  \"900\",\n])\n\nkeywordSets.fontWeightKeywords = uniteSets(\n  keywordSets.basicKeywords,\n  keywordSets.fontWeightRelativeKeywords,\n  keywordSets.fontWeightAbsoluteKeywords,\n  keywordSets.fontWeightNumericKeywords\n)\n\nkeywordSets.animationNameKeywords = uniteSets(keywordSets.basicKeywords,\n  [\"none\"]\n)\n\nkeywordSets.animationTimingFunctionKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"linear\",\n  \"ease\",\n  \"ease-in\",\n  \"ease-in-out\",\n  \"ease-out\",\n  \"step-start\",\n  \"step-end\",\n  \"steps\",\n  \"cubic-bezier\",\n])\n\nkeywordSets.animationIterationCountKeywords = new Set([\"infinite\"])\n\nkeywordSets.animationDirectionKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"normal\",\n  \"reverse\",\n  \"alternate\",\n  \"alternate-reverse\",\n])\n\nkeywordSets.animationFillModeKeywords = new Set([\n  \"none\",\n  \"forwards\",\n  \"backwards\",\n  \"both\",\n])\n\nkeywordSets.animationPlayStateKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"running\",\n  \"paused\",\n])\n\n// cf. https://developer.mozilla.org/en-US/docs/Web/CSS/animation\nkeywordSets.animationShorthandKeywords = uniteSets(\n  keywordSets.basicKeywords,\n  keywordSets.animationNameKeywords,\n  keywordSets.animationTimingFunctionKeywords,\n  keywordSets.animationIterationCountKeywords,\n  keywordSets.animationDirectionKeywords,\n  keywordSets.animationFillModeKeywords,\n  keywordSets.animationPlayStateKeywords\n)\n\n// These are the ones that can have single-colon notation\nkeywordSets.levelOneAndTwoPseudoElements = new Set([\n  \"before\",\n  \"after\",\n  \"first-line\",\n  \"first-letter\",\n])\n\n// These are the ones that require double-colon notation\nkeywordSets.levelThreePseudoElements = new Set([\n  \"before\",\n  \"after\",\n  \"first-line\",\n  \"first-letter\",\n  \"selection\",\n  \"spelling-error\",\n  \"grammar-error\",\n  \"backdrop\",\n  \"marker\",\n  \"placeholder\",\n  \"shadow\",\n  \"slotted\",\n  \"content\",\n])\n\nkeywordSets.pseudoElements = uniteSets(\n  keywordSets.levelOneAndTwoPseudoElements,\n  keywordSets.levelThreePseudoElements\n)\n\nkeywordSets.aNPlusBNotationPseudoClasses = new Set([\n  \"nth-child\",\n  \"nth-column\",\n  \"nth-last-child\",\n  \"nth-last-column\",\n  \"nth-last-of-type\",\n  \"nth-of-type\",\n])\n\nkeywordSets.linguisticPseudoClasses = new Set([\n  \"dir\",\n  \"lang\",\n])\n\nkeywordSets.otherPseudoClasses = new Set([\n  \"active\",\n  \"any-link\",\n  \"blank\",\n  \"checked\",\n  \"contains\",\n  \"current\",\n  \"default\",\n  \"disabled\",\n  \"drop\",\n  \"empty\",\n  \"enabled\",\n  \"first-child\",\n  \"first-of-type\",\n  \"focus\",\n  \"focus-within\",\n  \"fullscreen\",\n  \"future\",\n  \"has\",\n  \"host\",\n  \"host-context\",\n  \"hover\",\n  \"indeterminate\",\n  \"in-range\",\n  \"invalid\",\n  \"last-child\",\n  \"last-of-type\",\n  \"link\",\n  \"matches\",\n  \"not\",\n  \"only-child\",\n  \"only-of-type\",\n  \"optional\",\n  \"out-of-range\",\n  \"past\",\n  \"placeholder-shown\",\n  \"read-only\",\n  \"read-write\",\n  \"required\",\n  \"root\",\n  \"scope\",\n  \"target\",\n  \"user-error\",\n  \"user-invalid\",\n  \"val\",\n  \"valid\",\n  \"visited\",\n])\n\nkeywordSets.webkitProprietaryPseudoElements = new Set([\n  \"scrollbar\",\n  \"scrollbar-button\",\n  \"scrollbar-track\",\n  \"scrollbar-track-piece\",\n  \"scrollbar-thumb\",\n  \"scrollbar-corner\",\n  \"resize\",\n])\n\nkeywordSets.webkitProprietaryPseudoClasses = new Set([\n  \"horizontal\",\n  \"vertical\",\n  \"decrement\",\n  \"increment\",\n  \"start\",\n  \"end\",\n  \"double-button\",\n  \"single-button\",\n  \"no-button\",\n  \"corner-present\",\n  \"window-inactive\",\n])\n\nkeywordSets.pseudoClasses = uniteSets(\n  keywordSets.aNPlusBNotationPseudoClasses,\n  keywordSets.linguisticPseudoClasses,\n  keywordSets.otherPseudoClasses\n)\n\nkeywordSets.shorthandTimeProperties = new Set([\n  \"transition\",\n  \"animation\",\n])\n\nkeywordSets.longhandTimeProperties = new Set([\n  \"transition-duration\",\n  \"transition-delay\",\n  \"animation-duration\",\n  \"animation-delay\",\n])\n\nkeywordSets.timeProperties = uniteSets(\n  keywordSets.shorthandTimeProperties,\n  keywordSets.longhandTimeProperties\n)\n\nkeywordSets.camelCaseKeywords = new Set([\n  \"optimizeSpeed\",\n  \"optimizeQuality\",\n  \"optimizeLegibility\",\n  \"geometricPrecision\",\n  \"currentColor\",\n  \"crispEdges\",\n  \"visiblePainted\",\n  \"visibleFill\",\n  \"visibleStroke\",\n  \"sRGB\",\n  \"linearRGB\",\n])\n\n// https://developer.mozilla.org/docs/Web/CSS/counter-increment\nkeywordSets.counterIncrementKeywords = uniteSets(keywordSets.basicKeywords, [\"none\"])\n\nkeywordSets.counterResetKeywords = uniteSets(keywordSets.basicKeywords, [\"none\"])\n\nkeywordSets.gridRowKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"auto\",\n  \"span\",\n])\n\nkeywordSets.gridColumnKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"auto\",\n  \"span\",\n])\n\nkeywordSets.gridAreaKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"auto\",\n  \"span\",\n])\n\n// https://developer.mozilla.org/ru/docs/Web/CSS/list-style-type\nkeywordSets.listStyleTypeKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"none\",\n  \"disc\",\n  \"circle\",\n  \"square\",\n  \"decimal\",\n  \"cjk-decimal\",\n  \"decimal-leading-zero\",\n  \"lower-roman\",\n  \"upper-roman\",\n  \"lower-greek\",\n  \"lower-alpha\",\n  \"lower-latin\",\n  \"upper-alpha\",\n  \"upper-latin\",\n  \"arabic-indic\",\n  \"armenian\",\n  \"bengali\",\n  \"cambodian\",\n  \"cjk-earthly-branch\",\n  \"cjk-ideographic\",\n  \"devanagari\",\n  \"ethiopic-numeric\",\n  \"georgian\",\n  \"gujarati\",\n  \"gurmukhi\",\n  \"hebrew\",\n  \"hiragana\",\n  \"hiragana-iroha\",\n  \"japanese-formal\",\n  \"japanese-informal\",\n  \"kannada\",\n  \"katakana\",\n  \"katakana-iroha\",\n  \"khmer\",\n  \"korean-hangul-formal\",\n  \"korean-hanja-formal\",\n  \"korean-hanja-informal\",\n  \"lao\",\n  \"lower-armenian\",\n  \"malayalam\",\n  \"mongolian\",\n  \"myanmar\",\n  \"oriya\",\n  \"persian\",\n  \"simp-chinese-formal\",\n  \"simp-chinese-informal\",\n  \"tamil\",\n  \"telugu\",\n  \"thai\",\n  \"tibetan\",\n  \"trad-chinese-formal\",\n  \"trad-chinese-informal\",\n  \"upper-armenian\",\n  \"disclosure-open\",\n  \"disclosure-closed\",\n  // Non-standard extensions (without prefixe)\n  \"ethiopic-halehame\",\n  \"ethiopic-halehame-am\",\n  \"ethiopic-halehame-ti-er\",\n  \"ethiopic-halehame-ti-et\",\n  \"hangul\",\n  \"hangul-consonant\",\n  \"urdu\",\n])\n\nkeywordSets.listStylePositionKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"inside\",\n  \"outside\",\n])\n\nkeywordSets.listStyleImageKeywords = uniteSets(keywordSets.basicKeywords, [\"none\"])\n\nkeywordSets.listStyleShorthandKeywords = uniteSets(\n  keywordSets.basicKeywords,\n  keywordSets.listStyleTypeKeywords,\n  keywordSets.listStylePositionKeywords,\n  keywordSets.listStyleImageKeywords\n)\n\nkeywordSets.fontStyleKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"normal\",\n  \"italic\",\n  \"oblique\",\n])\n\nkeywordSets.fontVariantKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"normal\",\n  \"none\",\n  \"historical-forms\",\n  \"none\",\n  \"common-ligatures\",\n  \"no-common-ligatures\",\n  \"discretionary-ligatures\",\n  \"no-discretionary-ligatures\",\n  \"historical-ligatures\",\n  \"no-historical-ligatures\",\n  \"contextual\",\n  \"no-contextual\",\n  \"small-caps\",\n  \"small-caps\",\n  \"all-small-caps\",\n  \"petite-caps\",\n  \"all-petite-caps\",\n  \"unicase\",\n  \"titling-caps\",\n  \"lining-nums\",\n  \"oldstyle-nums\",\n  \"proportional-nums\",\n  \"tabular-nums\",\n  \"diagonal-fractions\",\n  \"stacked-fractions\",\n  \"ordinal\",\n  \"slashed-zero\",\n  \"jis78\",\n  \"jis83\",\n  \"jis90\",\n  \"jis04\",\n  \"simplified\",\n  \"traditional\",\n  \"full-width\",\n  \"proportional-width\",\n  \"ruby\",\n])\n\nkeywordSets.fontStretchKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"semi-condensed\",\n  \"condensed\",\n  \"extra-condensed\",\n  \"ultra-condensed\",\n  \"semi-expanded\",\n  \"expanded\",\n  \"extra-expanded\",\n  \"ultra-expanded\",\n])\n\nkeywordSets.fontSizeKeywords = uniteSets(keywordSets.basicKeywords, [\n  \"xx-small\",\n  \"x-small\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"x-large\",\n  \"xx-large\",\n  \"larger\",\n  \"smaller\",\n])\n\nkeywordSets.lineHeightKeywords = uniteSets(keywordSets.basicKeywords, [\"normal\"])\n\nkeywordSets.fontShorthandKeywords = uniteSets(\n  keywordSets.basicKeywords,\n  keywordSets.fontStyleKeywords,\n  keywordSets.fontVariantKeywords,\n  keywordSets.fontWeightKeywords,\n  keywordSets.fontStretchKeywords,\n  keywordSets.fontSizeKeywords,\n  keywordSets.lineHeightKeywords, keywordSets.fontFamilyKeywords\n)\n\nkeywordSets.keyframeSelectorKeywords = new Set([\n  \"from\",\n  \"to\",\n])\n\n// https://developer.mozilla.org/en/docs/Web/CSS/At-rule\nkeywordSets.atRules = new Set([\n  \"apply\",\n  \"annotation\",\n  \"character-variant\",\n  \"charset\",\n  \"counter-style\",\n  \"custom-media\",\n  \"custom-selector\",\n  \"document\",\n  \"font-face\",\n  \"font-feature-values\",\n  \"import\",\n  \"keyframes\",\n  \"media\",\n  \"namespace\",\n  \"nest\",\n  \"ornaments\",\n  \"page\",\n  \"styleset\",\n  \"stylistic\",\n  \"supports\",\n  \"swash\",\n  \"viewport\",\n])\n\n// https://drafts.csswg.org/mediaqueries/#descdef-media-update\nkeywordSets.deprecatedMediaFeatureNames = new Set([\n  \"device-aspect-ratio\",\n  \"device-height\",\n  \"device-width\",\n  \"max-device-aspect-ratio\",\n  \"max-device-height\",\n  \"max-device-width\",\n  \"min-device-aspect-ratio\",\n  \"min-device-height\",\n  \"min-device-width\",\n])\n\n// https://drafts.csswg.org/mediaqueries/#descdef-media-update\nkeywordSets.mediaFeatureNames = uniteSets(keywordSets.deprecatedMediaFeatureNames, [\n  \"any-hover\",\n  \"any-pointer\",\n  \"aspect-ratio\",\n  \"color\",\n  \"color-gamut\",\n  \"color-index\",\n  \"grid\",\n  \"height\",\n  \"hover\",\n  \"max-aspect-ratio\",\n  \"max-color\",\n  \"max-color-index\",\n  \"max-height\",\n  \"max-monochrome\",\n  \"max-resolution\",\n  \"max-width\",\n  \"min-aspect-ratio\",\n  \"min-color\",\n  \"min-color-index\",\n  \"min-height\",\n  \"min-monochrome\",\n  \"min-resolution\",\n  \"min-width\",\n  \"monochrome\",\n  \"orientation\",\n  \"overflow-block\",\n  \"overflow-inline\",\n  \"pointer\",\n  \"resolution\",\n  \"scan\",\n  \"scripting\",\n  \"update\",\n  \"width\",\n])\n\n// https://www.w3.org/TR/CSS22/ui.html#system-colors\nkeywordSets.systemColors = new Set([\n  \"activeborder\",\n  \"activecaption\",\n  \"appworkspace\",\n  \"background\",\n  \"buttonface\",\n  \"buttonhighlight\",\n  \"buttonshadow\",\n  \"buttontext\",\n  \"captiontext\",\n  \"graytext\",\n  \"highlight\",\n  \"highlighttext\",\n  \"inactiveborder\",\n  \"inactivecaption\",\n  \"inactivecaptiontext\",\n  \"infobackground\",\n  \"infotext\",\n  \"menu\",\n  \"menutext\",\n  \"scrollbar\",\n  \"threeddarkshadow\",\n  \"threedface\",\n  \"threedhighlight\",\n  \"threedlightshadow\",\n  \"threedshadow\",\n  \"window\",\n  \"windowframe\",\n  \"windowtext\",\n])\n\nfunction uniteSets() {\n  const sets = Array.from(arguments)\n\n  return new Set(sets.reduce((result, set) => {\n    return result.concat(_.toArray(set))\n  }, []))\n}\n\nmodule.exports = keywordSets\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-no-vendor-prefix/index.js":"\"use strict\"\n\nconst isAutoprefixable = require(\"../../utils/isAutoprefixable\")\nconst isStandardSyntaxAtRule = require(\"../../utils/isStandardSyntaxAtRule\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"at-rule-no-vendor-prefix\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: p => `Unexpected vendor-prefixed at-rule \"@${p}\"`,\n})\n\nconst rule = function (actual) {\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      if (!isStandardSyntaxAtRule(atRule)) {\n        return\n      }\n\n      const name = atRule.name\n\n      if (name[0] !== \"-\") {\n        return\n      }\n\n      if (!isAutoprefixable.atRuleName(name)) {\n        return\n      }\n\n      report({\n        message: messages.rejected(name),\n        node: atRule,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isAutoprefixable.js":"/* @flow */\n\"use strict\"\n\nconst Browsers = require(\"autoprefixer/lib/browsers\")\nconst Prefixes = require(\"autoprefixer/lib/prefixes\")\nconst autoprefixer = require(\"autoprefixer\")\n\n/**\n * Use Autoprefixer's secret powers to determine whether or\n * not a certain CSS identifier contains a vendor prefix that\n * Autoprefixer, given the standardized identifier, could add itself.\n *\n * Used by `*-no-vendor-prefix-*` rules to find superfluous\n * vendor prefixes.\n */\n\nconst prefixes = new Prefixes(autoprefixer.data.prefixes, new Browsers(autoprefixer.data.browsers, []))\n\n/**\n * Most identifier types have to be looked up in a unique way,\n * so we're exposing special functions for each.\n */\nmodule.exports = {\n\n  atRuleName(identifier/*: string*/)/*: boolean*/ {\n    return prefixes.remove[`@${identifier.toLowerCase()}`]\n  },\n\n  selector(identifier/*: string*/)/*: boolean*/ {\n    return prefixes.remove.selectors.some(selectorObj => {\n      return identifier.toLowerCase() === selectorObj.prefixed\n    })\n  },\n\n  mediaFeatureName(identifier/*: string*/)/*: boolean*/ {\n    return identifier.toLowerCase().indexOf(\"device-pixel-ratio\") !== -1\n  },\n\n  property(identifier/*: string*/)/*: boolean*/ {\n    return autoprefixer.data.prefixes[prefixes.unprefixed(identifier.toLowerCase())]\n  },\n\n  propertyValue(prop/*: string*/, value/*: string*/)/*: boolean*/ {\n    const possiblePrefixableValues = prefixes.remove[prop.toLowerCase()] && prefixes.remove[prop.toLowerCase()].values\n    return possiblePrefixableValues && possiblePrefixableValues.some(valueObj => {\n      return value.toLowerCase() === valueObj.prefixed\n    })\n  },\n\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-semicolon-newline-after/index.js":"\"use strict\"\n\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst nextNonCommentNode = require(\"../../utils/nextNonCommentNode\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"at-rule-semicolon-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\";\\\"\",\n})\n\nconst rule = function (actual) {\n  const checker = whitespaceChecker(\"newline\", actual, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual,\n      possible: [\"always\"],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      const nextNode = atRule.next()\n      if (!nextNode) {\n        return\n      }\n      if (hasBlock(atRule)) {\n        return\n      }\n\n      // Allow an end-of-line comment\n      const nodeToCheck = nextNonCommentNode(nextNode)\n      if (!nodeToCheck) {\n        return\n      }\n\n      checker.afterOneOnly({\n        source: rawNodeString(nodeToCheck),\n        index: -1,\n        err: msg => {\n          report({\n            message: msg,\n            node: atRule,\n            index: atRule.toString().length + 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/nextNonCommentNode.js":"/* @flow */\n\"use strict\"\n\n/**\n * Get the next non-comment node in a PostCSS AST\n * at or after a given node.\n */\nmodule.exports = function nextNonCommentNode(startNode/*: Object*/)/*: ?Object*/ {\n  if (!startNode || !startNode.next) return null\n\n  if (startNode.type === \"comment\") {\n    return nextNonCommentNode(startNode.next())\n  }\n\n  return startNode\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/at-rule-whitelist/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"at-rule-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected at-rule \"${name}\"`,\n})\n\nconst rule = function (whitelistInput) {\n  // To allow for just a string as a parameter (not only arrays of strings)\n  const whitelist = [].concat(whitelistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      const name = atRule.name\n\n      if (whitelist.indexOf(postcss.vendor.unprefixed(name).toLowerCase()) !== -1) {\n        return\n      }\n\n      report({\n        message: messages.rejected(name),\n        node: atRule,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-closing-brace-empty-line-before/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst hasEmptyLine = require(\"../../utils/hasEmptyLine\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"block-closing-brace-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before closing brace\",\n  rejected: \"Unexpected empty line before closing brace\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always-multi-line\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      // Get whitespace after \"\"}\", ignoring extra semicolon\n      const before = (statement.raws.after || \"\").replace(/;+/, \"\")\n      if (before === undefined) {\n        return\n      }\n\n      // Calculate index\n      const statementString = statement.toString()\n      let index = statementString.length - 1\n      if (statementString[index - 1] === \"\\r\") {\n        index -= 1\n      }\n\n      // Set expectation\n      const expectEmptyLineBefore = expectation === \"always-multi-line\"\n        && !isSingleLineString(blockString(statement))\n          ? true\n          : false\n\n      // Check for at least one empty line\n      const hasEmptyLineBefore = hasEmptyLine(before)\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return\n      }\n\n      const message = expectEmptyLineBefore\n        ? messages.expected\n        : messages.rejected\n\n      report({\n        message,\n        result,\n        ruleName,\n        node: statement,\n        index,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/blockString.js":"/* @flow */\n\"use strict\"\nconst beforeBlockString = require(\"./beforeBlockString\")\nconst hasBlock = require(\"./hasBlock\")\nconst rawNodeString = require(\"./rawNodeString\")\n\n/**\n * Return a CSS statement's block -- the string that starts and `{` and ends with `}`.\n *\n * If the statement has no block (e.g. `@import url(foo.css);`),\n * return undefined.\n *\n * @param {Rule|AtRule} statement - postcss rule or at-rule node\n * @return {string|undefined}\n */\nmodule.exports = function (statement/*: postcss$rule | postcss$atRule*/)/*: string | boolean*/ {\n  if (!hasBlock(statement)) {\n    return false\n  }\n  return rawNodeString(statement).slice(beforeBlockString(statement).length)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/beforeBlockString.js":"/* @flow */\n\"use strict\"\nmodule.exports = function (\n  statement/*: Object*/,\n  options/*:: ?: Object*/\n)/*: string*/ {\n  options = options || {}\n\n  let result = \"\"\n  let rule/*: postcss$rule*/\n  let atRule/*: postcss$atRule*/\n\n  if (statement.type === \"rule\") {\n    rule = statement\n  }\n  if (statement.type === \"atrule\") {\n    atRule = statement\n  }\n\n  if (!rule && !atRule) {\n    return result\n  }\n\n  const before = (statement.raws.before || \"\")\n\n  if (!options.noRawBefore) {\n    result += before\n  }\n  if (rule) {\n    result += rule.selector\n  }\n  if (atRule) {\n    result += \"@\" + atRule.name + (atRule.raws.afterName || \"\") + atRule.params\n  }\n\n  const between = statement.raws.between\n\n  if (between !== undefined) {\n    result += between\n  }\n\n  return result\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasEmptyBlock.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a statement has an empty block.\n *\n * @param {Rule|AtRule} statement - postcss rule or at-rule node\n * @return {boolean} True if the statement has a block and it is empty\n */\nmodule.exports = function (\n  statement/*: postcss$rule | postcss$atRule*/\n)/*: boolean*/ {\n  return statement.nodes !== undefined // has block\n  && statement.nodes.length === 0 // and is empty\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-closing-brace-newline-after/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-closing-brace-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\"}\\\"\",\n  expectedAfterSingleLine: () => \"Expected newline after \\\"}\\\" of a single-line block\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\"}\\\" of a single-line block\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\"}\\\" of a multi-line block\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\"}\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation, options) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-single-line\",\n        \"never-single-line\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignoreAtRules: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      if (!hasBlock(statement)) {\n        return\n      }\n      if (optionsMatches(options, \"ignoreAtRules\", statement.name)) {\n        return\n      }\n\n      const nextNode = statement.next()\n      if (!nextNode) {\n        return\n      }\n\n      // Allow an end-of-line comment x spaces after the brace\n      const nextNodeIsSingleLineComment = nextNode.type === \"comment\"\n        && !/[^ ]/.test((nextNode.raws.before || \"\"))\n        && nextNode.toString().indexOf(\"\\n\") === -1\n\n      const nodeToCheck = nextNodeIsSingleLineComment\n        ? nextNode.next()\n        : nextNode\n\n      if (!nodeToCheck) {\n        return\n      }\n\n      let reportIndex = statement.toString().length\n      let source = rawNodeString(nodeToCheck)\n\n      // Skip a semicolon at the beginning, if any\n      if (\n        source\n        && source[0] === \";\"\n      ) {\n        source = source.slice(1)\n        reportIndex++\n      }\n\n      // Only check one after, because there might be other\n      // spaces handled by the indentation rule\n      checker.afterOneOnly({\n        source,\n        index: -1,\n        lineCheckStr: blockString(statement),\n        err: msg => {\n          report({\n            message: msg,\n            node: statement,\n            index: reportIndex,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-closing-brace-newline-before/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"block-closing-brace-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: \"Expected newline before \\\"}\\\"\",\n  expectedBeforeMultiLine: \"Expected newline before \\\"}\\\" of a multi-line block\",\n  rejectedBeforeMultiLine: \"Unexpected whitespace before \\\"}\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      // Ignore extra semicolon\n      const after = (statement.raws.after || \"\").replace(/;+/, \"\")\n      if (after === undefined) {\n        return\n      }\n\n      const blockIsMultiLine = !isSingleLineString(blockString(statement))\n      const statementString = statement.toString()\n\n      let index = statementString.length - 2\n      if (statementString[index - 1] === \"\\r\") {\n        index -= 1\n      }\n\n      // We're really just checking whether a\n      // newline *starts* the block's final space -- between\n      // the last declaration and the closing brace. We can\n      // ignore any other whitespace between them, because that\n      // will be checked by the indentation rule.\n      if (\n        !_.startsWith(after, \"\\n\")\n        && !_.startsWith(after, \"\\r\\n\")\n      ) {\n        if (expectation === \"always\") {\n          complain(messages.expectedBefore)\n        } else if (\n          blockIsMultiLine\n          && expectation === \"always-multi-line\"\n        ) {\n          complain(messages.expectedBeforeMultiLine)\n        }\n      }\n\n      if (\n        after !== \"\"\n        && blockIsMultiLine\n        && expectation === \"never-multi-line\"\n      ) {\n        complain(messages.rejectedBeforeMultiLine)\n      }\n\n      function complain(message) {\n        report({\n          message,\n          result,\n          ruleName,\n          node: statement,\n          index,\n        })\n      }\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-closing-brace-space-after/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-closing-brace-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\"}\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\"}\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\"}\\\" of a single-line block\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\"}\\\" of a single-line block\",\n  expectedAfterMultiLine: () => \"Expected single space after \\\"}\\\" of a multi-line block\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\"}\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      const nextNode = statement.next()\n      if (!nextNode) {\n        return\n      }\n      if (!hasBlock(statement)) {\n        return\n      }\n\n      let reportIndex = statement.toString().length\n      let source = rawNodeString(nextNode)\n\n      // Skip a semicolon at the beginning, if any\n      if (\n        source\n        && source[0] === \";\"\n      ) {\n        source = source.slice(1)\n        reportIndex++\n      }\n\n      checker.after({\n        source,\n        index: -1,\n        lineCheckStr: blockString(statement),\n        err: msg => {\n          report({\n            message: msg,\n            node: statement,\n            index: reportIndex,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-closing-brace-space-before/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-closing-brace-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\"}\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\"}\\\"\",\n  expectedBeforeSingleLine: () => \"Expected single space before \\\"}\\\" of a single-line block\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\"}\\\" of a single-line block\",\n  expectedBeforeMultiLine: () => \"Expected single space before \\\"}\\\" of a multi-line block\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\"}\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual : expectation,\n      possible : [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statement: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      const source = blockString(statement)\n      const statementString = statement.toString()\n\n      let index = statementString.length - 2\n      if (statementString[index - 1] === \"\\r\") {\n        index -= 1\n      }\n\n      checker.before({\n        source,\n        index: source.length - 1,\n        err: msg => {\n          report({\n            message: msg,\n            node: statement,\n            index,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-no-empty/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"block-no-empty\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected empty block\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      if (!hasEmptyBlock(statement)) {\n        return\n      }\n\n      let index = beforeBlockString(statement, { noRawBefore: true }).length\n\n      // For empty blocks when using SugarSS parser\n      if (statement.raws.between === undefined) {\n        index--\n      }\n\n      report({\n        message: messages.rejected,\n        node: statement,\n        index,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-no-single-line/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"block-no-single-line\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected single-line block\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      \"'block-no-single-line' has been deprecated and in 8.0 will be removed. \" +\n      \"Instead use 'block-opening-brace-newline-after' and 'block-closing-brace-newline-before' with the \\\"always\\\" option.\"\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: \"https://stylelint.io/user-guide/rules/block-no-single-line/\",\n    })\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n      if (!isSingleLineString(blockString(statement))) {\n        return\n      }\n\n      report({\n        message: messages.rejected,\n        node: statement,\n        index: beforeBlockString(statement, { noRawBefore: true }).length,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-opening-brace-newline-after/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst nextNonCommentNode = require(\"../../utils/nextNonCommentNode\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-opening-brace-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\"{\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\"{\\\" of a multi-line block\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\"{\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statement: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has an empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      // Allow an end-of-line comment\n      const nodeToCheck = nextNonCommentNode(statement.first)\n      if (!nodeToCheck) {\n        return\n      }\n\n      checker.afterOneOnly({\n        source: rawNodeString(nodeToCheck),\n        index: -1,\n        lineCheckStr: blockString(statement),\n        err: m => {\n          report({\n            message: m,\n            node: statement,\n            index: beforeBlockString(statement, { noRawBefore: true }).length + 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-opening-brace-newline-before/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-opening-brace-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected newline before \\\"{\\\"\",\n  expectedBeforeSingleLine: () => \"Expected newline before \\\"{\\\" of a single-line block\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\"{\\\" of a single-line block\",\n  expectedBeforeMultiLine: () => \"Expected newline before \\\"{\\\" of a multi-line block\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\"{\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual : expectation,\n      possible : [\n        \"always\",\n        \"always-single-line\",\n        \"never-single-line\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statement: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has an empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      const source = beforeBlockString(statement)\n      const beforeBraceNoRaw = beforeBlockString(statement, { noRawBefore: true })\n\n      let index = beforeBraceNoRaw.length - 1\n      if (beforeBraceNoRaw[index - 1] === \"\\r\") {\n        index -= 1\n      }\n\n      checker.beforeAllowingIndentation({\n        lineCheckStr: blockString(statement),\n        source,\n        index: source.length,\n        err: m => {\n          report({\n            message: m,\n            node: statement,\n            index,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-opening-brace-space-after/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-opening-brace-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\"{\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\"{\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\"{\\\" of a single-line block\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\"{\\\" of a single-line block\",\n  expectedAfterMultiLine: () => \"Expected single space after \\\"{\\\" of a multi-line block\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\"{\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has an empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      checker.after({\n        source: blockString(statement),\n        index: 0,\n        err: m => {\n          report({\n            message: m,\n            node: statement,\n            index: beforeBlockString(statement, { noRawBefore: true }).length + 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/block-opening-brace-space-before/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blockString = require(\"../../utils/blockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"block-opening-brace-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\"{\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\"{\\\"\",\n  expectedBeforeSingleLine: () => \"Expected single space before \\\"{\\\" of a single-line block\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\"{\\\" of a single-line block\",\n  expectedBeforeMultiLine: () => \"Expected single space before \\\"{\\\" of a multi-line block\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\"{\\\" of a multi-line block\",\n})\n\nconst rule = function (expectation, options) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignoreAtRules: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Check both kinds of statements: rules and at-rules\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      // Return early if blockless or has an empty block\n      if (\n        !hasBlock(statement)\n        || hasEmptyBlock(statement)\n      ) {\n        return\n      }\n\n      // Return early if at-rule is to be ignored\n      if (optionsMatches(options, \"ignoreAtRules\", statement.name)) {\n        return\n      }\n\n      const source = beforeBlockString(statement)\n      const beforeBraceNoRaw = beforeBlockString(statement, { noRawBefore: true })\n\n      let index = beforeBraceNoRaw.length - 1\n      if (beforeBraceNoRaw[index - 1] === \"\\r\") {\n        index -= 1\n      }\n\n      checker.before({\n        source,\n        index: source.length,\n        lineCheckStr: blockString(statement),\n        err: m => {\n          report({\n            message: m,\n            node: statement,\n            index,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/color-hex-case/index.js":"\"use strict\"\n\nconst blurFunctionArguments = require(\"../../utils/blurFunctionArguments\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst styleSearch = require(\"style-search\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"color-hex-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const declString = blurFunctionArguments(decl.toString(), \"url\")\n      styleSearch({ source: declString, target: \"#\" }, match => {\n        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))\n        if (!hexMatch) {\n          return\n        }\n\n        const hexValue = hexMatch[0]\n        const hexValueLower = hexValue.toLowerCase()\n        const hexValueUpper = hexValue.toUpperCase()\n        const expectedHex = expectation === \"lower\"\n          ? hexValueLower\n          : hexValueUpper\n\n        if (hexValue === expectedHex) {\n          return\n        }\n\n        report({\n          message: messages.expected(hexValue, expectedHex),\n          node: decl,\n          index: match.startIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/blurFunctionArguments.js":"/* @flow */\n\"use strict\"\nconst _ = require(\"lodash\")\nconst balancedMatch = require(\"balanced-match\")\n\n/**\n * Replace all of the characters that are arguments to a certain\n * CSS function with some innocuous character.\n *\n * This is useful if you need to use a RegExp to find a string\n * but want to ignore matches in certain functions (e.g. `url()`,\n * which might contain all kinds of false positives).\n *\n * For example:\n * blurFunctionArguments(\"abc url(abc) abc\", \"url\") === \"abc url(```) abc\"\n *\n * @param {string} source\n * @param {string} functionName\n * @param {[string]} blurChar=\"`\"\n * @return {string} - The result string, with the function arguments \"blurred\"\n */\nmodule.exports = function (source/*: string*/, functionName/*: string*/)/*: string*/ {\n  const blurChar/*: string*/ = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"`\"\n\n  const nameWithParen = `${functionName.toLowerCase()}(`\n  const lowerCaseSource = source.toLowerCase()\n  if (!_.includes(lowerCaseSource, nameWithParen)) {\n    return source\n  }\n\n  const functionNameLength/*: number*/ = functionName.length\n\n  let result = source\n  let searchStartIndex = 0\n  while (lowerCaseSource.indexOf(nameWithParen, searchStartIndex) !== -1) {\n    const openingParenIndex = lowerCaseSource.indexOf(nameWithParen, searchStartIndex) + functionNameLength\n    const closingParenIndex = balancedMatch(\"(\", \")\", lowerCaseSource.slice(openingParenIndex)).end + openingParenIndex\n    const argumentsLength = closingParenIndex - openingParenIndex - 1\n    result = result.slice(0, openingParenIndex + 1) + _.repeat(blurChar, argumentsLength) + result.slice(closingParenIndex)\n    searchStartIndex = closingParenIndex\n  }\n  return result\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/color-hex-length/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"color-hex-length\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"short\",\n        \"long\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const declString = decl.toString()\n\n      styleSearch({ source: declString, target: \"#\" }, match => {\n        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))\n        if (!hexMatch) {\n          return\n        }\n\n        const hexValue = hexMatch[0]\n\n        if (\n          expectation === \"long\"\n          && hexValue.length !== 4\n          && hexValue.length !== 5\n        ) {\n          return\n        }\n\n        if (\n          expectation === \"short\"\n          && (\n            hexValue.length < 6\n            || !canShrink(hexValue)\n          )\n        ) {\n          return\n        }\n\n        const variant = expectation === \"long\"\n          ? longer\n          : shorter\n\n        report({\n          message: messages.expected(hexValue, variant(hexValue)),\n          node: decl,\n          index: match.startIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nfunction canShrink(hex) {\n  hex = hex.toLowerCase()\n\n  return hex[1] === hex[2]\n    && hex[3] === hex[4]\n    && hex[5] === hex[6]\n    && (hex.length === 7\n      || hex.length === 9\n      && hex[7] === hex[8]\n    )\n}\n\nfunction shorter(hex) {\n  let hexVariant = \"#\"\n  for (let i = 1; i < hex.length; i = i + 2) {\n    hexVariant += hex[i]\n  }\n  return hexVariant\n}\n\nfunction longer(hex) {\n  let hexVariant = \"#\"\n  for (let i = 1; i < hex.length; i++) {\n    hexVariant += hex[i] + hex[i]\n  }\n  return hexVariant\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/color-named/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isStandardSyntaxFunction = require(\"../../utils/isStandardSyntaxFunction\")\nconst isStandardSyntaxValue = require(\"../../utils/isStandardSyntaxValue\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst namedColorData = require(\"../../reference/namedColorData\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst propertySets = require(\"../../reference/propertySets\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"color-named\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (named, original) => `Expected \"${original}\" to be \"${named}\"`,\n  rejected: named => `Unexpected named color \"${named}\"`,\n})\n\n// Todo tested on case insensivity\nconst NODE_TYPES = [\n  \"word\",\n  \"function\",\n]\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"never\",\n        \"always-where-possible\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignoreProperties: [_.isString],\n        ignore: [\"inside-function\"],\n      },\n      optional: true,\n    })\n\n    if (!validOptions) {\n      return\n    }\n\n    const namedColors = Object.keys(namedColorData)\n\n    root.walkDecls(decl => {\n      if (propertySets.acceptCustomIdents.has(decl.prop)) {\n        return\n      }\n\n      // Return early if the property is to be ignored\n      if (optionsMatches(options, \"ignoreProperties\", decl.prop)) {\n        return\n      }\n\n      valueParser(decl.value).walk(node => {\n        const value = node.value,\n          type = node.type,\n          sourceIndex = node.sourceIndex\n\n        if (\n          optionsMatches(options, \"ignore\", \"inside-function\")\n          && type === \"function\"\n        ) {\n          return false\n        }\n\n        if (!isStandardSyntaxFunction(node)) {\n          return false\n        }\n\n        if (!isStandardSyntaxValue(value)) {\n          return\n        }\n        // Return early if neither a word nor a function\n        if (NODE_TYPES.indexOf(type) === -1) {\n          return\n        }\n\n        // Check for named colors for \"never\" option\n        if (\n          expectation === \"never\"\n          && type === \"word\"\n          && namedColors.indexOf(value.toLowerCase()) !== -1\n        ) {\n          complain(messages.rejected(value), decl, declarationValueIndex(decl) + sourceIndex)\n          return\n        }\n\n        // Check \"always-where-possible\" option ...\n        if (expectation !== \"always-where-possible\") {\n          return\n        }\n\n        // First by checking for alternative color function representations ...\n        if (\n          type === \"function\"\n          && keywordSets.colorFunctionNames.has(value.toLowerCase())\n        ) {\n          // Remove all spaces to match what's in `representations`\n          const normalizedFunctionString = valueParser.stringify(node).replace(/\\s+/g, \"\")\n          let namedColor\n          for (let i = 0, l = namedColors.length; i < l; i++) {\n            namedColor = namedColors[i]\n            if (namedColorData[namedColor].func.indexOf(normalizedFunctionString.toLowerCase()) !== -1) {\n              complain(messages.expected(namedColor, normalizedFunctionString), decl, declarationValueIndex(decl) + sourceIndex)\n              return // Exit as soon as a problem is found\n            }\n          }\n          return\n        }\n\n        // Then by checking for alternative hex representations\n        let namedColor\n        for (let i = 0, l = namedColors.length; i < l; i++) {\n          namedColor = namedColors[i]\n          if (namedColorData[namedColor].hex.indexOf(value.toLowerCase()) !== -1) {\n            complain(messages.expected(namedColor, value), decl, declarationValueIndex(decl) + sourceIndex)\n            return // Exit as soon as a problem is found\n          }\n        }\n      })\n    })\n\n    function complain(message, node, index) {\n      report({\n        result,\n        ruleName,\n        message,\n        node,\n        index,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/declarationValueIndex.js":"/* @flow */\n\"use strict\"\n\n/**\n * Get the index of a declaration's value\n */\nmodule.exports = function (decl/*: Object*/)/*: number*/ {\n  const beforeColon = decl.toString().indexOf(\":\")\n  const afterColon = decl.raw(\"between\").length - decl.raw(\"between\").indexOf(\":\")\n  return beforeColon + afterColon\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxFunction.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a function is standard\n */\nmodule.exports = function (node/*: Object*/)/*: boolean*/ {\n  // Function nodes without names are things in parentheses like Sass lists\n  if (!node.value) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxValue.js":"/* @flow */\n\"use strict\"\n\nconst hasInterpolation = require(\"../utils/hasInterpolation\")\n/**\n * Check whether a value is standard\n */\nmodule.exports = function (value/*: string*/)/*: boolean*/ {\n  // SCSS variable\n  if (value[0] === \"$\") {\n    return false\n  }\n\n  // Less variable\n  if (value[0] === \"@\") {\n    return false\n  }\n\n  // SCSS or Less interpolation\n  if (hasInterpolation(value)) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasInterpolation.js":"/* @flow */\n\"use strict\"\n\nconst hasLessInterpolation = require(\"../utils/hasLessInterpolation\")\nconst hasPsvInterpolation = require(\"../utils/hasPsvInterpolation\")\nconst hasScssInterpolation = require(\"../utils/hasScssInterpolation\")\n/**\n * Check whether a string has interpolation\n *\n * @param {string} string\n * @return {boolean} If `true`, a string has interpolation\n */\nmodule.exports = function (string/*: string*/)/*: boolean*/ {\n  // SCSS or Less interpolation\n  if (hasLessInterpolation(string) || hasScssInterpolation(string) || hasPsvInterpolation(string)) {\n    return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasLessInterpolation.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a string has less interpolation\n *\n * @param {string} string\n * @return {boolean} If `true`, a string has less interpolation\n */\nmodule.exports = function (string/*: string*/)/*: boolean*/ {\n  if (/@{.+?}/.test(string)) {\n    return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasPsvInterpolation.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a string has postcss-simple-vars interpolation\n */\nmodule.exports = function (string/*: string*/)/*: boolean*/ {\n  if (/\\$\\(.+?\\)/.test(string)) {\n    return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hasScssInterpolation.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a string has scss interpolation\n */\nmodule.exports = function (string/*: string*/)/*: boolean*/ {\n  if (/#{.+?}/.test(string)) {\n    return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/reference/namedColorData.js":"\"use strict\"\n\nmodule.exports = {\n  \"aliceblue\": {\n    \"hex\": [\n      \"#f0f8ff\", \"#fff0f8ff\",\n    ],\n    \"func\": [\n      \"rgb(240,248,255)\",\n      \"rgba(240,248,255,1)\",\n      \"rgba(240,248,255,100%)\",\n      \"rgb(94%,97%,100%)\",\n      \"rgba(94%,97%,100%,1)\",\n      \"rgba(94%,97%,100%,100%)\",\n      \"hsl(208,100%,97%)\",\n      \"hsla(208,100%,97%,1)\",\n      \"hsla(208,100%,97%,100%)\",\n      \"hwb(208,94%,0%)\",\n      \"hwb(208,94%,0%,1)\",\n      \"hwb(208,94%,0%,100%)\",\n    ],\n  },\n  \"antiquewhite\": {\n    \"hex\": [\n      \"#faebd7\", \"#fffaebd7\",\n    ],\n    \"func\": [\n      \"rgb(250,235,215)\",\n      \"rgba(250,235,215,1)\",\n      \"rgba(250,235,215,100%)\",\n      \"rgb(98%,92%,84%)\",\n      \"rgba(98%,92%,84%,1)\",\n      \"rgba(98%,92%,84%,100%)\",\n      \"hsl(34,78%,91%)\",\n      \"hsla(34,78%,91%,1)\",\n      \"hsla(34,78%,91%,100%)\",\n      \"hwb(34,84%,2%)\",\n      \"hwb(34,84%,2%,1)\",\n      \"hwb(34,84%,2%,100%)\",\n    ],\n  },\n  \"aqua\": {\n    \"hex\": [\n      \"#00ffff\", \"#ff00ffff\", \"#0ff\", \"#f0ff\",\n    ],\n    \"func\": [\n      \"rgb(0,255,255)\",\n      \"rgba(0,255,255,1)\",\n      \"rgba(0,255,255,100%)\",\n      \"rgb(0%,100%,100%)\",\n      \"rgba(0%,100%,100%,1)\",\n      \"rgba(0%,100%,100%,100%)\",\n      \"hsl(180,100%,50%)\",\n      \"hsla(180,100%,50%,1)\",\n      \"hsla(180,100%,50%,100%)\",\n      \"hwb(180,0%,0%)\",\n      \"hwb(180,0%,0%,1)\",\n      \"hwb(180,0%,0%,100%)\",\n    ],\n  },\n  \"aquamarine\": {\n    \"hex\": [\n      \"#7fffd4\", \"#ff7fffd4\",\n    ],\n    \"func\": [\n      \"rgb(127,255,212)\",\n      \"rgba(127,255,212,1)\",\n      \"rgba(127,255,212,100%)\",\n      \"rgb(50%,100%,83%)\",\n      \"rgba(50%,100%,83%,1)\",\n      \"rgba(50%,100%,83%,100%)\",\n      \"hsl(160,100%,75%)\",\n      \"hsla(160,100%,75%,1)\",\n      \"hsla(160,100%,75%,100%)\",\n      \"hwb(160,50%,0%)\",\n      \"hwb(160,50%,0%,1)\",\n      \"hwb(160,50%,0%,100%)\",\n    ],\n  },\n  \"azure\": {\n    \"hex\": [\n      \"#f0ffff\", \"#fff0ffff\",\n    ],\n    \"func\": [\n      \"rgb(240,255,255)\",\n      \"rgba(240,255,255,1)\",\n      \"rgba(240,255,255,100%)\",\n      \"rgb(94%,100%,100%)\",\n      \"rgba(94%,100%,100%,1)\",\n      \"rgba(94%,100%,100%,100%)\",\n      \"hsl(180,100%,97%)\",\n      \"hsla(180,100%,97%,1)\",\n      \"hsla(180,100%,97%,100%)\",\n      \"hwb(180,94%,0%)\",\n      \"hwb(180,94%,0%,1)\",\n      \"hwb(180,94%,0%,100%)\",\n    ],\n  },\n  \"beige\": {\n    \"hex\": [\n      \"#f5f5dc\", \"#fff5f5dc\",\n    ],\n    \"func\": [\n      \"rgb(245,245,220)\",\n      \"rgba(245,245,220,1)\",\n      \"rgba(245,245,220,100%)\",\n      \"rgb(96%,96%,86%)\",\n      \"rgba(96%,96%,86%,1)\",\n      \"rgba(96%,96%,86%,100%)\",\n      \"hsl(60,56%,91%)\",\n      \"hsla(60,56%,91%,1)\",\n      \"hsla(60,56%,91%,100%)\",\n      \"hwb(60,86%,4%)\",\n      \"hwb(60,86%,4%,1)\",\n      \"hwb(60,86%,4%,100%)\",\n    ],\n  },\n  \"bisque\": {\n    \"hex\": [\n      \"#ffe4c4\", \"#ffffe4c4\",\n    ],\n    \"func\": [\n      \"rgb(255,228,196)\",\n      \"rgba(255,228,196,1)\",\n      \"rgba(255,228,196,100%)\",\n      \"rgb(100%,89%,77%)\",\n      \"rgba(100%,89%,77%,1)\",\n      \"rgba(100%,89%,77%,100%)\",\n      \"hsl(33,100%,88%)\",\n      \"hsla(33,100%,88%,1)\",\n      \"hsla(33,100%,88%,100%)\",\n      \"hwb(33,77%,0%)\",\n      \"hwb(33,77%,0%,1)\",\n      \"hwb(33,77%,0%,100%)\",\n    ],\n  },\n  \"black\": {\n    \"hex\": [\n      \"#000000\", \"#ff000000\", \"#000\", \"#f000\",\n    ],\n    \"func\": [\n      \"rgb(0,0,0)\",\n      \"rgba(0,0,0,1)\",\n      \"rgba(0,0,0,100%)\",\n      \"rgb(0%,0%,0%)\",\n      \"rgba(0%,0%,0%,1)\",\n      \"rgba(0%,0%,0%,100%)\",\n      \"hsl(0,0%,0%)\",\n      \"hsla(0,0%,0%,1)\",\n      \"hsla(0,0%,0%,100%)\",\n      \"hwb(0,0%,100%)\",\n      \"hwb(0,0%,100%,1)\",\n      \"hwb(0,0%,100%,100%)\",\n      \"gray(0)\",\n      \"gray(0,1)\",\n      \"gray(0,100%)\",\n      \"gray(0%)\",\n      \"gray(0%,1)\",\n      \"gray(0%,100%)\",\n    ],\n  },\n  \"blanchedalmond\": {\n    \"hex\": [\n      \"#ffebcd\", \"#ffffebcd\",\n    ],\n    \"func\": [\n      \"rgb(255,235,205)\",\n      \"rgba(255,235,205,1)\",\n      \"rgba(255,235,205,100%)\",\n      \"rgb(100%,92%,80%)\",\n      \"rgba(100%,92%,80%,1)\",\n      \"rgba(100%,92%,80%,100%)\",\n      \"hsl(36,100%,90%)\",\n      \"hsla(36,100%,90%,1)\",\n      \"hsla(36,100%,90%,100%)\",\n      \"hwb(36,80%,0%)\",\n      \"hwb(36,80%,0%,1)\",\n      \"hwb(36,80%,0%,100%)\",\n    ],\n  },\n  \"blue\": {\n    \"hex\": [\n      \"#0000ff\", \"#ff0000ff\", \"#00f\", \"#f00f\",\n    ],\n    \"func\": [\n      \"rgb(0,0,255)\",\n      \"rgba(0,0,255,1)\",\n      \"rgba(0,0,255,100%)\",\n      \"rgb(0%,0%,100%)\",\n      \"rgba(0%,0%,100%,1)\",\n      \"rgba(0%,0%,100%,100%)\",\n      \"hsl(240,100%,50%)\",\n      \"hsla(240,100%,50%,1)\",\n      \"hsla(240,100%,50%,100%)\",\n      \"hwb(240,0%,0%)\",\n      \"hwb(240,0%,0%,1)\",\n      \"hwb(240,0%,0%,100%)\",\n    ],\n  },\n  \"blueviolet\": {\n    \"hex\": [\n      \"#8a2be2\", \"#ff8a2be2\",\n    ],\n    \"func\": [\n      \"rgb(138,43,226)\",\n      \"rgba(138,43,226,1)\",\n      \"rgba(138,43,226,100%)\",\n      \"rgb(54%,17%,89%)\",\n      \"rgba(54%,17%,89%,1)\",\n      \"rgba(54%,17%,89%,100%)\",\n      \"hsl(271,76%,53%)\",\n      \"hsla(271,76%,53%,1)\",\n      \"hsla(271,76%,53%,100%)\",\n      \"hwb(271,17%,11%)\",\n      \"hwb(271,17%,11%,1)\",\n      \"hwb(271,17%,11%,100%)\",\n    ],\n  },\n  \"brown\": {\n    \"hex\": [\n      \"#a52a2a\", \"#ffa52a2a\",\n    ],\n    \"func\": [\n      \"rgb(165,42,42)\",\n      \"rgba(165,42,42,1)\",\n      \"rgba(165,42,42,100%)\",\n      \"rgb(65%,16%,16%)\",\n      \"rgba(65%,16%,16%,1)\",\n      \"rgba(65%,16%,16%,100%)\",\n      \"hsl(0,59%,41%)\",\n      \"hsla(0,59%,41%,1)\",\n      \"hsla(0,59%,41%,100%)\",\n      \"hwb(0,16%,35%)\",\n      \"hwb(0,16%,35%,1)\",\n      \"hwb(0,16%,35%,100%)\",\n    ],\n  },\n  \"burlywood\": {\n    \"hex\": [\n      \"#deb887\", \"#ffdeb887\",\n    ],\n    \"func\": [\n      \"rgb(222,184,135)\",\n      \"rgba(222,184,135,1)\",\n      \"rgba(222,184,135,100%)\",\n      \"rgb(87%,72%,53%)\",\n      \"rgba(87%,72%,53%,1)\",\n      \"rgba(87%,72%,53%,100%)\",\n      \"hsl(34,57%,70%)\",\n      \"hsla(34,57%,70%,1)\",\n      \"hsla(34,57%,70%,100%)\",\n      \"hwb(34,53%,13%)\",\n      \"hwb(34,53%,13%,1)\",\n      \"hwb(34,53%,13%,100%)\",\n    ],\n  },\n  \"cadetblue\": {\n    \"hex\": [\n      \"#5f9ea0\", \"#ff5f9ea0\",\n    ],\n    \"func\": [\n      \"rgb(95,158,160)\",\n      \"rgba(95,158,160,1)\",\n      \"rgba(95,158,160,100%)\",\n      \"rgb(37%,62%,63%)\",\n      \"rgba(37%,62%,63%,1)\",\n      \"rgba(37%,62%,63%,100%)\",\n      \"hsl(182,25%,50%)\",\n      \"hsla(182,25%,50%,1)\",\n      \"hsla(182,25%,50%,100%)\",\n      \"hwb(182,37%,37%)\",\n      \"hwb(182,37%,37%,1)\",\n      \"hwb(182,37%,37%,100%)\",\n    ],\n  },\n  \"chartreuse\": {\n    \"hex\": [\n      \"#7fff00\", \"#ff7fff00\",\n    ],\n    \"func\": [\n      \"rgb(127,255,0)\",\n      \"rgba(127,255,0,1)\",\n      \"rgba(127,255,0,100%)\",\n      \"rgb(50%,100%,0%)\",\n      \"rgba(50%,100%,0%,1)\",\n      \"rgba(50%,100%,0%,100%)\",\n      \"hsl(90,100%,50%)\",\n      \"hsla(90,100%,50%,1)\",\n      \"hsla(90,100%,50%,100%)\",\n      \"hwb(90,0%,0%)\",\n      \"hwb(90,0%,0%,1)\",\n      \"hwb(90,0%,0%,100%)\",\n    ],\n  },\n  \"chocolate\": {\n    \"hex\": [\n      \"#d2691e\", \"#ffd2691e\",\n    ],\n    \"func\": [\n      \"rgb(210,105,30)\",\n      \"rgba(210,105,30,1)\",\n      \"rgba(210,105,30,100%)\",\n      \"rgb(82%,41%,12%)\",\n      \"rgba(82%,41%,12%,1)\",\n      \"rgba(82%,41%,12%,100%)\",\n      \"hsl(25,75%,47%)\",\n      \"hsla(25,75%,47%,1)\",\n      \"hsla(25,75%,47%,100%)\",\n      \"hwb(25,12%,18%)\",\n      \"hwb(25,12%,18%,1)\",\n      \"hwb(25,12%,18%,100%)\",\n    ],\n  },\n  \"coral\": {\n    \"hex\": [\n      \"#ff7f50\", \"#ffff7f50\",\n    ],\n    \"func\": [\n      \"rgb(255,127,80)\",\n      \"rgba(255,127,80,1)\",\n      \"rgba(255,127,80,100%)\",\n      \"rgb(100%,50%,31%)\",\n      \"rgba(100%,50%,31%,1)\",\n      \"rgba(100%,50%,31%,100%)\",\n      \"hsl(16,100%,66%)\",\n      \"hsla(16,100%,66%,1)\",\n      \"hsla(16,100%,66%,100%)\",\n      \"hwb(16,31%,0%)\",\n      \"hwb(16,31%,0%,1)\",\n      \"hwb(16,31%,0%,100%)\",\n    ],\n  },\n  \"cornflowerblue\": {\n    \"hex\": [\n      \"#6495ed\", \"#ff6495ed\",\n    ],\n    \"func\": [\n      \"rgb(100,149,237)\",\n      \"rgba(100,149,237,1)\",\n      \"rgba(100,149,237,100%)\",\n      \"rgb(39%,58%,93%)\",\n      \"rgba(39%,58%,93%,1)\",\n      \"rgba(39%,58%,93%,100%)\",\n      \"hsl(219,79%,66%)\",\n      \"hsla(219,79%,66%,1)\",\n      \"hsla(219,79%,66%,100%)\",\n      \"hwb(219,39%,7%)\",\n      \"hwb(219,39%,7%,1)\",\n      \"hwb(219,39%,7%,100%)\",\n    ],\n  },\n  \"cornsilk\": {\n    \"hex\": [\n      \"#fff8dc\", \"#fffff8dc\",\n    ],\n    \"func\": [\n      \"rgb(255,248,220)\",\n      \"rgba(255,248,220,1)\",\n      \"rgba(255,248,220,100%)\",\n      \"rgb(100%,97%,86%)\",\n      \"rgba(100%,97%,86%,1)\",\n      \"rgba(100%,97%,86%,100%)\",\n      \"hsl(48,100%,93%)\",\n      \"hsla(48,100%,93%,1)\",\n      \"hsla(48,100%,93%,100%)\",\n      \"hwb(48,86%,0%)\",\n      \"hwb(48,86%,0%,1)\",\n      \"hwb(48,86%,0%,100%)\",\n    ],\n  },\n  \"crimson\": {\n    \"hex\": [\n      \"#dc143c\", \"#ffdc143c\",\n    ],\n    \"func\": [\n      \"rgb(220,20,60)\",\n      \"rgba(220,20,60,1)\",\n      \"rgba(220,20,60,100%)\",\n      \"rgb(86%,8%,24%)\",\n      \"rgba(86%,8%,24%,1)\",\n      \"rgba(86%,8%,24%,100%)\",\n      \"hsl(348,83%,47%)\",\n      \"hsla(348,83%,47%,1)\",\n      \"hsla(348,83%,47%,100%)\",\n      \"hwb(348,8%,14%)\",\n      \"hwb(348,8%,14%,1)\",\n      \"hwb(348,8%,14%,100%)\",\n    ],\n  },\n  \"cyan\": {\n    \"hex\": [\n      \"#00ffff\", \"#ff00ffff\", \"#0ff\", \"#f0ff\",\n    ],\n    \"func\": [\n      \"rgb(0,255,255)\",\n      \"rgba(0,255,255,1)\",\n      \"rgba(0,255,255,100%)\",\n      \"rgb(0%,100%,100%)\",\n      \"rgba(0%,100%,100%,1)\",\n      \"rgba(0%,100%,100%,100%)\",\n      \"hsl(180,100%,50%)\",\n      \"hsla(180,100%,50%,1)\",\n      \"hsla(180,100%,50%,100%)\",\n      \"hwb(180,0%,0%)\",\n      \"hwb(180,0%,0%,1)\",\n      \"hwb(180,0%,0%,100%)\",\n    ],\n  },\n  \"darkblue\": {\n    \"hex\": [\n      \"#00008b\", \"#ff00008b\",\n    ],\n    \"func\": [\n      \"rgb(0,0,139)\",\n      \"rgba(0,0,139,1)\",\n      \"rgba(0,0,139,100%)\",\n      \"rgb(0%,0%,55%)\",\n      \"rgba(0%,0%,55%,1)\",\n      \"rgba(0%,0%,55%,100%)\",\n      \"hsl(240,100%,27%)\",\n      \"hsla(240,100%,27%,1)\",\n      \"hsla(240,100%,27%,100%)\",\n      \"hwb(240,0%,45%)\",\n      \"hwb(240,0%,45%,1)\",\n      \"hwb(240,0%,45%,100%)\",\n    ],\n  },\n  \"darkcyan\": {\n    \"hex\": [\n      \"#008b8b\", \"#ff008b8b\",\n    ],\n    \"func\": [\n      \"rgb(0,139,139)\",\n      \"rgba(0,139,139,1)\",\n      \"rgba(0,139,139,100%)\",\n      \"rgb(0%,55%,55%)\",\n      \"rgba(0%,55%,55%,1)\",\n      \"rgba(0%,55%,55%,100%)\",\n      \"hsl(180,100%,27%)\",\n      \"hsla(180,100%,27%,1)\",\n      \"hsla(180,100%,27%,100%)\",\n      \"hwb(180,0%,45%)\",\n      \"hwb(180,0%,45%,1)\",\n      \"hwb(180,0%,45%,100%)\",\n    ],\n  },\n  \"darkgoldenrod\": {\n    \"hex\": [\n      \"#b8860b\", \"#ffb8860b\",\n    ],\n    \"func\": [\n      \"rgb(184,134,11)\",\n      \"rgba(184,134,11,1)\",\n      \"rgba(184,134,11,100%)\",\n      \"rgb(72%,53%,4%)\",\n      \"rgba(72%,53%,4%,1)\",\n      \"rgba(72%,53%,4%,100%)\",\n      \"hsl(43,89%,38%)\",\n      \"hsla(43,89%,38%,1)\",\n      \"hsla(43,89%,38%,100%)\",\n      \"hwb(43,4%,28%)\",\n      \"hwb(43,4%,28%,1)\",\n      \"hwb(43,4%,28%,100%)\",\n    ],\n  },\n  \"darkgray\": {\n    \"hex\": [\n      \"#a9a9a9\", \"#ffa9a9a9\",\n    ],\n    \"func\": [\n      \"rgb(169,169,169)\",\n      \"rgba(169,169,169,1)\",\n      \"rgba(169,169,169,100%)\",\n      \"rgb(66%,66%,66%)\",\n      \"rgba(66%,66%,66%,1)\",\n      \"rgba(66%,66%,66%,100%)\",\n      \"hsl(0,0%,66%)\",\n      \"hsla(0,0%,66%,1)\",\n      \"hsla(0,0%,66%,100%)\",\n      \"hwb(0,66%,34%)\",\n      \"hwb(0,66%,34%,1)\",\n      \"hwb(0,66%,34%,100%)\",\n    ],\n  },\n  \"darkgreen\": {\n    \"hex\": [\n      \"#006400\", \"#ff006400\",\n    ],\n    \"func\": [\n      \"rgb(0,100,0)\",\n      \"rgba(0,100,0,1)\",\n      \"rgba(0,100,0,100%)\",\n      \"rgb(0%,39%,0%)\",\n      \"rgba(0%,39%,0%,1)\",\n      \"rgba(0%,39%,0%,100%)\",\n      \"hsl(120,100%,20%)\",\n      \"hsla(120,100%,20%,1)\",\n      \"hsla(120,100%,20%,100%)\",\n      \"hwb(120,0%,61%)\",\n      \"hwb(120,0%,61%,1)\",\n      \"hwb(120,0%,61%,100%)\",\n    ],\n  },\n  \"darkgrey\": {\n    \"hex\": [\n      \"#a9a9a9\", \"#ffa9a9a9\",\n    ],\n    \"func\": [\n      \"rgb(169,169,169)\",\n      \"rgba(169,169,169,1)\",\n      \"rgba(169,169,169,100%)\",\n      \"rgb(66%,66%,66%)\",\n      \"rgba(66%,66%,66%,1)\",\n      \"rgba(66%,66%,66%,100%)\",\n      \"hsl(0,0%,66%)\",\n      \"hsla(0,0%,66%,1)\",\n      \"hsla(0,0%,66%,100%)\",\n      \"hwb(0,66%,34%)\",\n      \"hwb(0,66%,34%,1)\",\n      \"hwb(0,66%,34%,100%)\",\n      \"gray(169)\",\n      \"gray(169,1)\",\n      \"gray(169,100%)\",\n      \"gray(169%)\",\n      \"gray(169%,1)\",\n      \"gray(169%,100%)\",\n    ],\n  },\n  \"darkkhaki\": {\n    \"hex\": [\n      \"#bdb76b\", \"#ffbdb76b\",\n    ],\n    \"func\": [\n      \"rgb(189,183,107)\",\n      \"rgba(189,183,107,1)\",\n      \"rgba(189,183,107,100%)\",\n      \"rgb(74%,72%,42%)\",\n      \"rgba(74%,72%,42%,1)\",\n      \"rgba(74%,72%,42%,100%)\",\n      \"hsl(56,38%,58%)\",\n      \"hsla(56,38%,58%,1)\",\n      \"hsla(56,38%,58%,100%)\",\n      \"hwb(56,42%,26%)\",\n      \"hwb(56,42%,26%,1)\",\n      \"hwb(56,42%,26%,100%)\",\n    ],\n  },\n  \"darkmagenta\": {\n    \"hex\": [\n      \"#8b008b\", \"#ff8b008b\",\n    ],\n    \"func\": [\n      \"rgb(139,0,139)\",\n      \"rgba(139,0,139,1)\",\n      \"rgba(139,0,139,100%)\",\n      \"rgb(55%,0%,55%)\",\n      \"rgba(55%,0%,55%,1)\",\n      \"rgba(55%,0%,55%,100%)\",\n      \"hsl(300,100%,27%)\",\n      \"hsla(300,100%,27%,1)\",\n      \"hsla(300,100%,27%,100%)\",\n      \"hwb(300,0%,45%)\",\n      \"hwb(300,0%,45%,1)\",\n      \"hwb(300,0%,45%,100%)\",\n    ],\n  },\n  \"darkolivegreen\": {\n    \"hex\": [\n      \"#556b2f\", \"#ff556b2f\",\n    ],\n    \"func\": [\n      \"rgb(85,107,47)\",\n      \"rgba(85,107,47,1)\",\n      \"rgba(85,107,47,100%)\",\n      \"rgb(33%,42%,18%)\",\n      \"rgba(33%,42%,18%,1)\",\n      \"rgba(33%,42%,18%,100%)\",\n      \"hsl(82,39%,30%)\",\n      \"hsla(82,39%,30%,1)\",\n      \"hsla(82,39%,30%,100%)\",\n      \"hwb(82,18%,58%)\",\n      \"hwb(82,18%,58%,1)\",\n      \"hwb(82,18%,58%,100%)\",\n    ],\n  },\n  \"darkorange\": {\n    \"hex\": [\n      \"#ff8c00\", \"#ffff8c00\",\n    ],\n    \"func\": [\n      \"rgb(255,140,0)\",\n      \"rgba(255,140,0,1)\",\n      \"rgba(255,140,0,100%)\",\n      \"rgb(100%,55%,0%)\",\n      \"rgba(100%,55%,0%,1)\",\n      \"rgba(100%,55%,0%,100%)\",\n      \"hsl(33,100%,50%)\",\n      \"hsla(33,100%,50%,1)\",\n      \"hsla(33,100%,50%,100%)\",\n      \"hwb(33,0%,0%)\",\n      \"hwb(33,0%,0%,1)\",\n      \"hwb(33,0%,0%,100%)\",\n    ],\n  },\n  \"darkorchid\": {\n    \"hex\": [\n      \"#9932cc\", \"#ff9932cc\",\n    ],\n    \"func\": [\n      \"rgb(153,50,204)\",\n      \"rgba(153,50,204,1)\",\n      \"rgba(153,50,204,100%)\",\n      \"rgb(60%,20%,80%)\",\n      \"rgba(60%,20%,80%,1)\",\n      \"rgba(60%,20%,80%,100%)\",\n      \"hsl(280,61%,50%)\",\n      \"hsla(280,61%,50%,1)\",\n      \"hsla(280,61%,50%,100%)\",\n      \"hwb(280,20%,20%)\",\n      \"hwb(280,20%,20%,1)\",\n      \"hwb(280,20%,20%,100%)\",\n    ],\n  },\n  \"darkred\": {\n    \"hex\": [\n      \"#8b0000\", \"#ff8b0000\",\n    ],\n    \"func\": [\n      \"rgb(139,0,0)\",\n      \"rgba(139,0,0,1)\",\n      \"rgba(139,0,0,100%)\",\n      \"rgb(55%,0%,0%)\",\n      \"rgba(55%,0%,0%,1)\",\n      \"rgba(55%,0%,0%,100%)\",\n      \"hsl(0,100%,27%)\",\n      \"hsla(0,100%,27%,1)\",\n      \"hsla(0,100%,27%,100%)\",\n      \"hwb(0,0%,45%)\",\n      \"hwb(0,0%,45%,1)\",\n      \"hwb(0,0%,45%,100%)\",\n    ],\n  },\n  \"darksalmon\": {\n    \"hex\": [\n      \"#e9967a\", \"#ffe9967a\",\n    ],\n    \"func\": [\n      \"rgb(233,150,122)\",\n      \"rgba(233,150,122,1)\",\n      \"rgba(233,150,122,100%)\",\n      \"rgb(91%,59%,48%)\",\n      \"rgba(91%,59%,48%,1)\",\n      \"rgba(91%,59%,48%,100%)\",\n      \"hsl(15,72%,70%)\",\n      \"hsla(15,72%,70%,1)\",\n      \"hsla(15,72%,70%,100%)\",\n      \"hwb(15,48%,9%)\",\n      \"hwb(15,48%,9%,1)\",\n      \"hwb(15,48%,9%,100%)\",\n    ],\n  },\n  \"darkseagreen\": {\n    \"hex\": [\n      \"#8fbc8f\", \"#ff8fbc8f\",\n    ],\n    \"func\": [\n      \"rgb(143,188,143)\",\n      \"rgba(143,188,143,1)\",\n      \"rgba(143,188,143,100%)\",\n      \"rgb(56%,74%,56%)\",\n      \"rgba(56%,74%,56%,1)\",\n      \"rgba(56%,74%,56%,100%)\",\n      \"hsl(120,25%,65%)\",\n      \"hsla(120,25%,65%,1)\",\n      \"hsla(120,25%,65%,100%)\",\n      \"hwb(120,56%,26%)\",\n      \"hwb(120,56%,26%,1)\",\n      \"hwb(120,56%,26%,100%)\",\n    ],\n  },\n  \"darkslateblue\": {\n    \"hex\": [\n      \"#483d8b\", \"#ff483d8b\",\n    ],\n    \"func\": [\n      \"rgb(72,61,139)\",\n      \"rgba(72,61,139,1)\",\n      \"rgba(72,61,139,100%)\",\n      \"rgb(28%,24%,55%)\",\n      \"rgba(28%,24%,55%,1)\",\n      \"rgba(28%,24%,55%,100%)\",\n      \"hsl(248,39%,39%)\",\n      \"hsla(248,39%,39%,1)\",\n      \"hsla(248,39%,39%,100%)\",\n      \"hwb(248,24%,45%)\",\n      \"hwb(248,24%,45%,1)\",\n      \"hwb(248,24%,45%,100%)\",\n    ],\n  },\n  \"darkslategray\": {\n    \"hex\": [\n      \"#2f4f4f\", \"#ff2f4f4f\",\n    ],\n    \"func\": [\n      \"rgb(47,79,79)\",\n      \"rgba(47,79,79,1)\",\n      \"rgba(47,79,79,100%)\",\n      \"rgb(18%,31%,31%)\",\n      \"rgba(18%,31%,31%,1)\",\n      \"rgba(18%,31%,31%,100%)\",\n      \"hsl(180,25%,25%)\",\n      \"hsla(180,25%,25%,1)\",\n      \"hsla(180,25%,25%,100%)\",\n      \"hwb(180,18%,69%)\",\n      \"hwb(180,18%,69%,1)\",\n      \"hwb(180,18%,69%,100%)\",\n    ],\n  },\n  \"darkslategrey\": {\n    \"hex\": [\n      \"#2f4f4f\", \"#ff2f4f4f\",\n    ],\n    \"func\": [\n      \"rgb(47,79,79)\",\n      \"rgba(47,79,79,1)\",\n      \"rgba(47,79,79,100%)\",\n      \"rgb(18%,31%,31%)\",\n      \"rgba(18%,31%,31%,1)\",\n      \"rgba(18%,31%,31%,100%)\",\n      \"hsl(180,25%,25%)\",\n      \"hsla(180,25%,25%,1)\",\n      \"hsla(180,25%,25%,100%)\",\n      \"hwb(180,18%,69%)\",\n      \"hwb(180,18%,69%,1)\",\n      \"hwb(180,18%,69%,100%)\",\n    ],\n  },\n  \"darkturquoise\": {\n    \"hex\": [\n      \"#00ced1\", \"#ff00ced1\",\n    ],\n    \"func\": [\n      \"rgb(0,206,209)\",\n      \"rgba(0,206,209,1)\",\n      \"rgba(0,206,209,100%)\",\n      \"rgb(0%,81%,82%)\",\n      \"rgba(0%,81%,82%,1)\",\n      \"rgba(0%,81%,82%,100%)\",\n      \"hsl(181,100%,41%)\",\n      \"hsla(181,100%,41%,1)\",\n      \"hsla(181,100%,41%,100%)\",\n      \"hwb(181,0%,18%)\",\n      \"hwb(181,0%,18%,1)\",\n      \"hwb(181,0%,18%,100%)\",\n    ],\n  },\n  \"darkviolet\": {\n    \"hex\": [\n      \"#9400d3\", \"#ff9400d3\",\n    ],\n    \"func\": [\n      \"rgb(148,0,211)\",\n      \"rgba(148,0,211,1)\",\n      \"rgba(148,0,211,100%)\",\n      \"rgb(58%,0%,83%)\",\n      \"rgba(58%,0%,83%,1)\",\n      \"rgba(58%,0%,83%,100%)\",\n      \"hsl(282,100%,41%)\",\n      \"hsla(282,100%,41%,1)\",\n      \"hsla(282,100%,41%,100%)\",\n      \"hwb(282,0%,17%)\",\n      \"hwb(282,0%,17%,1)\",\n      \"hwb(282,0%,17%,100%)\",\n    ],\n  },\n  \"deeppink\": {\n    \"hex\": [\n      \"#ff1493\", \"#ffff1493\",\n    ],\n    \"func\": [\n      \"rgb(255,20,147)\",\n      \"rgba(255,20,147,1)\",\n      \"rgba(255,20,147,100%)\",\n      \"rgb(100%,8%,58%)\",\n      \"rgba(100%,8%,58%,1)\",\n      \"rgba(100%,8%,58%,100%)\",\n      \"hsl(328,100%,54%)\",\n      \"hsla(328,100%,54%,1)\",\n      \"hsla(328,100%,54%,100%)\",\n      \"hwb(328,8%,0%)\",\n      \"hwb(328,8%,0%,1)\",\n      \"hwb(328,8%,0%,100%)\",\n    ],\n  },\n  \"deepskyblue\": {\n    \"hex\": [\n      \"#00bfff\", \"#ff00bfff\",\n    ],\n    \"func\": [\n      \"rgb(0,191,255)\",\n      \"rgba(0,191,255,1)\",\n      \"rgba(0,191,255,100%)\",\n      \"rgb(0%,75%,100%)\",\n      \"rgba(0%,75%,100%,1)\",\n      \"rgba(0%,75%,100%,100%)\",\n      \"hsl(195,100%,50%)\",\n      \"hsla(195,100%,50%,1)\",\n      \"hsla(195,100%,50%,100%)\",\n      \"hwb(195,0%,0%)\",\n      \"hwb(195,0%,0%,1)\",\n      \"hwb(195,0%,0%,100%)\",\n    ],\n  },\n  \"dimgray\": {\n    \"hex\": [\n      \"#696969\", \"#ff696969\",\n    ],\n    \"func\": [\n      \"rgb(105,105,105)\",\n      \"rgba(105,105,105,1)\",\n      \"rgba(105,105,105,100%)\",\n      \"rgb(41%,41%,41%)\",\n      \"rgba(41%,41%,41%,1)\",\n      \"rgba(41%,41%,41%,100%)\",\n      \"hsl(0,0%,41%)\",\n      \"hsla(0,0%,41%,1)\",\n      \"hsla(0,0%,41%,100%)\",\n      \"hwb(0,41%,59%)\",\n      \"hwb(0,41%,59%,1)\",\n      \"hwb(0,41%,59%,100%)\",\n    ],\n  },\n  \"dimgrey\": {\n    \"hex\": [\n      \"#696969\", \"#ff696969\",\n    ],\n    \"func\": [\n      \"rgb(105,105,105)\",\n      \"rgba(105,105,105,1)\",\n      \"rgba(105,105,105,100%)\",\n      \"rgb(41%,41%,41%)\",\n      \"rgba(41%,41%,41%,1)\",\n      \"rgba(41%,41%,41%,100%)\",\n      \"hsl(0,0%,41%)\",\n      \"hsla(0,0%,41%,1)\",\n      \"hsla(0,0%,41%,100%)\",\n      \"hwb(0,41%,59%)\",\n      \"hwb(0,41%,59%,1)\",\n      \"hwb(0,41%,59%,100%)\",\n      \"gray(105)\",\n      \"gray(105,1)\",\n      \"gray(105,100%)\",\n      \"gray(105%)\",\n      \"gray(105%,1)\",\n      \"gray(105%,100%)\",\n    ],\n  },\n  \"dodgerblue\": {\n    \"hex\": [\n      \"#1e90ff\", \"#ff1e90ff\",\n    ],\n    \"func\": [\n      \"rgb(30,144,255)\",\n      \"rgba(30,144,255,1)\",\n      \"rgba(30,144,255,100%)\",\n      \"rgb(12%,56%,100%)\",\n      \"rgba(12%,56%,100%,1)\",\n      \"rgba(12%,56%,100%,100%)\",\n      \"hsl(210,100%,56%)\",\n      \"hsla(210,100%,56%,1)\",\n      \"hsla(210,100%,56%,100%)\",\n      \"hwb(210,12%,0%)\",\n      \"hwb(210,12%,0%,1)\",\n      \"hwb(210,12%,0%,100%)\",\n    ],\n  },\n  \"firebrick\": {\n    \"hex\": [\n      \"#b22222\", \"#ffb22222\",\n    ],\n    \"func\": [\n      \"rgb(178,34,34)\",\n      \"rgba(178,34,34,1)\",\n      \"rgba(178,34,34,100%)\",\n      \"rgb(70%,13%,13%)\",\n      \"rgba(70%,13%,13%,1)\",\n      \"rgba(70%,13%,13%,100%)\",\n      \"hsl(0,68%,42%)\",\n      \"hsla(0,68%,42%,1)\",\n      \"hsla(0,68%,42%,100%)\",\n      \"hwb(0,13%,30%)\",\n      \"hwb(0,13%,30%,1)\",\n      \"hwb(0,13%,30%,100%)\",\n    ],\n  },\n  \"floralwhite\": {\n    \"hex\": [\n      \"#fffaf0\", \"#fffffaf0\",\n    ],\n    \"func\": [\n      \"rgb(255,250,240)\",\n      \"rgba(255,250,240,1)\",\n      \"rgba(255,250,240,100%)\",\n      \"rgb(100%,98%,94%)\",\n      \"rgba(100%,98%,94%,1)\",\n      \"rgba(100%,98%,94%,100%)\",\n      \"hsl(40,100%,97%)\",\n      \"hsla(40,100%,97%,1)\",\n      \"hsla(40,100%,97%,100%)\",\n      \"hwb(40,94%,0%)\",\n      \"hwb(40,94%,0%,1)\",\n      \"hwb(40,94%,0%,100%)\",\n    ],\n  },\n  \"forestgreen\": {\n    \"hex\": [\n      \"#228b22\", \"#ff228b22\",\n    ],\n    \"func\": [\n      \"rgb(34,139,34)\",\n      \"rgba(34,139,34,1)\",\n      \"rgba(34,139,34,100%)\",\n      \"rgb(13%,55%,13%)\",\n      \"rgba(13%,55%,13%,1)\",\n      \"rgba(13%,55%,13%,100%)\",\n      \"hsl(120,61%,34%)\",\n      \"hsla(120,61%,34%,1)\",\n      \"hsla(120,61%,34%,100%)\",\n      \"hwb(120,13%,45%)\",\n      \"hwb(120,13%,45%,1)\",\n      \"hwb(120,13%,45%,100%)\",\n    ],\n  },\n  \"fuchsia\": {\n    \"hex\": [\n      \"#ff00ff\", \"#ffff00ff\", \"#f0f\", \"#ff0f\",\n    ],\n    \"func\": [\n      \"rgb(255,0,255)\",\n      \"rgba(255,0,255,1)\",\n      \"rgba(255,0,255,100%)\",\n      \"rgb(100%,0%,100%)\",\n      \"rgba(100%,0%,100%,1)\",\n      \"rgba(100%,0%,100%,100%)\",\n      \"hsl(300,100%,50%)\",\n      \"hsla(300,100%,50%,1)\",\n      \"hsla(300,100%,50%,100%)\",\n      \"hwb(300,0%,0%)\",\n      \"hwb(300,0%,0%,1)\",\n      \"hwb(300,0%,0%,100%)\",\n    ],\n  },\n  \"gainsboro\": {\n    \"hex\": [\n      \"#dcdcdc\", \"#ffdcdcdc\",\n    ],\n    \"func\": [\n      \"rgb(220,220,220)\",\n      \"rgba(220,220,220,1)\",\n      \"rgba(220,220,220,100%)\",\n      \"rgb(86%,86%,86%)\",\n      \"rgba(86%,86%,86%,1)\",\n      \"rgba(86%,86%,86%,100%)\",\n      \"hsl(0,0%,86%)\",\n      \"hsla(0,0%,86%,1)\",\n      \"hsla(0,0%,86%,100%)\",\n      \"hwb(0,86%,14%)\",\n      \"hwb(0,86%,14%,1)\",\n      \"hwb(0,86%,14%,100%)\",\n    ],\n  },\n  \"ghostwhite\": {\n    \"hex\": [\n      \"#f8f8ff\", \"#fff8f8ff\",\n    ],\n    \"func\": [\n      \"rgb(248,248,255)\",\n      \"rgba(248,248,255,1)\",\n      \"rgba(248,248,255,100%)\",\n      \"rgb(97%,97%,100%)\",\n      \"rgba(97%,97%,100%,1)\",\n      \"rgba(97%,97%,100%,100%)\",\n      \"hsl(240,100%,99%)\",\n      \"hsla(240,100%,99%,1)\",\n      \"hsla(240,100%,99%,100%)\",\n      \"hwb(240,97%,0%)\",\n      \"hwb(240,97%,0%,1)\",\n      \"hwb(240,97%,0%,100%)\",\n    ],\n  },\n  \"gold\": {\n    \"hex\": [\n      \"#ffd700\", \"#ffffd700\",\n    ],\n    \"func\": [\n      \"rgb(255,215,0)\",\n      \"rgba(255,215,0,1)\",\n      \"rgba(255,215,0,100%)\",\n      \"rgb(100%,84%,0%)\",\n      \"rgba(100%,84%,0%,1)\",\n      \"rgba(100%,84%,0%,100%)\",\n      \"hsl(51,100%,50%)\",\n      \"hsla(51,100%,50%,1)\",\n      \"hsla(51,100%,50%,100%)\",\n      \"hwb(51,0%,0%)\",\n      \"hwb(51,0%,0%,1)\",\n      \"hwb(51,0%,0%,100%)\",\n    ],\n  },\n  \"goldenrod\": {\n    \"hex\": [\n      \"#daa520\", \"#ffdaa520\",\n    ],\n    \"func\": [\n      \"rgb(218,165,32)\",\n      \"rgba(218,165,32,1)\",\n      \"rgba(218,165,32,100%)\",\n      \"rgb(85%,65%,13%)\",\n      \"rgba(85%,65%,13%,1)\",\n      \"rgba(85%,65%,13%,100%)\",\n      \"hsl(43,74%,49%)\",\n      \"hsla(43,74%,49%,1)\",\n      \"hsla(43,74%,49%,100%)\",\n      \"hwb(43,13%,15%)\",\n      \"hwb(43,13%,15%,1)\",\n      \"hwb(43,13%,15%,100%)\",\n    ],\n  },\n  \"gray\": {\n    \"hex\": [\n      \"#808080\", \"#ff808080\",\n    ],\n    \"func\": [\n      \"rgb(128,128,128)\",\n      \"rgba(128,128,128,1)\",\n      \"rgba(128,128,128,100%)\",\n      \"rgb(50%,50%,50%)\",\n      \"rgba(50%,50%,50%,1)\",\n      \"rgba(50%,50%,50%,100%)\",\n      \"hsl(0,0%,50%)\",\n      \"hsla(0,0%,50%,1)\",\n      \"hsla(0,0%,50%,100%)\",\n      \"hwb(0,50%,50%)\",\n      \"hwb(0,50%,50%,1)\",\n      \"hwb(0,50%,50%,100%)\",\n    ],\n  },\n  \"green\": {\n    \"hex\": [\n      \"#008000\", \"#ff008000\",\n    ],\n    \"func\": [\n      \"rgb(0,128,0)\",\n      \"rgba(0,128,0,1)\",\n      \"rgba(0,128,0,100%)\",\n      \"rgb(0%,50%,0%)\",\n      \"rgba(0%,50%,0%,1)\",\n      \"rgba(0%,50%,0%,100%)\",\n      \"hsl(120,100%,25%)\",\n      \"hsla(120,100%,25%,1)\",\n      \"hsla(120,100%,25%,100%)\",\n      \"hwb(120,0%,50%)\",\n      \"hwb(120,0%,50%,1)\",\n      \"hwb(120,0%,50%,100%)\",\n    ],\n  },\n  \"greenyellow\": {\n    \"hex\": [\n      \"#adff2f\", \"#ffadff2f\",\n    ],\n    \"func\": [\n      \"rgb(173,255,47)\",\n      \"rgba(173,255,47,1)\",\n      \"rgba(173,255,47,100%)\",\n      \"rgb(68%,100%,18%)\",\n      \"rgba(68%,100%,18%,1)\",\n      \"rgba(68%,100%,18%,100%)\",\n      \"hsl(84,100%,59%)\",\n      \"hsla(84,100%,59%,1)\",\n      \"hsla(84,100%,59%,100%)\",\n      \"hwb(84,18%,0%)\",\n      \"hwb(84,18%,0%,1)\",\n      \"hwb(84,18%,0%,100%)\",\n    ],\n  },\n  \"grey\": {\n    \"hex\": [\n      \"#808080\", \"#ff808080\",\n    ],\n    \"func\": [\n      \"rgb(128,128,128)\",\n      \"rgba(128,128,128,1)\",\n      \"rgba(128,128,128,100%)\",\n      \"rgb(50%,50%,50%)\",\n      \"rgba(50%,50%,50%,1)\",\n      \"rgba(50%,50%,50%,100%)\",\n      \"hsl(0,0%,50%)\",\n      \"hsla(0,0%,50%,1)\",\n      \"hsla(0,0%,50%,100%)\",\n      \"hwb(0,50%,50%)\",\n      \"hwb(0,50%,50%,1)\",\n      \"hwb(0,50%,50%,100%)\",\n      \"gray(128)\",\n      \"gray(128,1)\",\n      \"gray(128,100%)\",\n      \"gray(128%)\",\n      \"gray(128%,1)\",\n      \"gray(128%,100%)\",\n    ],\n  },\n  \"honeydew\": {\n    \"hex\": [\n      \"#f0fff0\", \"#fff0fff0\",\n    ],\n    \"func\": [\n      \"rgb(240,255,240)\",\n      \"rgba(240,255,240,1)\",\n      \"rgba(240,255,240,100%)\",\n      \"rgb(94%,100%,94%)\",\n      \"rgba(94%,100%,94%,1)\",\n      \"rgba(94%,100%,94%,100%)\",\n      \"hsl(120,100%,97%)\",\n      \"hsla(120,100%,97%,1)\",\n      \"hsla(120,100%,97%,100%)\",\n      \"hwb(120,94%,0%)\",\n      \"hwb(120,94%,0%,1)\",\n      \"hwb(120,94%,0%,100%)\",\n    ],\n  },\n  \"hotpink\": {\n    \"hex\": [\n      \"#ff69b4\", \"#ffff69b4\",\n    ],\n    \"func\": [\n      \"rgb(255,105,180)\",\n      \"rgba(255,105,180,1)\",\n      \"rgba(255,105,180,100%)\",\n      \"rgb(100%,41%,71%)\",\n      \"rgba(100%,41%,71%,1)\",\n      \"rgba(100%,41%,71%,100%)\",\n      \"hsl(330,100%,71%)\",\n      \"hsla(330,100%,71%,1)\",\n      \"hsla(330,100%,71%,100%)\",\n      \"hwb(330,41%,0%)\",\n      \"hwb(330,41%,0%,1)\",\n      \"hwb(330,41%,0%,100%)\",\n    ],\n  },\n  \"indianred\": {\n    \"hex\": [\n      \"#cd5c5c\", \"#ffcd5c5c\",\n    ],\n    \"func\": [\n      \"rgb(205,92,92)\",\n      \"rgba(205,92,92,1)\",\n      \"rgba(205,92,92,100%)\",\n      \"rgb(80%,36%,36%)\",\n      \"rgba(80%,36%,36%,1)\",\n      \"rgba(80%,36%,36%,100%)\",\n      \"hsl(0,53%,58%)\",\n      \"hsla(0,53%,58%,1)\",\n      \"hsla(0,53%,58%,100%)\",\n      \"hwb(0,36%,20%)\",\n      \"hwb(0,36%,20%,1)\",\n      \"hwb(0,36%,20%,100%)\",\n    ],\n  },\n  \"indigo\": {\n    \"hex\": [\n      \"#4b0082\", \"#ff4b0082\",\n    ],\n    \"func\": [\n      \"rgb(75,0,130)\",\n      \"rgba(75,0,130,1)\",\n      \"rgba(75,0,130,100%)\",\n      \"rgb(29%,0%,51%)\",\n      \"rgba(29%,0%,51%,1)\",\n      \"rgba(29%,0%,51%,100%)\",\n      \"hsl(275,100%,25%)\",\n      \"hsla(275,100%,25%,1)\",\n      \"hsla(275,100%,25%,100%)\",\n      \"hwb(275,0%,49%)\",\n      \"hwb(275,0%,49%,1)\",\n      \"hwb(275,0%,49%,100%)\",\n    ],\n  },\n  \"ivory\": {\n    \"hex\": [\n      \"#fffff0\", \"#fffffff0\",\n    ],\n    \"func\": [\n      \"rgb(255,255,240)\",\n      \"rgba(255,255,240,1)\",\n      \"rgba(255,255,240,100%)\",\n      \"rgb(100%,100%,94%)\",\n      \"rgba(100%,100%,94%,1)\",\n      \"rgba(100%,100%,94%,100%)\",\n      \"hsl(60,100%,97%)\",\n      \"hsla(60,100%,97%,1)\",\n      \"hsla(60,100%,97%,100%)\",\n      \"hwb(60,94%,0%)\",\n      \"hwb(60,94%,0%,1)\",\n      \"hwb(60,94%,0%,100%)\",\n    ],\n  },\n  \"khaki\": {\n    \"hex\": [\n      \"#f0e68c\", \"#fff0e68c\",\n    ],\n    \"func\": [\n      \"rgb(240,230,140)\",\n      \"rgba(240,230,140,1)\",\n      \"rgba(240,230,140,100%)\",\n      \"rgb(94%,90%,55%)\",\n      \"rgba(94%,90%,55%,1)\",\n      \"rgba(94%,90%,55%,100%)\",\n      \"hsl(54,77%,75%)\",\n      \"hsla(54,77%,75%,1)\",\n      \"hsla(54,77%,75%,100%)\",\n      \"hwb(54,55%,6%)\",\n      \"hwb(54,55%,6%,1)\",\n      \"hwb(54,55%,6%,100%)\",\n    ],\n  },\n  \"lavender\": {\n    \"hex\": [\n      \"#e6e6fa\", \"#ffe6e6fa\",\n    ],\n    \"func\": [\n      \"rgb(230,230,250)\",\n      \"rgba(230,230,250,1)\",\n      \"rgba(230,230,250,100%)\",\n      \"rgb(90%,90%,98%)\",\n      \"rgba(90%,90%,98%,1)\",\n      \"rgba(90%,90%,98%,100%)\",\n      \"hsl(240,67%,94%)\",\n      \"hsla(240,67%,94%,1)\",\n      \"hsla(240,67%,94%,100%)\",\n      \"hwb(240,90%,2%)\",\n      \"hwb(240,90%,2%,1)\",\n      \"hwb(240,90%,2%,100%)\",\n    ],\n  },\n  \"lavenderblush\": {\n    \"hex\": [\n      \"#fff0f5\", \"#fffff0f5\",\n    ],\n    \"func\": [\n      \"rgb(255,240,245)\",\n      \"rgba(255,240,245,1)\",\n      \"rgba(255,240,245,100%)\",\n      \"rgb(100%,94%,96%)\",\n      \"rgba(100%,94%,96%,1)\",\n      \"rgba(100%,94%,96%,100%)\",\n      \"hsl(340,100%,97%)\",\n      \"hsla(340,100%,97%,1)\",\n      \"hsla(340,100%,97%,100%)\",\n      \"hwb(340,94%,0%)\",\n      \"hwb(340,94%,0%,1)\",\n      \"hwb(340,94%,0%,100%)\",\n    ],\n  },\n  \"lawngreen\": {\n    \"hex\": [\n      \"#7cfc00\", \"#ff7cfc00\",\n    ],\n    \"func\": [\n      \"rgb(124,252,0)\",\n      \"rgba(124,252,0,1)\",\n      \"rgba(124,252,0,100%)\",\n      \"rgb(49%,99%,0%)\",\n      \"rgba(49%,99%,0%,1)\",\n      \"rgba(49%,99%,0%,100%)\",\n      \"hsl(90,100%,49%)\",\n      \"hsla(90,100%,49%,1)\",\n      \"hsla(90,100%,49%,100%)\",\n      \"hwb(90,0%,1%)\",\n      \"hwb(90,0%,1%,1)\",\n      \"hwb(90,0%,1%,100%)\",\n    ],\n  },\n  \"lemonchiffon\": {\n    \"hex\": [\n      \"#fffacd\", \"#fffffacd\",\n    ],\n    \"func\": [\n      \"rgb(255,250,205)\",\n      \"rgba(255,250,205,1)\",\n      \"rgba(255,250,205,100%)\",\n      \"rgb(100%,98%,80%)\",\n      \"rgba(100%,98%,80%,1)\",\n      \"rgba(100%,98%,80%,100%)\",\n      \"hsl(54,100%,90%)\",\n      \"hsla(54,100%,90%,1)\",\n      \"hsla(54,100%,90%,100%)\",\n      \"hwb(54,80%,0%)\",\n      \"hwb(54,80%,0%,1)\",\n      \"hwb(54,80%,0%,100%)\",\n    ],\n  },\n  \"lightblue\": {\n    \"hex\": [\n      \"#add8e6\", \"#ffadd8e6\",\n    ],\n    \"func\": [\n      \"rgb(173,216,230)\",\n      \"rgba(173,216,230,1)\",\n      \"rgba(173,216,230,100%)\",\n      \"rgb(68%,85%,90%)\",\n      \"rgba(68%,85%,90%,1)\",\n      \"rgba(68%,85%,90%,100%)\",\n      \"hsl(195,53%,79%)\",\n      \"hsla(195,53%,79%,1)\",\n      \"hsla(195,53%,79%,100%)\",\n      \"hwb(195,68%,10%)\",\n      \"hwb(195,68%,10%,1)\",\n      \"hwb(195,68%,10%,100%)\",\n    ],\n  },\n  \"lightcoral\": {\n    \"hex\": [\n      \"#f08080\", \"#fff08080\",\n    ],\n    \"func\": [\n      \"rgb(240,128,128)\",\n      \"rgba(240,128,128,1)\",\n      \"rgba(240,128,128,100%)\",\n      \"rgb(94%,50%,50%)\",\n      \"rgba(94%,50%,50%,1)\",\n      \"rgba(94%,50%,50%,100%)\",\n      \"hsl(0,79%,72%)\",\n      \"hsla(0,79%,72%,1)\",\n      \"hsla(0,79%,72%,100%)\",\n      \"hwb(0,50%,6%)\",\n      \"hwb(0,50%,6%,1)\",\n      \"hwb(0,50%,6%,100%)\",\n    ],\n  },\n  \"lightcyan\": {\n    \"hex\": [\n      \"#e0ffff\", \"#ffe0ffff\",\n    ],\n    \"func\": [\n      \"rgb(224,255,255)\",\n      \"rgba(224,255,255,1)\",\n      \"rgba(224,255,255,100%)\",\n      \"rgb(88%,100%,100%)\",\n      \"rgba(88%,100%,100%,1)\",\n      \"rgba(88%,100%,100%,100%)\",\n      \"hsl(180,100%,94%)\",\n      \"hsla(180,100%,94%,1)\",\n      \"hsla(180,100%,94%,100%)\",\n      \"hwb(180,88%,0%)\",\n      \"hwb(180,88%,0%,1)\",\n      \"hwb(180,88%,0%,100%)\",\n    ],\n  },\n  \"lightgoldenrodyellow\": {\n    \"hex\": [\n      \"#fafad2\", \"#fffafad2\",\n    ],\n    \"func\": [\n      \"rgb(250,250,210)\",\n      \"rgba(250,250,210,1)\",\n      \"rgba(250,250,210,100%)\",\n      \"rgb(98%,98%,82%)\",\n      \"rgba(98%,98%,82%,1)\",\n      \"rgba(98%,98%,82%,100%)\",\n      \"hsl(60,80%,90%)\",\n      \"hsla(60,80%,90%,1)\",\n      \"hsla(60,80%,90%,100%)\",\n      \"hwb(60,82%,2%)\",\n      \"hwb(60,82%,2%,1)\",\n      \"hwb(60,82%,2%,100%)\",\n    ],\n  },\n  \"lightgray\": {\n    \"hex\": [\n      \"#d3d3d3\", \"#ffd3d3d3\",\n    ],\n    \"func\": [\n      \"rgb(211,211,211)\",\n      \"rgba(211,211,211,1)\",\n      \"rgba(211,211,211,100%)\",\n      \"rgb(83%,83%,83%)\",\n      \"rgba(83%,83%,83%,1)\",\n      \"rgba(83%,83%,83%,100%)\",\n      \"hsl(0,0%,83%)\",\n      \"hsla(0,0%,83%,1)\",\n      \"hsla(0,0%,83%,100%)\",\n      \"hwb(0,83%,17%)\",\n      \"hwb(0,83%,17%,1)\",\n      \"hwb(0,83%,17%,100%)\",\n    ],\n  },\n  \"lightgreen\": {\n    \"hex\": [\n      \"#90ee90\", \"#ff90ee90\",\n    ],\n    \"func\": [\n      \"rgb(144,238,144)\",\n      \"rgba(144,238,144,1)\",\n      \"rgba(144,238,144,100%)\",\n      \"rgb(56%,93%,56%)\",\n      \"rgba(56%,93%,56%,1)\",\n      \"rgba(56%,93%,56%,100%)\",\n      \"hsl(120,73%,75%)\",\n      \"hsla(120,73%,75%,1)\",\n      \"hsla(120,73%,75%,100%)\",\n      \"hwb(120,56%,7%)\",\n      \"hwb(120,56%,7%,1)\",\n      \"hwb(120,56%,7%,100%)\",\n    ],\n  },\n  \"lightgrey\": {\n    \"hex\": [\n      \"#d3d3d3\", \"#ffd3d3d3\",\n    ],\n    \"func\": [\n      \"rgb(211,211,211)\",\n      \"rgba(211,211,211,1)\",\n      \"rgba(211,211,211,100%)\",\n      \"rgb(83%,83%,83%)\",\n      \"rgba(83%,83%,83%,1)\",\n      \"rgba(83%,83%,83%,100%)\",\n      \"hsl(0,0%,83%)\",\n      \"hsla(0,0%,83%,1)\",\n      \"hsla(0,0%,83%,100%)\",\n      \"hwb(0,83%,17%)\",\n      \"hwb(0,83%,17%,1)\",\n      \"hwb(0,83%,17%,100%)\",\n      \"gray(211)\",\n      \"gray(211,1)\",\n      \"gray(211,100%)\",\n      \"gray(211%)\",\n      \"gray(211%,1)\",\n      \"gray(211%,100%)\",\n    ],\n  },\n  \"lightpink\": {\n    \"hex\": [\n      \"#ffb6c1\", \"#ffffb6c1\",\n    ],\n    \"func\": [\n      \"rgb(255,182,193)\",\n      \"rgba(255,182,193,1)\",\n      \"rgba(255,182,193,100%)\",\n      \"rgb(100%,71%,76%)\",\n      \"rgba(100%,71%,76%,1)\",\n      \"rgba(100%,71%,76%,100%)\",\n      \"hsl(351,100%,86%)\",\n      \"hsla(351,100%,86%,1)\",\n      \"hsla(351,100%,86%,100%)\",\n      \"hwb(351,71%,0%)\",\n      \"hwb(351,71%,0%,1)\",\n      \"hwb(351,71%,0%,100%)\",\n    ],\n  },\n  \"lightsalmon\": {\n    \"hex\": [\n      \"#ffa07a\", \"#ffffa07a\",\n    ],\n    \"func\": [\n      \"rgb(255,160,122)\",\n      \"rgba(255,160,122,1)\",\n      \"rgba(255,160,122,100%)\",\n      \"rgb(100%,63%,48%)\",\n      \"rgba(100%,63%,48%,1)\",\n      \"rgba(100%,63%,48%,100%)\",\n      \"hsl(17,100%,74%)\",\n      \"hsla(17,100%,74%,1)\",\n      \"hsla(17,100%,74%,100%)\",\n      \"hwb(17,48%,0%)\",\n      \"hwb(17,48%,0%,1)\",\n      \"hwb(17,48%,0%,100%)\",\n    ],\n  },\n  \"lightseagreen\": {\n    \"hex\": [\n      \"#20b2aa\", \"#ff20b2aa\",\n    ],\n    \"func\": [\n      \"rgb(32,178,170)\",\n      \"rgba(32,178,170,1)\",\n      \"rgba(32,178,170,100%)\",\n      \"rgb(13%,70%,67%)\",\n      \"rgba(13%,70%,67%,1)\",\n      \"rgba(13%,70%,67%,100%)\",\n      \"hsl(177,70%,41%)\",\n      \"hsla(177,70%,41%,1)\",\n      \"hsla(177,70%,41%,100%)\",\n      \"hwb(177,13%,30%)\",\n      \"hwb(177,13%,30%,1)\",\n      \"hwb(177,13%,30%,100%)\",\n    ],\n  },\n  \"lightskyblue\": {\n    \"hex\": [\n      \"#87cefa\", \"#ff87cefa\",\n    ],\n    \"func\": [\n      \"rgb(135,206,250)\",\n      \"rgba(135,206,250,1)\",\n      \"rgba(135,206,250,100%)\",\n      \"rgb(53%,81%,98%)\",\n      \"rgba(53%,81%,98%,1)\",\n      \"rgba(53%,81%,98%,100%)\",\n      \"hsl(203,92%,75%)\",\n      \"hsla(203,92%,75%,1)\",\n      \"hsla(203,92%,75%,100%)\",\n      \"hwb(203,53%,2%)\",\n      \"hwb(203,53%,2%,1)\",\n      \"hwb(203,53%,2%,100%)\",\n    ],\n  },\n  \"lightslategray\": {\n    \"hex\": [\n      \"#778899\", \"#ff778899\", \"#789\", \"#f789\",\n    ],\n    \"func\": [\n      \"rgb(119,136,153)\",\n      \"rgba(119,136,153,1)\",\n      \"rgba(119,136,153,100%)\",\n      \"rgb(47%,53%,60%)\",\n      \"rgba(47%,53%,60%,1)\",\n      \"rgba(47%,53%,60%,100%)\",\n      \"hsl(210,14%,53%)\",\n      \"hsla(210,14%,53%,1)\",\n      \"hsla(210,14%,53%,100%)\",\n      \"hwb(210,47%,40%)\",\n      \"hwb(210,47%,40%,1)\",\n      \"hwb(210,47%,40%,100%)\",\n    ],\n  },\n  \"lightslategrey\": {\n    \"hex\": [\n      \"#778899\", \"#ff778899\", \"#789\", \"#f789\",\n    ],\n    \"func\": [\n      \"rgb(119,136,153)\",\n      \"rgba(119,136,153,1)\",\n      \"rgba(119,136,153,100%)\",\n      \"rgb(47%,53%,60%)\",\n      \"rgba(47%,53%,60%,1)\",\n      \"rgba(47%,53%,60%,100%)\",\n      \"hsl(210,14%,53%)\",\n      \"hsla(210,14%,53%,1)\",\n      \"hsla(210,14%,53%,100%)\",\n      \"hwb(210,47%,40%)\",\n      \"hwb(210,47%,40%,1)\",\n      \"hwb(210,47%,40%,100%)\",\n    ],\n  },\n  \"lightsteelblue\": {\n    \"hex\": [\n      \"#b0c4de\", \"#ffb0c4de\",\n    ],\n    \"func\": [\n      \"rgb(176,196,222)\",\n      \"rgba(176,196,222,1)\",\n      \"rgba(176,196,222,100%)\",\n      \"rgb(69%,77%,87%)\",\n      \"rgba(69%,77%,87%,1)\",\n      \"rgba(69%,77%,87%,100%)\",\n      \"hsl(214,41%,78%)\",\n      \"hsla(214,41%,78%,1)\",\n      \"hsla(214,41%,78%,100%)\",\n      \"hwb(214,69%,13%)\",\n      \"hwb(214,69%,13%,1)\",\n      \"hwb(214,69%,13%,100%)\",\n    ],\n  },\n  \"lightyellow\": {\n    \"hex\": [\n      \"#ffffe0\", \"#ffffffe0\",\n    ],\n    \"func\": [\n      \"rgb(255,255,224)\",\n      \"rgba(255,255,224,1)\",\n      \"rgba(255,255,224,100%)\",\n      \"rgb(100%,100%,88%)\",\n      \"rgba(100%,100%,88%,1)\",\n      \"rgba(100%,100%,88%,100%)\",\n      \"hsl(60,100%,94%)\",\n      \"hsla(60,100%,94%,1)\",\n      \"hsla(60,100%,94%,100%)\",\n      \"hwb(60,88%,0%)\",\n      \"hwb(60,88%,0%,1)\",\n      \"hwb(60,88%,0%,100%)\",\n    ],\n  },\n  \"lime\": {\n    \"hex\": [\n      \"#00ff00\", \"#ff00ff00\", \"#0f0\", \"#f0f0\",\n    ],\n    \"func\": [\n      \"rgb(0,255,0)\",\n      \"rgba(0,255,0,1)\",\n      \"rgba(0,255,0,100%)\",\n      \"rgb(0%,100%,0%)\",\n      \"rgba(0%,100%,0%,1)\",\n      \"rgba(0%,100%,0%,100%)\",\n      \"hsl(120,100%,50%)\",\n      \"hsla(120,100%,50%,1)\",\n      \"hsla(120,100%,50%,100%)\",\n      \"hwb(120,0%,0%)\",\n      \"hwb(120,0%,0%,1)\",\n      \"hwb(120,0%,0%,100%)\",\n    ],\n  },\n  \"limegreen\": {\n    \"hex\": [\n      \"#32cd32\", \"#ff32cd32\",\n    ],\n    \"func\": [\n      \"rgb(50,205,50)\",\n      \"rgba(50,205,50,1)\",\n      \"rgba(50,205,50,100%)\",\n      \"rgb(20%,80%,20%)\",\n      \"rgba(20%,80%,20%,1)\",\n      \"rgba(20%,80%,20%,100%)\",\n      \"hsl(120,61%,50%)\",\n      \"hsla(120,61%,50%,1)\",\n      \"hsla(120,61%,50%,100%)\",\n      \"hwb(120,20%,20%)\",\n      \"hwb(120,20%,20%,1)\",\n      \"hwb(120,20%,20%,100%)\",\n    ],\n  },\n  \"linen\": {\n    \"hex\": [\n      \"#faf0e6\", \"#fffaf0e6\",\n    ],\n    \"func\": [\n      \"rgb(250,240,230)\",\n      \"rgba(250,240,230,1)\",\n      \"rgba(250,240,230,100%)\",\n      \"rgb(98%,94%,90%)\",\n      \"rgba(98%,94%,90%,1)\",\n      \"rgba(98%,94%,90%,100%)\",\n      \"hsl(30,67%,94%)\",\n      \"hsla(30,67%,94%,1)\",\n      \"hsla(30,67%,94%,100%)\",\n      \"hwb(30,90%,2%)\",\n      \"hwb(30,90%,2%,1)\",\n      \"hwb(30,90%,2%,100%)\",\n    ],\n  },\n  \"magenta\": {\n    \"hex\": [\n      \"#ff00ff\", \"#ffff00ff\", \"#f0f\", \"#ff0f\",\n    ],\n    \"func\": [\n      \"rgb(255,0,255)\",\n      \"rgba(255,0,255,1)\",\n      \"rgba(255,0,255,100%)\",\n      \"rgb(100%,0%,100%)\",\n      \"rgba(100%,0%,100%,1)\",\n      \"rgba(100%,0%,100%,100%)\",\n      \"hsl(300,100%,50%)\",\n      \"hsla(300,100%,50%,1)\",\n      \"hsla(300,100%,50%,100%)\",\n      \"hwb(300,0%,0%)\",\n      \"hwb(300,0%,0%,1)\",\n      \"hwb(300,0%,0%,100%)\",\n    ],\n  },\n  \"maroon\": {\n    \"hex\": [\n      \"#800000\", \"#ff800000\",\n    ],\n    \"func\": [\n      \"rgb(128,0,0)\",\n      \"rgba(128,0,0,1)\",\n      \"rgba(128,0,0,100%)\",\n      \"rgb(50%,0%,0%)\",\n      \"rgba(50%,0%,0%,1)\",\n      \"rgba(50%,0%,0%,100%)\",\n      \"hsl(0,100%,25%)\",\n      \"hsla(0,100%,25%,1)\",\n      \"hsla(0,100%,25%,100%)\",\n      \"hwb(0,0%,50%)\",\n      \"hwb(0,0%,50%,1)\",\n      \"hwb(0,0%,50%,100%)\",\n    ],\n  },\n  \"mediumaquamarine\": {\n    \"hex\": [\n      \"#66cdaa\", \"#ff66cdaa\",\n    ],\n    \"func\": [\n      \"rgb(102,205,170)\",\n      \"rgba(102,205,170,1)\",\n      \"rgba(102,205,170,100%)\",\n      \"rgb(40%,80%,67%)\",\n      \"rgba(40%,80%,67%,1)\",\n      \"rgba(40%,80%,67%,100%)\",\n      \"hsl(160,51%,60%)\",\n      \"hsla(160,51%,60%,1)\",\n      \"hsla(160,51%,60%,100%)\",\n      \"hwb(160,40%,20%)\",\n      \"hwb(160,40%,20%,1)\",\n      \"hwb(160,40%,20%,100%)\",\n    ],\n  },\n  \"mediumblue\": {\n    \"hex\": [\n      \"#0000cd\", \"#ff0000cd\",\n    ],\n    \"func\": [\n      \"rgb(0,0,205)\",\n      \"rgba(0,0,205,1)\",\n      \"rgba(0,0,205,100%)\",\n      \"rgb(0%,0%,80%)\",\n      \"rgba(0%,0%,80%,1)\",\n      \"rgba(0%,0%,80%,100%)\",\n      \"hsl(240,100%,40%)\",\n      \"hsla(240,100%,40%,1)\",\n      \"hsla(240,100%,40%,100%)\",\n      \"hwb(240,0%,20%)\",\n      \"hwb(240,0%,20%,1)\",\n      \"hwb(240,0%,20%,100%)\",\n    ],\n  },\n  \"mediumorchid\": {\n    \"hex\": [\n      \"#ba55d3\", \"#ffba55d3\",\n    ],\n    \"func\": [\n      \"rgb(186,85,211)\",\n      \"rgba(186,85,211,1)\",\n      \"rgba(186,85,211,100%)\",\n      \"rgb(73%,33%,83%)\",\n      \"rgba(73%,33%,83%,1)\",\n      \"rgba(73%,33%,83%,100%)\",\n      \"hsl(288,59%,58%)\",\n      \"hsla(288,59%,58%,1)\",\n      \"hsla(288,59%,58%,100%)\",\n      \"hwb(288,33%,17%)\",\n      \"hwb(288,33%,17%,1)\",\n      \"hwb(288,33%,17%,100%)\",\n    ],\n  },\n  \"mediumpurple\": {\n    \"hex\": [\n      \"#9370db\", \"#ff9370db\",\n    ],\n    \"func\": [\n      \"rgb(147,112,219)\",\n      \"rgba(147,112,219,1)\",\n      \"rgba(147,112,219,100%)\",\n      \"rgb(58%,44%,86%)\",\n      \"rgba(58%,44%,86%,1)\",\n      \"rgba(58%,44%,86%,100%)\",\n      \"hsl(260,60%,65%)\",\n      \"hsla(260,60%,65%,1)\",\n      \"hsla(260,60%,65%,100%)\",\n      \"hwb(260,44%,14%)\",\n      \"hwb(260,44%,14%,1)\",\n      \"hwb(260,44%,14%,100%)\",\n    ],\n  },\n  \"mediumseagreen\": {\n    \"hex\": [\n      \"#3cb371\", \"#ff3cb371\",\n    ],\n    \"func\": [\n      \"rgb(60,179,113)\",\n      \"rgba(60,179,113,1)\",\n      \"rgba(60,179,113,100%)\",\n      \"rgb(24%,70%,44%)\",\n      \"rgba(24%,70%,44%,1)\",\n      \"rgba(24%,70%,44%,100%)\",\n      \"hsl(147,50%,47%)\",\n      \"hsla(147,50%,47%,1)\",\n      \"hsla(147,50%,47%,100%)\",\n      \"hwb(147,24%,30%)\",\n      \"hwb(147,24%,30%,1)\",\n      \"hwb(147,24%,30%,100%)\",\n    ],\n  },\n  \"mediumslateblue\": {\n    \"hex\": [\n      \"#7b68ee\", \"#ff7b68ee\",\n    ],\n    \"func\": [\n      \"rgb(123,104,238)\",\n      \"rgba(123,104,238,1)\",\n      \"rgba(123,104,238,100%)\",\n      \"rgb(48%,41%,93%)\",\n      \"rgba(48%,41%,93%,1)\",\n      \"rgba(48%,41%,93%,100%)\",\n      \"hsl(249,80%,67%)\",\n      \"hsla(249,80%,67%,1)\",\n      \"hsla(249,80%,67%,100%)\",\n      \"hwb(249,41%,7%)\",\n      \"hwb(249,41%,7%,1)\",\n      \"hwb(249,41%,7%,100%)\",\n    ],\n  },\n  \"mediumspringgreen\": {\n    \"hex\": [\n      \"#00fa9a\", \"#ff00fa9a\",\n    ],\n    \"func\": [\n      \"rgb(0,250,154)\",\n      \"rgba(0,250,154,1)\",\n      \"rgba(0,250,154,100%)\",\n      \"rgb(0%,98%,60%)\",\n      \"rgba(0%,98%,60%,1)\",\n      \"rgba(0%,98%,60%,100%)\",\n      \"hsl(157,100%,49%)\",\n      \"hsla(157,100%,49%,1)\",\n      \"hsla(157,100%,49%,100%)\",\n      \"hwb(157,0%,2%)\",\n      \"hwb(157,0%,2%,1)\",\n      \"hwb(157,0%,2%,100%)\",\n    ],\n  },\n  \"mediumturquoise\": {\n    \"hex\": [\n      \"#48d1cc\", \"#ff48d1cc\",\n    ],\n    \"func\": [\n      \"rgb(72,209,204)\",\n      \"rgba(72,209,204,1)\",\n      \"rgba(72,209,204,100%)\",\n      \"rgb(28%,82%,80%)\",\n      \"rgba(28%,82%,80%,1)\",\n      \"rgba(28%,82%,80%,100%)\",\n      \"hsl(178,60%,55%)\",\n      \"hsla(178,60%,55%,1)\",\n      \"hsla(178,60%,55%,100%)\",\n      \"hwb(178,28%,18%)\",\n      \"hwb(178,28%,18%,1)\",\n      \"hwb(178,28%,18%,100%)\",\n    ],\n  },\n  \"mediumvioletred\": {\n    \"hex\": [\n      \"#c71585\", \"#ffc71585\",\n    ],\n    \"func\": [\n      \"rgb(199,21,133)\",\n      \"rgba(199,21,133,1)\",\n      \"rgba(199,21,133,100%)\",\n      \"rgb(78%,8%,52%)\",\n      \"rgba(78%,8%,52%,1)\",\n      \"rgba(78%,8%,52%,100%)\",\n      \"hsl(322,81%,43%)\",\n      \"hsla(322,81%,43%,1)\",\n      \"hsla(322,81%,43%,100%)\",\n      \"hwb(322,8%,22%)\",\n      \"hwb(322,8%,22%,1)\",\n      \"hwb(322,8%,22%,100%)\",\n    ],\n  },\n  \"midnightblue\": {\n    \"hex\": [\n      \"#191970\", \"#ff191970\",\n    ],\n    \"func\": [\n      \"rgb(25,25,112)\",\n      \"rgba(25,25,112,1)\",\n      \"rgba(25,25,112,100%)\",\n      \"rgb(10%,10%,44%)\",\n      \"rgba(10%,10%,44%,1)\",\n      \"rgba(10%,10%,44%,100%)\",\n      \"hsl(240,64%,27%)\",\n      \"hsla(240,64%,27%,1)\",\n      \"hsla(240,64%,27%,100%)\",\n      \"hwb(240,10%,56%)\",\n      \"hwb(240,10%,56%,1)\",\n      \"hwb(240,10%,56%,100%)\",\n    ],\n  },\n  \"mintcream\": {\n    \"hex\": [\n      \"#f5fffa\", \"#fff5fffa\",\n    ],\n    \"func\": [\n      \"rgb(245,255,250)\",\n      \"rgba(245,255,250,1)\",\n      \"rgba(245,255,250,100%)\",\n      \"rgb(96%,100%,98%)\",\n      \"rgba(96%,100%,98%,1)\",\n      \"rgba(96%,100%,98%,100%)\",\n      \"hsl(150,100%,98%)\",\n      \"hsla(150,100%,98%,1)\",\n      \"hsla(150,100%,98%,100%)\",\n      \"hwb(150,96%,0%)\",\n      \"hwb(150,96%,0%,1)\",\n      \"hwb(150,96%,0%,100%)\",\n    ],\n  },\n  \"mistyrose\": {\n    \"hex\": [\n      \"#ffe4e1\", \"#ffffe4e1\",\n    ],\n    \"func\": [\n      \"rgb(255,228,225)\",\n      \"rgba(255,228,225,1)\",\n      \"rgba(255,228,225,100%)\",\n      \"rgb(100%,89%,88%)\",\n      \"rgba(100%,89%,88%,1)\",\n      \"rgba(100%,89%,88%,100%)\",\n      \"hsl(6,100%,94%)\",\n      \"hsla(6,100%,94%,1)\",\n      \"hsla(6,100%,94%,100%)\",\n      \"hwb(6,88%,0%)\",\n      \"hwb(6,88%,0%,1)\",\n      \"hwb(6,88%,0%,100%)\",\n    ],\n  },\n  \"moccasin\": {\n    \"hex\": [\n      \"#ffe4b5\", \"#ffffe4b5\",\n    ],\n    \"func\": [\n      \"rgb(255,228,181)\",\n      \"rgba(255,228,181,1)\",\n      \"rgba(255,228,181,100%)\",\n      \"rgb(100%,89%,71%)\",\n      \"rgba(100%,89%,71%,1)\",\n      \"rgba(100%,89%,71%,100%)\",\n      \"hsl(38,100%,85%)\",\n      \"hsla(38,100%,85%,1)\",\n      \"hsla(38,100%,85%,100%)\",\n      \"hwb(38,71%,0%)\",\n      \"hwb(38,71%,0%,1)\",\n      \"hwb(38,71%,0%,100%)\",\n    ],\n  },\n  \"navajowhite\": {\n    \"hex\": [\n      \"#ffdead\", \"#ffffdead\",\n    ],\n    \"func\": [\n      \"rgb(255,222,173)\",\n      \"rgba(255,222,173,1)\",\n      \"rgba(255,222,173,100%)\",\n      \"rgb(100%,87%,68%)\",\n      \"rgba(100%,87%,68%,1)\",\n      \"rgba(100%,87%,68%,100%)\",\n      \"hsl(36,100%,84%)\",\n      \"hsla(36,100%,84%,1)\",\n      \"hsla(36,100%,84%,100%)\",\n      \"hwb(36,68%,0%)\",\n      \"hwb(36,68%,0%,1)\",\n      \"hwb(36,68%,0%,100%)\",\n    ],\n  },\n  \"navy\": {\n    \"hex\": [\n      \"#000080\", \"#ff000080\",\n    ],\n    \"func\": [\n      \"rgb(0,0,128)\",\n      \"rgba(0,0,128,1)\",\n      \"rgba(0,0,128,100%)\",\n      \"rgb(0%,0%,50%)\",\n      \"rgba(0%,0%,50%,1)\",\n      \"rgba(0%,0%,50%,100%)\",\n      \"hsl(240,100%,25%)\",\n      \"hsla(240,100%,25%,1)\",\n      \"hsla(240,100%,25%,100%)\",\n      \"hwb(240,0%,50%)\",\n      \"hwb(240,0%,50%,1)\",\n      \"hwb(240,0%,50%,100%)\",\n    ],\n  },\n  \"oldlace\": {\n    \"hex\": [\n      \"#fdf5e6\", \"#fffdf5e6\",\n    ],\n    \"func\": [\n      \"rgb(253,245,230)\",\n      \"rgba(253,245,230,1)\",\n      \"rgba(253,245,230,100%)\",\n      \"rgb(99%,96%,90%)\",\n      \"rgba(99%,96%,90%,1)\",\n      \"rgba(99%,96%,90%,100%)\",\n      \"hsl(39,85%,95%)\",\n      \"hsla(39,85%,95%,1)\",\n      \"hsla(39,85%,95%,100%)\",\n      \"hwb(39,90%,1%)\",\n      \"hwb(39,90%,1%,1)\",\n      \"hwb(39,90%,1%,100%)\",\n    ],\n  },\n  \"olive\": {\n    \"hex\": [\n      \"#808000\", \"#ff808000\",\n    ],\n    \"func\": [\n      \"rgb(128,128,0)\",\n      \"rgba(128,128,0,1)\",\n      \"rgba(128,128,0,100%)\",\n      \"rgb(50%,50%,0%)\",\n      \"rgba(50%,50%,0%,1)\",\n      \"rgba(50%,50%,0%,100%)\",\n      \"hsl(60,100%,25%)\",\n      \"hsla(60,100%,25%,1)\",\n      \"hsla(60,100%,25%,100%)\",\n      \"hwb(60,0%,50%)\",\n      \"hwb(60,0%,50%,1)\",\n      \"hwb(60,0%,50%,100%)\",\n    ],\n  },\n  \"olivedrab\": {\n    \"hex\": [\n      \"#6b8e23\", \"#ff6b8e23\",\n    ],\n    \"func\": [\n      \"rgb(107,142,35)\",\n      \"rgba(107,142,35,1)\",\n      \"rgba(107,142,35,100%)\",\n      \"rgb(42%,56%,14%)\",\n      \"rgba(42%,56%,14%,1)\",\n      \"rgba(42%,56%,14%,100%)\",\n      \"hsl(80,60%,35%)\",\n      \"hsla(80,60%,35%,1)\",\n      \"hsla(80,60%,35%,100%)\",\n      \"hwb(80,14%,44%)\",\n      \"hwb(80,14%,44%,1)\",\n      \"hwb(80,14%,44%,100%)\",\n    ],\n  },\n  \"orange\": {\n    \"hex\": [\n      \"#ffa500\", \"#ffffa500\",\n    ],\n    \"func\": [\n      \"rgb(255,165,0)\",\n      \"rgba(255,165,0,1)\",\n      \"rgba(255,165,0,100%)\",\n      \"rgb(100%,65%,0%)\",\n      \"rgba(100%,65%,0%,1)\",\n      \"rgba(100%,65%,0%,100%)\",\n      \"hsl(39,100%,50%)\",\n      \"hsla(39,100%,50%,1)\",\n      \"hsla(39,100%,50%,100%)\",\n      \"hwb(39,0%,0%)\",\n      \"hwb(39,0%,0%,1)\",\n      \"hwb(39,0%,0%,100%)\",\n    ],\n  },\n  \"orangered\": {\n    \"hex\": [\n      \"#ff4500\", \"#ffff4500\",\n    ],\n    \"func\": [\n      \"rgb(255,69,0)\",\n      \"rgba(255,69,0,1)\",\n      \"rgba(255,69,0,100%)\",\n      \"rgb(100%,27%,0%)\",\n      \"rgba(100%,27%,0%,1)\",\n      \"rgba(100%,27%,0%,100%)\",\n      \"hsl(16,100%,50%)\",\n      \"hsla(16,100%,50%,1)\",\n      \"hsla(16,100%,50%,100%)\",\n      \"hwb(16,0%,0%)\",\n      \"hwb(16,0%,0%,1)\",\n      \"hwb(16,0%,0%,100%)\",\n    ],\n  },\n  \"orchid\": {\n    \"hex\": [\n      \"#da70d6\", \"#ffda70d6\",\n    ],\n    \"func\": [\n      \"rgb(218,112,214)\",\n      \"rgba(218,112,214,1)\",\n      \"rgba(218,112,214,100%)\",\n      \"rgb(85%,44%,84%)\",\n      \"rgba(85%,44%,84%,1)\",\n      \"rgba(85%,44%,84%,100%)\",\n      \"hsl(302,59%,65%)\",\n      \"hsla(302,59%,65%,1)\",\n      \"hsla(302,59%,65%,100%)\",\n      \"hwb(302,44%,15%)\",\n      \"hwb(302,44%,15%,1)\",\n      \"hwb(302,44%,15%,100%)\",\n    ],\n  },\n  \"palegoldenrod\": {\n    \"hex\": [\n      \"#eee8aa\", \"#ffeee8aa\",\n    ],\n    \"func\": [\n      \"rgb(238,232,170)\",\n      \"rgba(238,232,170,1)\",\n      \"rgba(238,232,170,100%)\",\n      \"rgb(93%,91%,67%)\",\n      \"rgba(93%,91%,67%,1)\",\n      \"rgba(93%,91%,67%,100%)\",\n      \"hsl(55,67%,80%)\",\n      \"hsla(55,67%,80%,1)\",\n      \"hsla(55,67%,80%,100%)\",\n      \"hwb(55,67%,7%)\",\n      \"hwb(55,67%,7%,1)\",\n      \"hwb(55,67%,7%,100%)\",\n    ],\n  },\n  \"palegreen\": {\n    \"hex\": [\n      \"#98fb98\", \"#ff98fb98\",\n    ],\n    \"func\": [\n      \"rgb(152,251,152)\",\n      \"rgba(152,251,152,1)\",\n      \"rgba(152,251,152,100%)\",\n      \"rgb(60%,98%,60%)\",\n      \"rgba(60%,98%,60%,1)\",\n      \"rgba(60%,98%,60%,100%)\",\n      \"hsl(120,93%,79%)\",\n      \"hsla(120,93%,79%,1)\",\n      \"hsla(120,93%,79%,100%)\",\n      \"hwb(120,60%,2%)\",\n      \"hwb(120,60%,2%,1)\",\n      \"hwb(120,60%,2%,100%)\",\n    ],\n  },\n  \"paleturquoise\": {\n    \"hex\": [\n      \"#afeeee\", \"#ffafeeee\",\n    ],\n    \"func\": [\n      \"rgb(175,238,238)\",\n      \"rgba(175,238,238,1)\",\n      \"rgba(175,238,238,100%)\",\n      \"rgb(69%,93%,93%)\",\n      \"rgba(69%,93%,93%,1)\",\n      \"rgba(69%,93%,93%,100%)\",\n      \"hsl(180,65%,81%)\",\n      \"hsla(180,65%,81%,1)\",\n      \"hsla(180,65%,81%,100%)\",\n      \"hwb(180,69%,7%)\",\n      \"hwb(180,69%,7%,1)\",\n      \"hwb(180,69%,7%,100%)\",\n    ],\n  },\n  \"palevioletred\": {\n    \"hex\": [\n      \"#db7093\", \"#ffdb7093\",\n    ],\n    \"func\": [\n      \"rgb(219,112,147)\",\n      \"rgba(219,112,147,1)\",\n      \"rgba(219,112,147,100%)\",\n      \"rgb(86%,44%,58%)\",\n      \"rgba(86%,44%,58%,1)\",\n      \"rgba(86%,44%,58%,100%)\",\n      \"hsl(340,60%,65%)\",\n      \"hsla(340,60%,65%,1)\",\n      \"hsla(340,60%,65%,100%)\",\n      \"hwb(340,44%,14%)\",\n      \"hwb(340,44%,14%,1)\",\n      \"hwb(340,44%,14%,100%)\",\n    ],\n  },\n  \"papayawhip\": {\n    \"hex\": [\n      \"#ffefd5\", \"#ffffefd5\",\n    ],\n    \"func\": [\n      \"rgb(255,239,213)\",\n      \"rgba(255,239,213,1)\",\n      \"rgba(255,239,213,100%)\",\n      \"rgb(100%,94%,84%)\",\n      \"rgba(100%,94%,84%,1)\",\n      \"rgba(100%,94%,84%,100%)\",\n      \"hsl(37,100%,92%)\",\n      \"hsla(37,100%,92%,1)\",\n      \"hsla(37,100%,92%,100%)\",\n      \"hwb(37,84%,0%)\",\n      \"hwb(37,84%,0%,1)\",\n      \"hwb(37,84%,0%,100%)\",\n    ],\n  },\n  \"peachpuff\": {\n    \"hex\": [\n      \"#ffdab9\", \"#ffffdab9\",\n    ],\n    \"func\": [\n      \"rgb(255,218,185)\",\n      \"rgba(255,218,185,1)\",\n      \"rgba(255,218,185,100%)\",\n      \"rgb(100%,85%,73%)\",\n      \"rgba(100%,85%,73%,1)\",\n      \"rgba(100%,85%,73%,100%)\",\n      \"hsl(28,100%,86%)\",\n      \"hsla(28,100%,86%,1)\",\n      \"hsla(28,100%,86%,100%)\",\n      \"hwb(28,73%,0%)\",\n      \"hwb(28,73%,0%,1)\",\n      \"hwb(28,73%,0%,100%)\",\n    ],\n  },\n  \"peru\": {\n    \"hex\": [\n      \"#cd853f\", \"#ffcd853f\",\n    ],\n    \"func\": [\n      \"rgb(205,133,63)\",\n      \"rgba(205,133,63,1)\",\n      \"rgba(205,133,63,100%)\",\n      \"rgb(80%,52%,25%)\",\n      \"rgba(80%,52%,25%,1)\",\n      \"rgba(80%,52%,25%,100%)\",\n      \"hsl(30,59%,53%)\",\n      \"hsla(30,59%,53%,1)\",\n      \"hsla(30,59%,53%,100%)\",\n      \"hwb(30,25%,20%)\",\n      \"hwb(30,25%,20%,1)\",\n      \"hwb(30,25%,20%,100%)\",\n    ],\n  },\n  \"pink\": {\n    \"hex\": [\n      \"#ffc0cb\", \"#ffffc0cb\",\n    ],\n    \"func\": [\n      \"rgb(255,192,203)\",\n      \"rgba(255,192,203,1)\",\n      \"rgba(255,192,203,100%)\",\n      \"rgb(100%,75%,80%)\",\n      \"rgba(100%,75%,80%,1)\",\n      \"rgba(100%,75%,80%,100%)\",\n      \"hsl(350,100%,88%)\",\n      \"hsla(350,100%,88%,1)\",\n      \"hsla(350,100%,88%,100%)\",\n      \"hwb(350,75%,0%)\",\n      \"hwb(350,75%,0%,1)\",\n      \"hwb(350,75%,0%,100%)\",\n    ],\n  },\n  \"plum\": {\n    \"hex\": [\n      \"#dda0dd\", \"#ffdda0dd\",\n    ],\n    \"func\": [\n      \"rgb(221,160,221)\",\n      \"rgba(221,160,221,1)\",\n      \"rgba(221,160,221,100%)\",\n      \"rgb(87%,63%,87%)\",\n      \"rgba(87%,63%,87%,1)\",\n      \"rgba(87%,63%,87%,100%)\",\n      \"hsl(300,47%,75%)\",\n      \"hsla(300,47%,75%,1)\",\n      \"hsla(300,47%,75%,100%)\",\n      \"hwb(300,63%,13%)\",\n      \"hwb(300,63%,13%,1)\",\n      \"hwb(300,63%,13%,100%)\",\n    ],\n  },\n  \"powderblue\": {\n    \"hex\": [\n      \"#b0e0e6\", \"#ffb0e0e6\",\n    ],\n    \"func\": [\n      \"rgb(176,224,230)\",\n      \"rgba(176,224,230,1)\",\n      \"rgba(176,224,230,100%)\",\n      \"rgb(69%,88%,90%)\",\n      \"rgba(69%,88%,90%,1)\",\n      \"rgba(69%,88%,90%,100%)\",\n      \"hsl(187,52%,80%)\",\n      \"hsla(187,52%,80%,1)\",\n      \"hsla(187,52%,80%,100%)\",\n      \"hwb(187,69%,10%)\",\n      \"hwb(187,69%,10%,1)\",\n      \"hwb(187,69%,10%,100%)\",\n    ],\n  },\n  \"purple\": {\n    \"hex\": [\n      \"#800080\", \"#ff800080\",\n    ],\n    \"func\": [\n      \"rgb(128,0,128)\",\n      \"rgba(128,0,128,1)\",\n      \"rgba(128,0,128,100%)\",\n      \"rgb(50%,0%,50%)\",\n      \"rgba(50%,0%,50%,1)\",\n      \"rgba(50%,0%,50%,100%)\",\n      \"hsl(300,100%,25%)\",\n      \"hsla(300,100%,25%,1)\",\n      \"hsla(300,100%,25%,100%)\",\n      \"hwb(300,0%,50%)\",\n      \"hwb(300,0%,50%,1)\",\n      \"hwb(300,0%,50%,100%)\",\n    ],\n  },\n  \"rebeccapurple\": {\n    \"hex\": [\n      \"#663399\", \"#ff663399\", \"#639\", \"#f639\",\n    ],\n    \"func\": [\n      \"rgb(102,51,153)\",\n      \"rgba(102,51,153,1)\",\n      \"rgba(102,51,153,100%)\",\n      \"rgb(40%,20%,60%)\",\n      \"rgba(40%,20%,60%,1)\",\n      \"rgba(40%,20%,60%,100%)\",\n      \"hsl(270,50%,40%)\",\n      \"hsla(270,50%,40%,1)\",\n      \"hsla(270,50%,40%,100%)\",\n      \"hwb(270,20%,40%)\",\n      \"hwb(270,20%,40%,1)\",\n      \"hwb(270,20%,40%,100%)\",\n    ],\n  },\n  \"red\": {\n    \"hex\": [\n      \"#ff0000\", \"#ffff0000\", \"#f00\", \"#ff00\",\n    ],\n    \"func\": [\n      \"rgb(255,0,0)\",\n      \"rgba(255,0,0,1)\",\n      \"rgba(255,0,0,100%)\",\n      \"rgb(100%,0%,0%)\",\n      \"rgba(100%,0%,0%,1)\",\n      \"rgba(100%,0%,0%,100%)\",\n      \"hsl(0,100%,50%)\",\n      \"hsla(0,100%,50%,1)\",\n      \"hsla(0,100%,50%,100%)\",\n      \"hwb(0,0%,0%)\",\n      \"hwb(0,0%,0%,1)\",\n      \"hwb(0,0%,0%,100%)\",\n    ],\n  },\n  \"rosybrown\": {\n    \"hex\": [\n      \"#bc8f8f\", \"#ffbc8f8f\",\n    ],\n    \"func\": [\n      \"rgb(188,143,143)\",\n      \"rgba(188,143,143,1)\",\n      \"rgba(188,143,143,100%)\",\n      \"rgb(74%,56%,56%)\",\n      \"rgba(74%,56%,56%,1)\",\n      \"rgba(74%,56%,56%,100%)\",\n      \"hsl(0,25%,65%)\",\n      \"hsla(0,25%,65%,1)\",\n      \"hsla(0,25%,65%,100%)\",\n      \"hwb(0,56%,26%)\",\n      \"hwb(0,56%,26%,1)\",\n      \"hwb(0,56%,26%,100%)\",\n    ],\n  },\n  \"royalblue\": {\n    \"hex\": [\n      \"#4169e1\", \"#ff4169e1\",\n    ],\n    \"func\": [\n      \"rgb(65,105,225)\",\n      \"rgba(65,105,225,1)\",\n      \"rgba(65,105,225,100%)\",\n      \"rgb(25%,41%,88%)\",\n      \"rgba(25%,41%,88%,1)\",\n      \"rgba(25%,41%,88%,100%)\",\n      \"hsl(225,73%,57%)\",\n      \"hsla(225,73%,57%,1)\",\n      \"hsla(225,73%,57%,100%)\",\n      \"hwb(225,25%,12%)\",\n      \"hwb(225,25%,12%,1)\",\n      \"hwb(225,25%,12%,100%)\",\n    ],\n  },\n  \"saddlebrown\": {\n    \"hex\": [\n      \"#8b4513\", \"#ff8b4513\",\n    ],\n    \"func\": [\n      \"rgb(139,69,19)\",\n      \"rgba(139,69,19,1)\",\n      \"rgba(139,69,19,100%)\",\n      \"rgb(55%,27%,7%)\",\n      \"rgba(55%,27%,7%,1)\",\n      \"rgba(55%,27%,7%,100%)\",\n      \"hsl(25,76%,31%)\",\n      \"hsla(25,76%,31%,1)\",\n      \"hsla(25,76%,31%,100%)\",\n      \"hwb(25,7%,45%)\",\n      \"hwb(25,7%,45%,1)\",\n      \"hwb(25,7%,45%,100%)\",\n    ],\n  },\n  \"salmon\": {\n    \"hex\": [\n      \"#fa8072\", \"#fffa8072\",\n    ],\n    \"func\": [\n      \"rgb(250,128,114)\",\n      \"rgba(250,128,114,1)\",\n      \"rgba(250,128,114,100%)\",\n      \"rgb(98%,50%,45%)\",\n      \"rgba(98%,50%,45%,1)\",\n      \"rgba(98%,50%,45%,100%)\",\n      \"hsl(6,93%,71%)\",\n      \"hsla(6,93%,71%,1)\",\n      \"hsla(6,93%,71%,100%)\",\n      \"hwb(6,45%,2%)\",\n      \"hwb(6,45%,2%,1)\",\n      \"hwb(6,45%,2%,100%)\",\n    ],\n  },\n  \"sandybrown\": {\n    \"hex\": [\n      \"#f4a460\", \"#fff4a460\",\n    ],\n    \"func\": [\n      \"rgb(244,164,96)\",\n      \"rgba(244,164,96,1)\",\n      \"rgba(244,164,96,100%)\",\n      \"rgb(96%,64%,38%)\",\n      \"rgba(96%,64%,38%,1)\",\n      \"rgba(96%,64%,38%,100%)\",\n      \"hsl(28,87%,67%)\",\n      \"hsla(28,87%,67%,1)\",\n      \"hsla(28,87%,67%,100%)\",\n      \"hwb(28,38%,4%)\",\n      \"hwb(28,38%,4%,1)\",\n      \"hwb(28,38%,4%,100%)\",\n    ],\n  },\n  \"seagreen\": {\n    \"hex\": [\n      \"#2e8b57\", \"#ff2e8b57\",\n    ],\n    \"func\": [\n      \"rgb(46,139,87)\",\n      \"rgba(46,139,87,1)\",\n      \"rgba(46,139,87,100%)\",\n      \"rgb(18%,55%,34%)\",\n      \"rgba(18%,55%,34%,1)\",\n      \"rgba(18%,55%,34%,100%)\",\n      \"hsl(146,50%,36%)\",\n      \"hsla(146,50%,36%,1)\",\n      \"hsla(146,50%,36%,100%)\",\n      \"hwb(146,18%,45%)\",\n      \"hwb(146,18%,45%,1)\",\n      \"hwb(146,18%,45%,100%)\",\n    ],\n  },\n  \"seashell\": {\n    \"hex\": [\n      \"#fff5ee\", \"#fffff5ee\",\n    ],\n    \"func\": [\n      \"rgb(255,245,238)\",\n      \"rgba(255,245,238,1)\",\n      \"rgba(255,245,238,100%)\",\n      \"rgb(100%,96%,93%)\",\n      \"rgba(100%,96%,93%,1)\",\n      \"rgba(100%,96%,93%,100%)\",\n      \"hsl(25,100%,97%)\",\n      \"hsla(25,100%,97%,1)\",\n      \"hsla(25,100%,97%,100%)\",\n      \"hwb(25,93%,0%)\",\n      \"hwb(25,93%,0%,1)\",\n      \"hwb(25,93%,0%,100%)\",\n    ],\n  },\n  \"sienna\": {\n    \"hex\": [\n      \"#a0522d\", \"#ffa0522d\",\n    ],\n    \"func\": [\n      \"rgb(160,82,45)\",\n      \"rgba(160,82,45,1)\",\n      \"rgba(160,82,45,100%)\",\n      \"rgb(63%,32%,18%)\",\n      \"rgba(63%,32%,18%,1)\",\n      \"rgba(63%,32%,18%,100%)\",\n      \"hsl(19,56%,40%)\",\n      \"hsla(19,56%,40%,1)\",\n      \"hsla(19,56%,40%,100%)\",\n      \"hwb(19,18%,37%)\",\n      \"hwb(19,18%,37%,1)\",\n      \"hwb(19,18%,37%,100%)\",\n    ],\n  },\n  \"silver\": {\n    \"hex\": [\n      \"#c0c0c0\", \"#ffc0c0c0\",\n    ],\n    \"func\": [\n      \"rgb(192,192,192)\",\n      \"rgba(192,192,192,1)\",\n      \"rgba(192,192,192,100%)\",\n      \"rgb(75%,75%,75%)\",\n      \"rgba(75%,75%,75%,1)\",\n      \"rgba(75%,75%,75%,100%)\",\n      \"hsl(0,0%,75%)\",\n      \"hsla(0,0%,75%,1)\",\n      \"hsla(0,0%,75%,100%)\",\n      \"hwb(0,75%,25%)\",\n      \"hwb(0,75%,25%,1)\",\n      \"hwb(0,75%,25%,100%)\",\n    ],\n  },\n  \"skyblue\": {\n    \"hex\": [\n      \"#87ceeb\", \"#ff87ceeb\",\n    ],\n    \"func\": [\n      \"rgb(135,206,235)\",\n      \"rgba(135,206,235,1)\",\n      \"rgba(135,206,235,100%)\",\n      \"rgb(53%,81%,92%)\",\n      \"rgba(53%,81%,92%,1)\",\n      \"rgba(53%,81%,92%,100%)\",\n      \"hsl(197,71%,73%)\",\n      \"hsla(197,71%,73%,1)\",\n      \"hsla(197,71%,73%,100%)\",\n      \"hwb(197,53%,8%)\",\n      \"hwb(197,53%,8%,1)\",\n      \"hwb(197,53%,8%,100%)\",\n    ],\n  },\n  \"slateblue\": {\n    \"hex\": [\n      \"#6a5acd\", \"#ff6a5acd\",\n    ],\n    \"func\": [\n      \"rgb(106,90,205)\",\n      \"rgba(106,90,205,1)\",\n      \"rgba(106,90,205,100%)\",\n      \"rgb(42%,35%,80%)\",\n      \"rgba(42%,35%,80%,1)\",\n      \"rgba(42%,35%,80%,100%)\",\n      \"hsl(248,53%,58%)\",\n      \"hsla(248,53%,58%,1)\",\n      \"hsla(248,53%,58%,100%)\",\n      \"hwb(248,35%,20%)\",\n      \"hwb(248,35%,20%,1)\",\n      \"hwb(248,35%,20%,100%)\",\n    ],\n  },\n  \"slategray\": {\n    \"hex\": [\n      \"#708090\", \"#ff708090\",\n    ],\n    \"func\": [\n      \"rgb(112,128,144)\",\n      \"rgba(112,128,144,1)\",\n      \"rgba(112,128,144,100%)\",\n      \"rgb(44%,50%,56%)\",\n      \"rgba(44%,50%,56%,1)\",\n      \"rgba(44%,50%,56%,100%)\",\n      \"hsl(210,13%,50%)\",\n      \"hsla(210,13%,50%,1)\",\n      \"hsla(210,13%,50%,100%)\",\n      \"hwb(210,44%,44%)\",\n      \"hwb(210,44%,44%,1)\",\n      \"hwb(210,44%,44%,100%)\",\n    ],\n  },\n  \"slategrey\": {\n    \"hex\": [\n      \"#708090\", \"#ff708090\",\n    ],\n    \"func\": [\n      \"rgb(112,128,144)\",\n      \"rgba(112,128,144,1)\",\n      \"rgba(112,128,144,100%)\",\n      \"rgb(44%,50%,56%)\",\n      \"rgba(44%,50%,56%,1)\",\n      \"rgba(44%,50%,56%,100%)\",\n      \"hsl(210,13%,50%)\",\n      \"hsla(210,13%,50%,1)\",\n      \"hsla(210,13%,50%,100%)\",\n      \"hwb(210,44%,44%)\",\n      \"hwb(210,44%,44%,1)\",\n      \"hwb(210,44%,44%,100%)\",\n    ],\n  },\n  \"snow\": {\n    \"hex\": [\n      \"#fffafa\", \"#fffffafa\",\n    ],\n    \"func\": [\n      \"rgb(255,250,250)\",\n      \"rgba(255,250,250,1)\",\n      \"rgba(255,250,250,100%)\",\n      \"rgb(100%,98%,98%)\",\n      \"rgba(100%,98%,98%,1)\",\n      \"rgba(100%,98%,98%,100%)\",\n      \"hsl(0,100%,99%)\",\n      \"hsla(0,100%,99%,1)\",\n      \"hsla(0,100%,99%,100%)\",\n      \"hwb(0,98%,0%)\",\n      \"hwb(0,98%,0%,1)\",\n      \"hwb(0,98%,0%,100%)\",\n    ],\n  },\n  \"springgreen\": {\n    \"hex\": [\n      \"#00ff7f\", \"#ff00ff7f\",\n    ],\n    \"func\": [\n      \"rgb(0,255,127)\",\n      \"rgba(0,255,127,1)\",\n      \"rgba(0,255,127,100%)\",\n      \"rgb(0%,100%,50%)\",\n      \"rgba(0%,100%,50%,1)\",\n      \"rgba(0%,100%,50%,100%)\",\n      \"hsl(150,100%,50%)\",\n      \"hsla(150,100%,50%,1)\",\n      \"hsla(150,100%,50%,100%)\",\n      \"hwb(150,0%,0%)\",\n      \"hwb(150,0%,0%,1)\",\n      \"hwb(150,0%,0%,100%)\",\n    ],\n  },\n  \"steelblue\": {\n    \"hex\": [\n      \"#4682b4\", \"#ff4682b4\",\n    ],\n    \"func\": [\n      \"rgb(70,130,180)\",\n      \"rgba(70,130,180,1)\",\n      \"rgba(70,130,180,100%)\",\n      \"rgb(27%,51%,71%)\",\n      \"rgba(27%,51%,71%,1)\",\n      \"rgba(27%,51%,71%,100%)\",\n      \"hsl(207,44%,49%)\",\n      \"hsla(207,44%,49%,1)\",\n      \"hsla(207,44%,49%,100%)\",\n      \"hwb(207,27%,29%)\",\n      \"hwb(207,27%,29%,1)\",\n      \"hwb(207,27%,29%,100%)\",\n    ],\n  },\n  \"tan\": {\n    \"hex\": [\n      \"#d2b48c\", \"#ffd2b48c\",\n    ],\n    \"func\": [\n      \"rgb(210,180,140)\",\n      \"rgba(210,180,140,1)\",\n      \"rgba(210,180,140,100%)\",\n      \"rgb(82%,71%,55%)\",\n      \"rgba(82%,71%,55%,1)\",\n      \"rgba(82%,71%,55%,100%)\",\n      \"hsl(34,44%,69%)\",\n      \"hsla(34,44%,69%,1)\",\n      \"hsla(34,44%,69%,100%)\",\n      \"hwb(34,55%,18%)\",\n      \"hwb(34,55%,18%,1)\",\n      \"hwb(34,55%,18%,100%)\",\n    ],\n  },\n  \"teal\": {\n    \"hex\": [\n      \"#008080\", \"#ff008080\",\n    ],\n    \"func\": [\n      \"rgb(0,128,128)\",\n      \"rgba(0,128,128,1)\",\n      \"rgba(0,128,128,100%)\",\n      \"rgb(0%,50%,50%)\",\n      \"rgba(0%,50%,50%,1)\",\n      \"rgba(0%,50%,50%,100%)\",\n      \"hsl(180,100%,25%)\",\n      \"hsla(180,100%,25%,1)\",\n      \"hsla(180,100%,25%,100%)\",\n      \"hwb(180,0%,50%)\",\n      \"hwb(180,0%,50%,1)\",\n      \"hwb(180,0%,50%,100%)\",\n    ],\n  },\n  \"thistle\": {\n    \"hex\": [\n      \"#d8bfd8\", \"#ffd8bfd8\",\n    ],\n    \"func\": [\n      \"rgb(216,191,216)\",\n      \"rgba(216,191,216,1)\",\n      \"rgba(216,191,216,100%)\",\n      \"rgb(85%,75%,85%)\",\n      \"rgba(85%,75%,85%,1)\",\n      \"rgba(85%,75%,85%,100%)\",\n      \"hsl(300,24%,80%)\",\n      \"hsla(300,24%,80%,1)\",\n      \"hsla(300,24%,80%,100%)\",\n      \"hwb(300,75%,15%)\",\n      \"hwb(300,75%,15%,1)\",\n      \"hwb(300,75%,15%,100%)\",\n    ],\n  },\n  \"tomato\": {\n    \"hex\": [\n      \"#ff6347\", \"#ffff6347\",\n    ],\n    \"func\": [\n      \"rgb(255,99,71)\",\n      \"rgba(255,99,71,1)\",\n      \"rgba(255,99,71,100%)\",\n      \"rgb(100%,39%,28%)\",\n      \"rgba(100%,39%,28%,1)\",\n      \"rgba(100%,39%,28%,100%)\",\n      \"hsl(9,100%,64%)\",\n      \"hsla(9,100%,64%,1)\",\n      \"hsla(9,100%,64%,100%)\",\n      \"hwb(9,28%,0%)\",\n      \"hwb(9,28%,0%,1)\",\n      \"hwb(9,28%,0%,100%)\",\n    ],\n  },\n  \"turquoise\": {\n    \"hex\": [\n      \"#40e0d0\", \"#ff40e0d0\",\n    ],\n    \"func\": [\n      \"rgb(64,224,208)\",\n      \"rgba(64,224,208,1)\",\n      \"rgba(64,224,208,100%)\",\n      \"rgb(25%,88%,82%)\",\n      \"rgba(25%,88%,82%,1)\",\n      \"rgba(25%,88%,82%,100%)\",\n      \"hsl(174,72%,56%)\",\n      \"hsla(174,72%,56%,1)\",\n      \"hsla(174,72%,56%,100%)\",\n      \"hwb(174,25%,12%)\",\n      \"hwb(174,25%,12%,1)\",\n      \"hwb(174,25%,12%,100%)\",\n    ],\n  },\n  \"violet\": {\n    \"hex\": [\n      \"#ee82ee\", \"#ffee82ee\",\n    ],\n    \"func\": [\n      \"rgb(238,130,238)\",\n      \"rgba(238,130,238,1)\",\n      \"rgba(238,130,238,100%)\",\n      \"rgb(93%,51%,93%)\",\n      \"rgba(93%,51%,93%,1)\",\n      \"rgba(93%,51%,93%,100%)\",\n      \"hsl(300,76%,72%)\",\n      \"hsla(300,76%,72%,1)\",\n      \"hsla(300,76%,72%,100%)\",\n      \"hwb(300,51%,7%)\",\n      \"hwb(300,51%,7%,1)\",\n      \"hwb(300,51%,7%,100%)\",\n    ],\n  },\n  \"wheat\": {\n    \"hex\": [\n      \"#f5deb3\", \"#fff5deb3\",\n    ],\n    \"func\": [\n      \"rgb(245,222,179)\",\n      \"rgba(245,222,179,1)\",\n      \"rgba(245,222,179,100%)\",\n      \"rgb(96%,87%,70%)\",\n      \"rgba(96%,87%,70%,1)\",\n      \"rgba(96%,87%,70%,100%)\",\n      \"hsl(39,77%,83%)\",\n      \"hsla(39,77%,83%,1)\",\n      \"hsla(39,77%,83%,100%)\",\n      \"hwb(39,70%,4%)\",\n      \"hwb(39,70%,4%,1)\",\n      \"hwb(39,70%,4%,100%)\",\n    ],\n  },\n  \"white\": {\n    \"hex\": [\n      \"#ffffff\", \"#ffffffff\", \"#fff\", \"#ffff\",\n    ],\n    \"func\": [\n      \"rgb(255,255,255)\",\n      \"rgba(255,255,255,1)\",\n      \"rgba(255,255,255,100%)\",\n      \"rgb(100%,100%,100%)\",\n      \"rgba(100%,100%,100%,1)\",\n      \"rgba(100%,100%,100%,100%)\",\n      \"hsl(0,0%,100%)\",\n      \"hsla(0,0%,100%,1)\",\n      \"hsla(0,0%,100%,100%)\",\n      \"hwb(0,100%,0%)\",\n      \"hwb(0,100%,0%,1)\",\n      \"hwb(0,100%,0%,100%)\",\n      \"gray(255)\",\n      \"gray(255,1)\",\n      \"gray(255,100%)\",\n      \"gray(255%)\",\n      \"gray(255%,1)\",\n      \"gray(255%,100%)\",\n    ],\n  },\n  \"whitesmoke\": {\n    \"hex\": [\n      \"#f5f5f5\", \"#fff5f5f5\",\n    ],\n    \"func\": [\n      \"rgb(245,245,245)\",\n      \"rgba(245,245,245,1)\",\n      \"rgba(245,245,245,100%)\",\n      \"rgb(96%,96%,96%)\",\n      \"rgba(96%,96%,96%,1)\",\n      \"rgba(96%,96%,96%,100%)\",\n      \"hsl(0,0%,96%)\",\n      \"hsla(0,0%,96%,1)\",\n      \"hsla(0,0%,96%,100%)\",\n      \"hwb(0,96%,4%)\",\n      \"hwb(0,96%,4%,1)\",\n      \"hwb(0,96%,4%,100%)\",\n      \"gray(245)\",\n      \"gray(245,1)\",\n      \"gray(245,100%)\",\n      \"gray(245%)\",\n      \"gray(245%,1)\",\n      \"gray(245%,100%)\",\n    ],\n  },\n  \"yellow\": {\n    \"hex\": [\n      \"#ffff00\", \"#ffffff00\", \"#ff0\", \"#fff0\",\n    ],\n    \"func\": [\n      \"rgb(255,255,0)\",\n      \"rgba(255,255,0,1)\",\n      \"rgba(255,255,0,100%)\",\n      \"rgb(100%,100%,0%)\",\n      \"rgba(100%,100%,0%,1)\",\n      \"rgba(100%,100%,0%,100%)\",\n      \"hsl(60,100%,50%)\",\n      \"hsla(60,100%,50%,1)\",\n      \"hsla(60,100%,50%,100%)\",\n      \"hwb(60,0%,0%)\",\n      \"hwb(60,0%,0%,1)\",\n      \"hwb(60,0%,0%,100%)\",\n    ],\n  },\n  \"yellowgreen\": {\n    \"hex\": [\n      \"#9acd32\", \"#ff9acd32\",\n    ],\n    \"func\": [\n      \"rgb(154,205,50)\",\n      \"rgba(154,205,50,1)\",\n      \"rgba(154,205,50,100%)\",\n      \"rgb(60%,80%,20%)\",\n      \"rgba(60%,80%,20%,1)\",\n      \"rgba(60%,80%,20%,100%)\",\n      \"hsl(80,61%,50%)\",\n      \"hsla(80,61%,50%,1)\",\n      \"hsla(80,61%,50%,100%)\",\n      \"hwb(80,20%,20%)\",\n      \"hwb(80,20%,20%,1)\",\n      \"hwb(80,20%,20%,100%)\",\n    ],\n  },\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/reference/propertySets.js":"\"use strict\"\n\nconst propertySets = {}\n\npropertySets.acceptCustomIdents = new Set([\n  \"animation\",\n  \"animation-name\",\n  \"font\",\n  \"font-family\",\n  \"counter-increment\",\n  \"grid-row\",\n  \"grid-column\",\n  \"grid-area\",\n  \"list-style\",\n  \"list-style-type\",\n])\n\nmodule.exports = propertySets\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/color-no-hex/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst styleSearch = require(\"style-search\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"color-no-hex\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: hex => `Unexpected hex color \"${hex}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const declString = decl.toString()\n\n      styleSearch({ source: declString, target: \"#\" }, match => {\n        // If there's not a colon, comma, or whitespace character before, we'll assume this is\n        // not intended to be a hex color, but is instead something like the\n        // hash in a url() argument\n        if (!/[:,\\s]/.test(declString[match.startIndex - 1])) {\n          return\n        }\n\n        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))\n        if (!hexMatch) {\n          return\n        }\n        const hexValue = hexMatch[0]\n\n        report({\n          message: messages.rejected(hexValue),\n          node: decl,\n          index: match.startIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/color-no-invalid-hex/index.js":"\"use strict\"\n\nconst isValidHex = require(\"../../utils/isValidHex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst styleSearch = require(\"style-search\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"color-no-invalid-hex\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: hex => `Unexpected invalid hex color \"${hex}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const declString = decl.toString()\n\n      styleSearch({ source: declString, target: \"#\" }, match => {\n        // If there's not a colon, comma, or whitespace character before, we'll assume this is\n        // not intended to be a hex color, but is instead something like the\n        // hash in a url() argument\n        if (!/[:,\\s]/.test(declString[match.startIndex - 1])) {\n          return\n        }\n\n        const hexMatch = /^#[0-9A-Za-z]+/.exec(declString.substr(match.startIndex))\n        if (!hexMatch) {\n          return\n        }\n\n        const hexValue = hexMatch[0]\n        if (isValidHex(hexValue)) {\n          return\n        }\n\n        report({\n          message: messages.rejected(hexValue),\n          node: decl,\n          index: match.startIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isValidHex.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a value is a valid 3, 4, 6 or 8 digit hex\n */\nmodule.exports = function (value/*: string*/)/*: boolean*/ {\n  return (/^#(?:[0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/.test(value)\n  )\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/comment-empty-line-before/index.js":"\"use strict\"\n\nconst hasEmptyLine = require(\"../../utils/hasEmptyLine\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"comment-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before comment\",\n  rejected: \"Unexpected empty line before comment\",\n})\n\nconst stylelintCommandPrefix = \"stylelint-\"\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        except: [\"first-nested\"],\n        ignore: [\n          \"stylelint-commands\",\n          \"stylelint-command\",\n          \"between-comments\",\n          \"after-comment\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    if (\n      optionsMatches(options, \"ignore\", \"between-comments\")\n    ) {\n      result.warn((\n        \"'comment-empty-line-before\\'s' \\\"between-comments\\\" option has been deprecated and in 8.0 will be removed. \" +\n        \"Instead use the \\\"after-comment\\\" option.\"\n      ), {\n        stylelintType: \"deprecation\",\n        stylelintReference: \"https://stylelint.io/user-guide/rules/comment-empty-line-before/\",\n      })\n    }\n\n    root.walkComments(comment => {\n      // Ignore the first node\n      if (comment === root.first) {\n        return\n      }\n\n      // Optionally ignore stylelint commands\n      if (\n        comment.text.indexOf(stylelintCommandPrefix) === 0\n        && optionsMatches(options, \"ignore\", \"stylelint-commands\")\n      ) {\n        return\n      }\n\n      // Optionally ignore newlines between comments\n      const prev = comment.prev()\n      if (\n        prev\n        && prev.type === \"comment\"\n        && optionsMatches(options, \"ignore\", \"between-comments\")\n      ) {\n        return\n      }\n\n      if (\n        prev\n        && prev.type === \"comment\"\n        && optionsMatches(options, \"ignore\", \"after-comment\")\n      ) {\n        return\n      }\n\n      if (\n        comment.raws.inline\n        || comment.inline\n      ) {\n        return\n      }\n\n      const before = (comment.raws.before || \"\")\n\n      // Ignore shared-line comments\n      if (before.indexOf(\"\\n\") === -1) {\n        return\n      }\n\n      const expectEmptyLineBefore = (() => {\n        if (\n          optionsMatches(options, \"except\", \"first-nested\")\n          && comment.parent !== root\n          && comment === comment.parent.first\n        ) {\n          return false\n        }\n        return expectation === \"always\"\n      })()\n\n      const hasEmptyLineBefore = hasEmptyLine(before)\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return\n      }\n\n      const message = expectEmptyLineBefore\n        ? messages.expected\n        : messages.rejected\n\n      report({\n        message,\n        node: comment,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/comment-no-empty/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"comment-no-empty\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected empty comment\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkComments(comment => {\n      // To ignore inline SCSS comments\n      if (\n        comment.raws.inline\n        || comment.inline\n      ) {\n        return\n      }\n\n      // To ignore comments that are not empty\n      if (\n        comment.text\n        && comment.text.length !== 0\n      ) {\n        return\n      }\n\n      report({\n        message: messages.rejected,\n        node: comment,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/comment-whitespace-inside/index.js":"\"use strict\"\n\nconst isWhitespace = require(\"../../utils/isWhitespace\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"comment-whitespace-inside\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: \"Expected whitespace after \\\"/*\\\"\",\n  rejectedOpening: \"Unexpected whitespace after \\\"/*\\\"\",\n  expectedClosing: \"Expected whitespace before \\\"*/\\\"\",\n  rejectedClosing: \"Unexpected whitespace before \\\"*/\\\"\",\n})\n\nconst rule = function (expectation) {\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkComments(function (comment) {\n      if (\n        comment.raws.inline\n        || comment.inline\n      ) {\n        return\n      }\n\n      const rawComment = comment.toString()\n      const firstFourChars = rawComment.substr(0, 4)\n\n      // Return early if sourcemap or copyright comment\n      if (/^\\/\\*[#!]\\s/.test(firstFourChars)) {\n        return\n      }\n\n      const leftMatches = rawComment.match(/(^\\/\\*+)(\\s)?/)\n      const rightMatches = rawComment.match(/(\\s)?(\\*+\\/)$/)\n      const opener = leftMatches[1]\n      const leftSpace = leftMatches[2] || \"\"\n      const rightSpace = rightMatches[1] || \"\"\n      const closer = rightMatches[2]\n\n      if (\n        expectation === \"never\"\n        && leftSpace !== \"\"\n      ) {\n        complain(messages.rejectedOpening, opener.length)\n      }\n\n      if (\n        expectation === \"always\"\n        && !isWhitespace(leftSpace)\n      ) {\n        complain(messages.expectedOpening, opener.length)\n      }\n\n      if (\n        expectation === \"never\"\n        && rightSpace !== \"\"\n      ) {\n        complain(messages.rejectedClosing, comment.toString().length - closer.length - 1)\n      }\n\n      if (\n        expectation === \"always\"\n        && !isWhitespace(rightSpace)\n      ) {\n        complain(messages.expectedClosing, comment.toString().length - closer.length - 1)\n      }\n\n      function complain(message, index) {\n        report({\n          message,\n          index,\n          result,\n          ruleName,\n          node: comment,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/comment-word-blacklist/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst containsString = require(\"../../utils/containsString\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"comment-word-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: pattern => `Unexpected word matching pattern \"${pattern}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkComments(comment => {\n      const text = comment.text\n      const rawComment = comment.toString()\n      const firstFourChars = rawComment.substr(0, 4)\n\n      // Return early if sourcemap\n      if (firstFourChars === \"/*# \") {\n        return\n      }\n\n      const matchesWord = matchesStringOrRegExp(text, blacklist) || containsString(text, blacklist)\n\n      if (!matchesWord) {\n        return\n      }\n\n      report({\n        message: messages.rejected(matchesWord.pattern),\n        node: comment,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/containsString.js":"/* @flow */\n\"use strict\"\n\n/**\n * Checks if a string contains a value. The comparison value can be a string or\n * an array of strings.\n *\n * Any strings starting and ending with `/` are ignored. Use the\n * matchesStringOrRegExp() util to match regexes.\n */\nmodule.exports = function containsString(\n  input/*: string*/,\n  comparison/*: string | Array<string>*/\n)/*: false | { match: string, pattern: string }*/ {\n  if (!Array.isArray(comparison)) {\n    return testAgainstString(input, comparison)\n  }\n\n  for (const comparisonItem of comparison) {\n    const testResult = testAgainstString(input, comparisonItem)\n    if (testResult) {\n      return testResult\n    }\n  }\n  return false\n}\n\nfunction testAgainstString(value, comparison) {\n  if (!comparison) return false\n  if (comparison[0] === \"/\" && comparison[comparison.length - 1] === \"/\") {\n    return false\n  }\n\n  if (value.indexOf(comparison) >= 0) {\n    return { match: value, pattern: comparison }\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/custom-media-pattern/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"custom-media-pattern\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected custom media query name to match specified pattern\",\n})\n\nconst rule = function (pattern) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [\n        _.isRegExp,\n        _.isString,\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern\n\n    root.walkAtRules(atRule => {\n      if (atRule.name.toLowerCase() !== \"custom-media\") {\n        return\n      }\n\n      const customMediaName = atRule.params.match(/^--(\\S+)\\b/)[1]\n\n      if (regexpPattern.test(customMediaName)) {\n        return\n      }\n\n      report({\n        message: messages.expected,\n        node: atRule,\n        index: atRuleParamIndex(atRule),\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/atRuleParamIndex.js":"/* @flow */\n\"use strict\"\nmodule.exports = function (atRule/*: postcss$atRule*/)/*: number*/ {\n  // Initial 1 is for the `@`\n  let index = 1 + atRule.name.length\n  if (atRule.raws.afterName) {\n    index += atRule.raws.afterName.length\n  }\n  return index\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/custom-property-empty-line-before/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst hasEmptyLine = require(\"../../utils/hasEmptyLine\")\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst isStandardSyntaxDeclaration = require(\"../../utils/isStandardSyntaxDeclaration\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"custom-property-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before custom property\",\n  rejected: \"Unexpected empty line before custom property\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        except: [\n          \"first-nested\",\n          \"after-comment\",\n          \"after-custom-property\",\n        ],\n        ignore: [\n          \"after-comment\",\n          \"inside-single-line-block\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        parent = decl.parent\n\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return\n      }\n      if (!isCustomProperty(prop)) {\n        return\n      }\n\n      // Optionally ignore the node if a comment precedes it\n      if (\n        optionsMatches(options, \"ignore\", \"after-comment\")\n        && decl.prev()\n        && decl.prev().type === \"comment\"\n      ) {\n        return\n      }\n\n      // Optionally ignore nodes inside single-line blocks\n      if (\n        optionsMatches(options, \"ignore\", \"inside-single-line-block\")\n        && isSingleLineString(blockString(parent))\n      ) {\n        return\n      }\n\n      let expectEmptyLineBefore = expectation === \"always\" ? true : false\n\n      // Optionally reverse the expectation for the first nested node\n      if (\n        optionsMatches(options, \"except\", \"first-nested\")\n        && decl === parent.first\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation if a comment precedes this node\n      if (\n        optionsMatches(options, \"except\", \"after-comment\")\n        && decl.prev()\n        && decl.prev().type === \"comment\"\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation if a custom property precedes this node\n      if (\n        optionsMatches(options, \"except\", \"after-custom-property\")\n        && decl.prev()\n        && decl.prev().prop\n        && isCustomProperty(decl.prev().prop)\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before)\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected\n      report({\n        message,\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isCustomProperty.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a property is a custom one\n */\nmodule.exports = function (property/*: string*/)/*: boolean*/ {\n  return property.slice(0, 2) === \"--\"\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxDeclaration.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a declaration is standard\n */\nmodule.exports = function (decl/*: Object*/)/*: boolean*/ {\n  const prop = decl.prop,\n    parent = decl.parent\n\n  // Declarations belong in a declaration block\n\n  if (parent.type === \"root\") {\n    return false\n  }\n\n  // SCSS var (e.g. $var: x), nested list (e.g. $list: (x)) or nested map (e.g. $map: (key:value))\n  if (prop[0] === \"$\") {\n    return false\n  }\n\n  // Less var (e.g. @var: x), but exclude variable interpolation (e.g. @{var})\n  if (prop[0] === \"@\" && prop[1] !== \"{\") {\n    return false\n  }\n\n  // SCSS nested properties (e.g. border: { style: solid; color: red; })\n  if (parent.selector && parent.selector[parent.selector.length - 1] === \":\" && parent.selector.substring(0, 2) !== \"--\") {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/custom-property-no-outside-root/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"custom-property-no-outside-root\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected custom property\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use the community 'stylelint-suitcss' plugin pack.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkRules(rule => {\n      // Ignore rules whose selector is just `:root`\n      if (rule.selector.toLowerCase().trim() === \":root\") {\n        return\n      }\n\n      rule.walkDecls(decl => {\n        if (!isCustomProperty(decl.prop)) {\n          return\n        }\n        report({\n          message: messages.rejected,\n          node: decl,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/custom-property-pattern/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"custom-property-pattern\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected custom property name to match specified pattern\",\n})\n\nconst rule = function (pattern) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [\n        _.isRegExp,\n        _.isString,\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const regexpPattern = _.isString(pattern) ? new RegExp(pattern) : pattern\n\n    root.walkDecls(decl => {\n      const prop = decl.prop\n\n      if (!isCustomProperty(prop)) {\n        return\n      }\n      if (regexpPattern.test(prop.slice(2))) {\n        return\n      }\n\n      report({\n        message: messages.expected,\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-bang-space-after/index.js":"\"use strict\"\n\nconst declarationBangSpaceChecker = require(\"../declarationBangSpaceChecker\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-bang-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\"!\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\"!\\\"\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    declarationBangSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declarationBangSpaceChecker.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../utils/declarationValueIndex\")\nconst report = require(\"../utils/report\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (opts) {\n  opts.root.walkDecls(function (decl) {\n    const indexOffset = declarationValueIndex(decl)\n    const declString = decl.toString()\n    const valueString = decl.toString().slice(indexOffset)\n    if (valueString.indexOf(\"!\") == -1) {\n      return\n    }\n\n    styleSearch({ source: valueString, target: \"!\" }, match => {\n      check(declString, match.startIndex + indexOffset, decl)\n    })\n  })\n\n  function check(source, index, node) {\n    opts.locationChecker({ source, index, err: m => report({\n      message: m,\n      node,\n      index,\n      result: opts.result,\n      ruleName: opts.checkedRuleName,\n    }),\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-bang-space-before/index.js":"\"use strict\"\n\nconst declarationBangSpaceChecker = require(\"../declarationBangSpaceChecker\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-bang-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\"!\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\"!\\\"\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    declarationBangSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-no-duplicate-properties/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-block-no-duplicate-properties\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: property => `Unexpected duplicate \"${property}\"`,\n})\n\nconst rule = function (on, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual: on }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"consecutive-duplicates\",\n          \"consecutive-duplicates-with-different-values\",\n        ],\n        ignoreProperties: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // In order to accommodate nested blocks (postcss-nested),\n    // we need to run a shallow loop (instead of eachDecl() or eachRule(),\n    // which loop recursively) and allow each nested block to accumulate\n    // its own list of properties -- so that a property in a nested rule\n    // does not conflict with the same property in the parent rule\n    root.each(node => {\n      if (\n        node.type === \"rule\"\n        || node.type === \"atrule\"\n      ) {\n        checkRulesInNode(node)\n      }\n    })\n\n    function checkRulesInNode(node) {\n      const decls = []\n      const values = []\n\n      node.each(child => {\n        if (\n          child.nodes\n          && child.nodes.length\n        ) {\n          checkRulesInNode(child)\n        }\n\n        if (child.type !== \"decl\") {\n          return\n        }\n\n        const prop = child.prop\n        const value = child.value\n\n        if (!isStandardSyntaxProperty(prop)) {\n          return\n        }\n        if (isCustomProperty(prop)) {\n          return\n        }\n\n        // Return early if the property is to be ignored\n        if (optionsMatches(options, \"ignoreProperties\", prop)) {\n          return\n        }\n\n        // Ignore the src property as commonly duplicated in at-fontface\n        if (prop.toLowerCase() === \"src\") {\n          return\n        }\n\n        const indexDuplicate = decls.indexOf(prop.toLowerCase())\n\n        if (indexDuplicate !== -1) {\n          if (optionsMatches(options, \"ignore\", \"consecutive-duplicates-with-different-values\")) {\n            // if duplicates are not consecutive\n            if (indexDuplicate !== decls.length - 1) {\n              report({\n                message: messages.rejected(prop),\n                node: child,\n                result,\n                ruleName,\n              })\n              return\n            }\n            // if values of consecutive duplicates are equal\n            if (value === values[indexDuplicate]) {\n              report({\n                message: messages.rejected(value),\n                node: child,\n                result,\n                ruleName,\n              })\n              return\n            }\n            return\n          }\n\n          if (\n            optionsMatches(options, \"ignore\", \"consecutive-duplicates\")\n            && indexDuplicate === decls.length - 1\n          ) {\n            return\n          }\n\n          report({\n            message: messages.rejected(prop),\n            node: child,\n            result,\n            ruleName,\n          })\n        }\n\n        decls.push(prop.toLowerCase())\n        values.push(value.toLowerCase())\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxProperty.js":"/* @flow */\n\"use strict\"\n\nconst hasInterpolation = require(\"../utils/hasInterpolation\")\n/**\n * Check whether a property is standard\n */\nmodule.exports = function (property/*: string*/)/*: boolean*/ {\n  // SCSS var (e.g. $var: x), list (e.g. $list: (x)) or map (e.g. $map: (key:value))\n  if (property[0] === \"$\") {\n    return false\n  }\n\n  // Less var (e.g. @var: x)\n  if (property[0] === \"@\") {\n    return false\n  }\n\n  // SCSS or Less interpolation\n  if (hasInterpolation(property)) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-no-ignored-properties/index.js":"\"use strict\"\n\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst postcss = require(\"postcss\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-block-no-ignored-properties\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (ignored, cause) => `Unexpected \"${ignored}\" with \"${cause}\"`,\n})\n\nconst ignored = [\n  {\n    property: \"display\",\n    value: \"inline\",\n    ignoredProperties: [\n      \"width\",\n      \"min-width\",\n      \"max-width\",\n      \"height\",\n      \"min-height\",\n      \"max-height\",\n      \"margin\",\n      \"margin-top\",\n      \"margin-bottom\",\n      \"overflow\",\n      \"overflow-x\",\n      \"overflow-y\",\n    ],\n  },\n  {\n    property: \"display\",\n    value: \"list-item\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"display\",\n    value: \"block\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"display\",\n    value: \"flex\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"display\",\n    value: \"table\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"display\",\n    value: \"/^table-.*$/\",\n    ignoredProperties: [\n      \"margin\",\n      \"margin-top\",\n      \"margin-right\",\n      \"margin-bottom\",\n      \"margin-left\",\n    ],\n  },\n  {\n    property: \"display\",\n    value: \"/^table-(row|row-group|column|column-group|header-group|footer-group|caption).*$/\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"display\",\n    value: \"/^table-(row|row-group).*$/\",\n    ignoredProperties: [\n      \"width\",\n      \"min-width\",\n      \"max-width\",\n    ],\n  },\n  {\n    property: \"display\",\n    value: \"/^table-(column|column-group).*$/\",\n    ignoredProperties: [\n      \"height\",\n      \"min-height\",\n      \"max-height\",\n    ],\n  },\n  {\n    property: \"float\",\n    value: \"left\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"float\",\n    value: \"right\",\n    ignoredProperties: [\"vertical-align\"],\n  },\n  {\n    property: \"position\",\n    value: \"static\",\n    ignoredProperties: [\n      \"top\",\n      \"right\",\n      \"bottom\",\n      \"left\",\n    ],\n  },\n  {\n    property: \"position\",\n    value: \"absolute\",\n    ignoredProperties: [\n      \"float\",\n      \"clear\",\n      \"vertical-align\",\n    ],\n  },\n  {\n    property: \"position\",\n    value: \"fixed\",\n    ignoredProperties: [\n      \"float\",\n      \"clear\",\n      \"vertical-align\",\n    ],\n  },\n]\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      \"'declaration-block-no-ignored-properties' has been deprecated and in 8.0 will be removed.\"\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: \"https://stylelint.io/user-guide/rules/declaration-block-no-ignored-properties/\",\n    })\n\n    const uniqueDecls = {}\n    root.walkDecls(decl => {\n      uniqueDecls[decl.prop] = decl\n    })\n\n    Object.keys(uniqueDecls).forEach((prop, index) => {\n      const decl = uniqueDecls[prop]\n      const unprefixedProp = postcss.vendor.unprefixed(prop)\n      const unprefixedValue = postcss.vendor.unprefixed(decl.value)\n\n      ignored.forEach(ignore => {\n        const matchProperty = matchesStringOrRegExp(unprefixedProp.toLowerCase(), ignore.property)\n        const matchValue = matchesStringOrRegExp(unprefixedValue.toLowerCase(), ignore.value)\n\n        if (!matchProperty || !matchValue) {\n          return\n        }\n\n        const ignoredProperties = ignore.ignoredProperties\n\n        decl.parent.nodes.forEach((node, nodeIndex) => {\n          if (!node.prop || ignoredProperties.indexOf(node.prop.toLowerCase()) === -1 || index === nodeIndex) {\n            return\n          }\n\n          report({\n            message: messages.rejected(node.prop, decl.toString()),\n            node,\n            result,\n            ruleName,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-no-redundant-longhand-properties/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst shorthandData = require(\"../../reference/shorthandData\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-block-no-redundant-longhand-properties\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: props => `Expected shorthand property \"${props}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignoreShorthands: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const longhandProperties = _.transform(shorthandData, (result, values, key) => {\n      if (optionsMatches(options, \"ignoreShorthands\", key)) {\n        return\n      }\n\n      values.forEach(value => {\n        (result[value] || (result[value] = [])).push(key)\n      })\n    })\n\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      const longhandDeclarations = {}\n      // Shallow iteration so nesting doesn't produce\n      // false positives\n      statement.each(node => {\n        if (node.type !== \"decl\") {\n          return\n        }\n\n        const prop = node.prop.toLowerCase()\n\n        const shorthandProperties = longhandProperties[prop]\n\n        if (!shorthandProperties) {\n          return\n        }\n\n        shorthandProperties.forEach(shorthandProperty => {\n          (longhandDeclarations[shorthandProperty] || (longhandDeclarations[shorthandProperty] = [])).push(prop)\n\n          if (!_.isEqual(shorthandData[shorthandProperty].sort(), longhandDeclarations[shorthandProperty].sort())) {\n            return\n          }\n\n          report({\n            ruleName,\n            result,\n            node,\n            message: messages.expected(shorthandProperty),\n          })\n        })\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/reference/shorthandData.js":"\"use strict\"\n\nmodule.exports = {\n  \"margin\": [\n    \"margin-top\",\n    \"margin-bottom\",\n    \"margin-left\",\n    \"margin-right\",\n  ],\n  \"padding\": [\n    \"padding-top\",\n    \"padding-bottom\",\n    \"padding-left\",\n    \"padding-right\",\n  ],\n  \"background\": [\n    \"background-image\",\n    \"background-size\",\n    \"background-position\",\n    \"background-repeat\",\n    \"background-origin\",\n    \"background-clip\",\n    \"background-attachment\",\n    \"background-color\",\n  ],\n  \"font\": [\n    \"font-style\",\n    \"font-variant\",\n    \"font-weight\",\n    \"font-stretch\",\n    \"font-size\",\n    \"font-family\",\n    \"line-height\",\n  ],\n  \"border\": [\n    \"border-top-width\",\n    \"border-bottom-width\",\n    \"border-left-width\",\n    \"border-right-width\",\n    \"border-top-style\",\n    \"border-bottom-style\",\n    \"border-left-style\",\n    \"border-right-style\",\n    \"border-top-color\",\n    \"border-bottom-color\",\n    \"border-left-color\",\n    \"border-right-color\",\n  ],\n  \"border-top\": [\n    \"border-top-width\",\n    \"border-top-style\",\n    \"border-top-color\",\n  ],\n  \"border-bottom\": [\n    \"border-bottom-width\",\n    \"border-bottom-style\",\n    \"border-bottom-color\",\n  ],\n  \"border-left\": [\n    \"border-left-width\",\n    \"border-left-style\",\n    \"border-left-color\",\n  ],\n  \"border-right\": [\n    \"border-right-width\",\n    \"border-right-style\",\n    \"border-right-color\",\n  ],\n  \"border-width\": [\n    \"border-top-width\",\n    \"border-bottom-width\",\n    \"border-left-width\",\n    \"border-right-width\",\n  ],\n  \"border-style\": [\n    \"border-top-style\",\n    \"border-bottom-style\",\n    \"border-left-style\",\n    \"border-right-style\",\n  ],\n  \"border-color\": [\n    \"border-top-color\",\n    \"border-bottom-color\",\n    \"border-left-color\",\n    \"border-right-color\",\n  ],\n  \"list-style\": [\n    \"list-style-type\",\n    \"list-style-position\",\n    \"list-style-image\",\n  ],\n  \"border-radius\": [\n    \"border-top-right-radius\",\n    \"border-top-left-radius\",\n    \"border-bottom-right-radius\",\n    \"border-bottom-left-radius\",\n  ],\n  \"transition\": [\n    \"transition-delay\",\n    \"transition-duration\",\n    \"transition-property\",\n    \"transition-timing-function\",\n  ],\n  \"-webkit-transition\": [\n    \"-webkit-transition-delay\",\n    \"-webkit-transition-duration\",\n    \"-webkit-transition-property\",\n    \"-webkit-transition-timing-function\",\n  ],\n  \"-moz-transition\": [\n    \"-moz-transition-delay\",\n    \"-moz-transition-duration\",\n    \"-moz-transition-property\",\n    \"-moz-transition-timing-function\",\n  ],\n  \"-o-transition\": [ \"-o-transition-delay\",\n    \"-o-transition-duration\",\n    \"-o-transition-property\",\n    \"-o-transition-timing-function\" ],\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-no-shorthand-property-overrides/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst shorthandData = require(\"../../reference/shorthandData\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-block-no-shorthand-property-overrides\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (shorthand, original) => `Unexpected shorthand \"${shorthand}\" after \"${original}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(check)\n    root.walkAtRules(check)\n\n    function check(statement) {\n      const declarations = {}\n      // Shallow iteration so nesting doesn't produce\n      // false positives\n      statement.each(node => {\n        if (node.type !== \"decl\") {\n          return\n        }\n        const prop = node.prop\n\n        const overrideables = shorthandData[prop.toLowerCase()]\n        if (!overrideables) {\n          declarations[prop.toLowerCase()] = prop\n          return\n        }\n        overrideables.forEach(longhandProp => {\n          if (!declarations.hasOwnProperty(longhandProp)) {\n            return\n          }\n          report({\n            ruleName,\n            result,\n            node,\n            message: messages.rejected(prop, declarations[longhandProp]),\n          })\n        })\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-properties-order/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"declaration-block-properties-order\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (first, second) => `Expected \"${first}\" to come before \"${second}\"`,\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: validatePrimaryOption,\n    }, {\n      actual: options,\n      possible: {\n        unspecified: [\n          \"top\",\n          \"bottom\",\n          \"ignore\",\n          \"bottomAlphabetical\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      \"'declaration-block-properties-order'has been deprecated and in 8.0 will be removed. \" +\n      \"Instead use the community 'stylelint-order' plugin pack.\"\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: \"https://stylelint.io/user-guide/rules/declaration-block-properties-order/\",\n    })\n\n    const alphabetical = expectation === \"alphabetical\"\n    const expectedOrder = alphabetical ? null : createExpectedOrder(expectation)\n    // By default, ignore unspecified properties\n    const unspecified = _.get(options, [\"unspecified\"], \"ignore\")\n\n    // Shallow loop\n    root.each(node => {\n      if (node.type === \"rule\" || node.type === \"atrule\") {\n        checkNode(node)\n      }\n    })\n\n    function checkNode(node) {\n      const allPropData = []\n\n      node.each(child => {\n        // If the child has nested nodes with child\n        // (e.g. a rule nested within a rule), make\n        // sure to check the children\n        if (child.nodes && child.nodes.length) {\n          checkNode(child)\n        }\n\n        if (child.type !== \"decl\") {\n          return\n        }\n\n        const prop = child.prop\n\n        if (!isStandardSyntaxProperty(prop)) {\n          return\n        }\n        if (isCustomProperty(prop)) {\n          return\n        }\n\n        let unprefixedPropName = postcss.vendor.unprefixed(prop)\n\n        // Hack to allow -moz-osx-font-smoothing to be understood\n        // just like -webkit-font-smoothing\n        if (unprefixedPropName.indexOf(\"osx-\") === 0) {\n          unprefixedPropName = unprefixedPropName.slice(4)\n        }\n\n        const propData = {\n          name: prop,\n          unprefixedName: unprefixedPropName,\n          orderData: alphabetical ? null : getOrderData(expectedOrder, unprefixedPropName),\n          before: child.raws.before,\n          index: allPropData.length,\n          node: child,\n        }\n\n        const previousPropData = _.last(allPropData)\n        allPropData.push(propData)\n\n        // Skip first decl\n        if (!previousPropData) {\n          return\n        }\n\n        const isCorrectOrder = alphabetical ? checkAlpabeticalOrder(previousPropData, propData) : checkOrder(previousPropData, propData)\n\n        if (isCorrectOrder) {\n          return\n        }\n\n        complain({\n          message: messages.expected(propData.name, previousPropData.name),\n          node: child,\n        })\n      })\n\n      function checkOrder(firstPropData, secondPropData) {\n        // If the unprefixed property names are the same, resort to alphabetical ordering\n        if (firstPropData.unprefixedName === secondPropData.unprefixedName) {\n          return firstPropData.name <= secondPropData.name\n        }\n\n        const firstPropIsUnspecified = !firstPropData.orderData\n        const secondPropIsUnspecified = !secondPropData.orderData\n\n        // Now check actual known properties ...\n        if (!firstPropIsUnspecified && !secondPropIsUnspecified) {\n          return firstPropData.orderData.expectedPosition <= secondPropData.orderData.expectedPosition\n        }\n\n        if (firstPropIsUnspecified && !secondPropIsUnspecified) {\n          // If first prop is unspecified, look for a specified prop before it to\n          // compare to the current prop\n          const priorSpecifiedPropData = _.findLast(allPropData.slice(0, -1), d => !!d.orderData)\n          if (priorSpecifiedPropData && priorSpecifiedPropData.orderData && priorSpecifiedPropData.orderData.expectedPosition > secondPropData.orderData.expectedPosition) {\n            complain({\n              message: messages.expected(secondPropData.name, priorSpecifiedPropData.name),\n              node: secondPropData.node,\n            })\n            return true // avoid logging another warning\n          }\n        }\n\n        // Now deal with unspecified props ...\n        // Starting with bottomAlphabetical as it requires more specific conditionals\n        if (unspecified === \"bottomAlphabetical\" && !firstPropIsUnspecified && secondPropIsUnspecified) {\n          return true\n        }\n\n        if (unspecified === \"bottomAlphabetical\" && secondPropIsUnspecified && firstPropIsUnspecified) {\n          if (checkAlpabeticalOrder(firstPropData, secondPropData)) {\n            return true\n          } else {\n            return false\n          }\n        }\n        if (unspecified === \"bottomAlphabetical\" && firstPropIsUnspecified) {\n          return false\n        }\n\n        if (firstPropIsUnspecified && secondPropIsUnspecified) {\n          return true\n        }\n\n        if (unspecified === \"ignore\" && (firstPropIsUnspecified || secondPropIsUnspecified)) {\n          return true\n        }\n\n        if (unspecified === \"top\" && firstPropIsUnspecified) {\n          return true\n        }\n        if (unspecified === \"top\" && secondPropIsUnspecified) {\n          return false\n        }\n\n        if (unspecified === \"bottom\" && secondPropIsUnspecified) {\n          return true\n        }\n        if (unspecified === \"bottom\" && firstPropIsUnspecified) {\n          return false\n        }\n      }\n    }\n\n    function complain(opts) {\n      report({\n        message: opts.message,\n        node: opts.node,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n\nfunction createExpectedOrder(input) {\n  const order = {}\n  let expectedPosition = 0\n\n  appendGroup(input)\n\n  function appendGroup(items) {\n    items.forEach(item => appendItem(item, false))\n  }\n\n  function appendItem(item, inFlexibleGroup) {\n    if (_.isString(item)) {\n      // In flexible groups, the expectedPosition does not ascend\n      // to make that flexibility work;\n      // otherwise, it will always ascend\n      if (!inFlexibleGroup) {\n        expectedPosition += 1\n      }\n      order[item] = { expectedPosition }\n      return\n    }\n\n    if (!item.order || item.order === \"strict\") {\n      appendGroup(item.properties)\n      return\n    } else if (item.order === \"flexible\") {\n      expectedPosition += 1\n      item.properties.forEach(property => {\n        appendItem(property, true)\n      })\n    }\n  }\n\n  return order\n}\n\nfunction getOrderData(expectedOrder, propName) {\n  let orderData = expectedOrder[propName]\n  // If prop was not specified but has a hyphen\n  // (e.g. `padding-top`), try looking for the segment preceding the hyphen\n  // and use that index\n  if (!orderData && propName.lastIndexOf(\"-\") !== -1) {\n    const propNamePreHyphen = propName.slice(0, propName.lastIndexOf(\"-\"))\n    orderData = getOrderData(expectedOrder, propNamePreHyphen)\n  }\n  return orderData\n}\n\nfunction checkAlpabeticalOrder(firstPropData, secondPropData) {\n  // If unprefixed prop names are the same, compare the prefixed versions\n  if (firstPropData.unprefixedName === secondPropData.unprefixedName) {\n    return firstPropData.name <= secondPropData.name\n  }\n\n  return firstPropData.unprefixedName < secondPropData.unprefixedName\n}\n\nfunction validatePrimaryOption(actualOptions) {\n  // Return true early if alphabetical\n  if (actualOptions === \"alphabetical\") {\n    return true\n  }\n\n  // Otherwise, begin checking array options\n  if (!Array.isArray(actualOptions)) {\n    return false\n  }\n\n  // Every item in the array must be a string or an object\n  // with a \"properties\" property\n  if (!actualOptions.every(item => {\n    if (_.isString(item)) {\n      return true\n    }\n    return _.isPlainObject(item) && !_.isUndefined(item.properties)\n  })) {\n    return false\n  }\n\n  const objectItems = actualOptions.filter(_.isPlainObject)\n\n  // Every object-item's \"order\" property must be \"strict\" or \"flexible\"\n  if (!objectItems.every(item => {\n    if (_.isUndefined(item.order)) {\n      return true\n    }\n    return _.includes([\n      \"strict\",\n      \"flexible\",\n    ], item.order)\n  })) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-semicolon-newline-after/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst nextNonCommentNode = require(\"../../utils/nextNonCommentNode\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-block-semicolon-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\";\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\";\\\" in a multi-line declaration block\",\n  rejectedAfterMultiLine: () => \"Unexpected newline after \\\";\\\" in a multi-line declaration block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      // Ignore last declaration if there's no trailing semicolon\n      const parentRule = decl.parent\n      if (\n        !parentRule.raws.semicolon\n        && parentRule.last === decl\n      ) {\n        return\n      }\n\n      const nextNode = decl.next()\n      if (!nextNode) {\n        return\n      }\n\n      // Allow end-of-line comment\n      const nodeToCheck = nextNonCommentNode(nextNode)\n      if (!nodeToCheck) {\n        return\n      }\n\n      checker.afterOneOnly({\n        source: rawNodeString(nodeToCheck),\n        index: -1,\n        lineCheckStr: blockString(parentRule),\n        err: m => {\n          report({\n            message: m,\n            node: decl,\n            index: decl.toString().length + 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-semicolon-newline-before/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-block-semicolon-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected newline before \\\";\\\"\",\n  expectedBeforeMultiLine: () => \"Expected newline before \\\";\\\" in a multi-line declaration block\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\";\\\" in a multi-line declaration block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(function (decl) {\n      const parentRule = decl.parent\n      if (\n        !parentRule.raws.semicolon\n        && parentRule.last === decl\n      ) {\n        return\n      }\n\n      const declString = decl.toString()\n\n      checker.beforeAllowingIndentation({\n        source: declString,\n        index: declString.length,\n        lineCheckStr: blockString(parentRule),\n        err: m => {\n          report({\n            message: m,\n            node: decl,\n            index: decl.toString().length - 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-semicolon-space-after/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst rawNodeString = require(\"../../utils/rawNodeString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-block-semicolon-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\";\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\";\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\";\\\" in a single-line declaration block\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\";\\\" in a single-line declaration block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(function (decl) {\n      // Ignore last declaration if there's no trailing semicolon\n      const parentRule = decl.parent\n      if (!parentRule.raws.semicolon && parentRule.last === decl) {\n        return\n      }\n\n      const nextDecl = decl.next()\n      if (!nextDecl) {\n        return\n      }\n\n      checker.after({\n        source: rawNodeString(nextDecl),\n        index: -1,\n        lineCheckStr: blockString(parentRule),\n        err: m => {\n          report({\n            message: m,\n            node: decl,\n            index: decl.toString().length + 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-semicolon-space-before/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-block-semicolon-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\";\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\";\\\"\",\n  expectedBeforeSingleLine: () => \"Expected single space before \\\";\\\" in a single-line declaration block\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\";\\\" in a single-line declaration block\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      // Ignore last declaration if there's no trailing semicolon\n      const parentRule = decl.parent\n      if (!parentRule.raws.semicolon && parentRule.last === decl) {\n        return\n      }\n\n      const declString = decl.toString()\n\n      checker.before({\n        source: declString,\n        index: declString.length,\n        lineCheckStr: blockString(parentRule),\n        err: m => {\n          report({\n            message: m,\n            node: decl,\n            index: decl.toString().length - 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-single-line-max-declarations/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blockString = require(\"../../utils/blockString\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"declaration-block-single-line-max-declarations\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: quantity => `Expected no more than ${quantity} declaration(s)`,\n})\n\nconst rule = function (quantity) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: quantity,\n      possible: [_.isNumber],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isSingleLineString(blockString(rule))) {\n        return\n      }\n      if (!rule.nodes) {\n        return\n      }\n\n      const decls = rule.nodes.filter(node => node.type === \"decl\")\n\n      if (decls.length <= quantity) {\n        return\n      }\n\n      report({\n        message: messages.expected(quantity),\n        node: rule,\n        index: beforeBlockString(rule, { noRawBefore: true }).length,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-block-trailing-semicolon/index.js":"\"use strict\"\n\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-block-trailing-semicolon\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected a trailing semicolon\",\n  rejected: \"Unexpected trailing semicolon\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      if (atRule.parent === root) {\n        return\n      }\n      if (atRule !== atRule.parent.last) {\n        return\n      }\n      if (hasBlock(atRule)) {\n        return\n      }\n      checkLastNode(atRule)\n    })\n\n    root.walkDecls(decl => {\n      if (decl !== decl.parent.last) {\n        return\n      }\n      checkLastNode(decl)\n    })\n\n    function checkLastNode(node) {\n      let message\n\n      if (expectation === \"always\") {\n        if (node.parent.raws.semicolon) {\n          return\n        }\n        message = messages.expected\n      }\n      if (expectation === \"never\") {\n        if (!node.parent.raws.semicolon) {\n          return\n        }\n        message = messages.rejected\n      }\n\n      report({\n        message,\n        node,\n        index: node.toString().trim().length - 1,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-colon-newline-after/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isStandardSyntaxDeclaration = require(\"../../utils/isStandardSyntaxDeclaration\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\n\nconst ruleName = \"declaration-colon-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\":\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\":\\\" with a multi-line declaration\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return\n      }\n\n      // Get the raw prop, and only the prop\n      const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || \"\").length - 1\n\n      // The extra characters tacked onto the end ensure that there is a character to check\n      // after the colon. Otherwise, with `background:pink` the character after the\n      const propPlusColon = decl.toString().slice(0, endOfPropIndex) + \"xxx\"\n\n      for (let i = 0, l = propPlusColon.length; i < l; i++) {\n        if (propPlusColon[i] !== \":\") {\n          continue\n        }\n        const indexToCheck = propPlusColon.substr(propPlusColon[i], 3) === \"/*\" ? propPlusColon.indexOf(\"*/\", i) + 1 : i\n\n        checker.afterOneOnly({\n          source: propPlusColon,\n          index: indexToCheck,\n          lineCheckStr: decl.value,\n          err: m => {\n            report({\n              message: m,\n              node: decl,\n              index: indexToCheck,\n              result,\n              ruleName,\n            })\n          },\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-colon-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst declarationColonSpaceChecker = require(\"../declarationColonSpaceChecker\")\n\nconst ruleName = \"declaration-colon-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\":\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\":\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\":\\\" with a single-line declaration\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    declarationColonSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declarationColonSpaceChecker.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../utils/declarationValueIndex\")\nconst isStandardSyntaxDeclaration = require(\"../utils/isStandardSyntaxDeclaration\")\nconst report = require(\"../utils/report\")\n\nmodule.exports = function (opts) {\n  opts.root.walkDecls(decl => {\n    if (!isStandardSyntaxDeclaration(decl)) {\n      return\n    }\n\n    // Get the raw prop, and only the prop\n    const endOfPropIndex = declarationValueIndex(decl) + (decl.raws.between || \"\").length - 1\n\n    // The extra characters tacked onto the end ensure that there is a character to check\n    // after the colon. Otherwise, with `background:pink` the character after the\n    const propPlusColon = decl.toString().slice(0, endOfPropIndex) + \"xxx\"\n\n    for (let i = 0, l = propPlusColon.length; i < l; i++) {\n      if (propPlusColon[i] !== \":\") {\n        continue\n      }\n      opts.locationChecker({\n        source: propPlusColon,\n        index: i,\n        lineCheckStr: decl.value,\n        err: m => {\n          report({\n            message: m,\n            node: decl,\n            index: decl.prop.toString().length + 1,\n            result: opts.result,\n            ruleName: opts.checkedRuleName,\n          })\n        },\n      })\n      break\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-colon-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst declarationColonSpaceChecker = require(\"../declarationColonSpaceChecker\")\n\nconst ruleName = \"declaration-colon-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\":\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\":\\\"\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    declarationColonSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-empty-line-before/index.js":"\"use strict\"\n\nconst blockString = require(\"../../utils/blockString\")\nconst hasEmptyLine = require(\"../../utils/hasEmptyLine\")\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst isStandardSyntaxDeclaration = require(\"../../utils/isStandardSyntaxDeclaration\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before declaration\",\n  rejected: \"Unexpected empty line before declaration\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        except: [\n          \"first-nested\",\n          \"after-comment\",\n          \"after-declaration\",\n        ],\n        ignore: [\n          \"after-comment\",\n          \"after-declaration\",\n          \"inside-single-line-block\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        parent = decl.parent\n\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return\n      }\n      if (isCustomProperty(prop)) {\n        return\n      }\n\n      // Optionally ignore the node if a comment precedes it\n      if (\n        optionsMatches(options, \"ignore\", \"after-comment\")\n        && decl.prev()\n        && decl.prev().type === \"comment\"\n      ) {\n        return\n      }\n\n      // Optionally ignore the node if a declaration precedes it\n      if (\n        optionsMatches(options, \"ignore\", \"after-declaration\")\n        && decl.prev()\n        && decl.prev().type === \"decl\"\n      ) {\n        return\n      }\n\n      // Optionally ignore nodes inside single-line blocks\n      if (\n        optionsMatches(options, \"ignore\", \"inside-single-line-block\")\n        && isSingleLineString(blockString(parent))\n      ) {\n        return\n      }\n\n      let expectEmptyLineBefore = expectation === \"always\"\n        ? true\n        : false\n\n      // Optionally reverse the expectation for the first nested node\n      if (\n        optionsMatches(options, \"except\", \"first-nested\")\n        && decl === parent.first\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation if a comment precedes this node\n      if (\n        optionsMatches(options, \"except\", \"after-comment\")\n        && decl.prev()\n        && decl.prev().type === \"comment\"\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation if a declaration precedes this node\n      if (\n        optionsMatches(options, \"except\", \"after-declaration\")\n        && decl.prev()\n        && decl.prev().prop\n        && isStandardSyntaxDeclaration(decl.prev())\n        && !isCustomProperty(decl.prev().prop)\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Check for at least one empty line\n      const hasEmptyLineBefore = hasEmptyLine(decl.raws.before)\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return\n      }\n\n      const message = expectEmptyLineBefore\n        ? messages.expected\n        : messages.rejected\n      report({ message, node: decl, result, ruleName })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-no-important/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"declaration-no-important\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected !important\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (!decl.important) {\n        return\n      }\n\n      report({\n        message: messages.rejected,\n        node: decl,\n        word: \"important\",\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-property-unit-blacklist/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"declaration-property-unit-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (property, unit) => `Unexpected unit \"${unit}\" for property \"${property}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isObject],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        value = decl.value\n\n      const unprefixedProp = postcss.vendor.unprefixed(prop)\n\n      const propBlacklist = _.find(blacklist, (list, propIdentifier) => matchesStringOrRegExp(unprefixedProp, propIdentifier))\n\n      if (!propBlacklist) {\n        return\n      }\n\n      valueParser(value).walk(function (node) {\n        // Ignore wrong units within `url` function\n        if (\n          node.type === \"function\"\n          && node.value.toLowerCase() === \"url\"\n        ) {\n          return false\n        }\n        if (node.type === \"string\") {\n          return\n        }\n\n        const unit = getUnitFromValueNode(node)\n\n        if (\n          !unit\n          || unit\n          && propBlacklist.indexOf(unit.toLowerCase()) === -1\n        ) {\n          return\n        }\n\n        report({\n          message: messages.rejected(prop, unit),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/getUnitFromValueNode.js":"/* @flow */\n\"use strict\"\n\nconst blurInterpolation = require(\"./blurInterpolation\")\nconst _ = require(\"lodash\")\nconst isStandardSyntaxValue = require(\"./isStandardSyntaxValue\")\nconst valueParser = require(\"postcss-value-parser\")\n\n/**\n * Get unit from value node\n *\n * Returns `null` if the unit is not found.\n */\nmodule.exports = function (node/*: Object*/)/*: ?string*/ {\n  if (!node || node && !node.value) {\n    return null\n  }\n\n  const value = blurInterpolation(node.value, \"\")\n  // ignore hack unit\n  .replace(\"\\\\0\", \"\").replace(\"\\\\9\", \"\")\n  // ignore decimal place\n  .replace(\".\", \"\")\n\n  if (node.type !== \"word\" || !isStandardSyntaxValue(value) || !_.isFinite(parseInt(value)) || node.value[0] === \"#\") {\n    return null\n  }\n\n  const parsedUnit = valueParser.unit(value)\n\n  if (!parsedUnit) {\n    return null\n  }\n\n  return parsedUnit.unit\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/blurInterpolation.js":"/* @flow */\n\"use strict\"\nmodule.exports = function (source/*: string*/)/*: string*/ {\n  const blurChar/*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \" \"\n\n  return source.replace(/[#@{}]+/g, blurChar)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-property-unit-whitelist/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"declaration-property-unit-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (property, unit) => `Unexpected unit \"${unit}\" for property \"${property}\"`,\n})\n\nconst rule = function (whitelist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isObject],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        value = decl.value\n\n      const unprefixedProp = postcss.vendor.unprefixed(prop)\n\n      const propWhitelist = _.find(whitelist, (list, propIdentifier) => matchesStringOrRegExp(unprefixedProp, propIdentifier))\n\n      if (!propWhitelist) {\n        return\n      }\n\n      valueParser(value).walk(function (node) {\n        // Ignore wrong units within `url` function\n        if (node.type === \"function\" && node.value.toLowerCase() === \"url\") {\n          return false\n        }\n        if (node.type === \"string\") {\n          return\n        }\n\n        const unit = getUnitFromValueNode(node)\n\n        if (!unit || (unit && propWhitelist.indexOf(unit.toLowerCase())) !== -1) {\n          return\n        }\n\n        report({\n          message: messages.rejected(prop, unit),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-property-value-blacklist/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"declaration-property-value-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (property, value) => `Unexpected value \"${value}\" for property \"${property}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isObject],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        value = decl.value\n\n      const unprefixedProp = postcss.vendor.unprefixed(prop)\n      const propBlacklist = _.find(blacklist, (list, propIdentifier) => matchesStringOrRegExp(unprefixedProp, propIdentifier))\n\n      if (_.isEmpty(propBlacklist)) {\n        return\n      }\n\n      if (!matchesStringOrRegExp(value, propBlacklist)) {\n        return\n      }\n\n      report({\n        message: messages.rejected(prop, value),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/declaration-property-value-whitelist/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"declaration-property-value-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (property, value) => `Unexpected value \"${value}\" for property \"${property}\"`,\n})\n\nconst rule = function (whitelist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isObject],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        value = decl.value\n\n      const unprefixedProp = postcss.vendor.unprefixed(prop)\n      const propWhitelist = _.find(whitelist, (list, propIdentifier) => matchesStringOrRegExp(unprefixedProp, propIdentifier))\n\n      if (_.isEmpty(propWhitelist)) {\n        return\n      }\n\n      if (matchesStringOrRegExp(value, propWhitelist)) {\n        return\n      }\n\n      report({\n        message: messages.rejected(prop, value),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/font-family-name-quotes/index.js":"\"use strict\"\n\nconst findFontFamily = require(\"../../utils/findFontFamily\")\nconst isStandardSyntaxValue = require(\"../../utils/isStandardSyntaxValue\")\nconst isVariable = require(\"../../utils/isVariable\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\n\nconst ruleName = \"font-family-name-quotes\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: family => `Expected quotes around \"${family}\"`,\n  rejected: family => `Unexpected quotes around \"${family}\"`,\n})\n\nfunction isSystemFontKeyword(font) {\n  if (font.indexOf(\"-apple-\") === 0) {\n    return true\n  }\n  if (font === \"BlinkMacSystemFont\") {\n    return true\n  }\n  return false\n}\n\n// \"To avoid mistakes in escaping, it is recommended to quote font family names\n// that contain white space, digits, or punctuation characters other than hyphens\"\n// (https://www.w3.org/TR/CSS2/fonts.html#font-family-prop)\nfunction quotesRecommended(family) {\n  return !/^[-a-zA-Z]+$/.test(family)\n}\n\n// Quotes are required if the family is not a valid CSS identifier\n// (regexes from https://mathiasbynens.be/notes/unquoted-font-family)\nfunction quotesRequired(family) {\n  return family.split(/\\s+/).some(word => {\n    return (/^(-?\\d|--)/.test(word) || !/^[-_a-zA-Z0-9\\u00A0-\\u10FFFF]+$/.test(word)\n    )\n  })\n}\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always-where-required\",\n        \"always-where-recommended\",\n        \"always-unless-keyword\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(/^font(-family)?$/i, decl => {\n      const fontFamilies = findFontFamily(decl.value)\n\n      if (fontFamilies.length === 0) {\n        return\n      }\n\n      fontFamilies.forEach(fontFamilyNode => {\n        let rawFamily = fontFamilyNode.value\n\n        if (fontFamilyNode.quote) {\n          rawFamily = fontFamilyNode.quote + rawFamily + fontFamilyNode.quote\n        }\n\n        checkFamilyName(rawFamily, decl)\n      })\n    })\n\n    function checkFamilyName(rawFamily, decl) {\n      if (!isStandardSyntaxValue(rawFamily)) {\n        return\n      }\n      if (isVariable(rawFamily)) {\n        return\n      }\n\n      const hasQuotes = rawFamily[0] === \"'\" || rawFamily[0] === \"\\\"\"\n\n      // Clean the family of its quotes\n      const family = rawFamily.replace(/^['\"]|['\"]$/g, \"\")\n\n      // Disallow quotes around (case-insensitive) keywords\n      // and system font keywords in all cases\n      if (keywordSets.fontFamilyKeywords.has(family.toLowerCase()) || isSystemFontKeyword(family)) {\n        if (hasQuotes) {\n          return complain(messages.rejected(family), family, decl)\n        }\n        return\n      }\n\n      const required = quotesRequired(family)\n      const recommended = quotesRecommended(family)\n\n      switch (expectation) {\n        case \"always-unless-keyword\":\n          if (!hasQuotes) {\n            return complain(messages.expected(family), family, decl)\n          }\n          return\n\n        case \"always-where-recommended\":\n          if (!recommended && hasQuotes) {\n            return complain(messages.rejected(family), family, decl)\n          }\n          if (recommended && !hasQuotes) {\n            return complain(messages.expected(family), family, decl)\n          }\n          return\n\n        case \"always-where-required\":\n          if (!required && hasQuotes) {\n            return complain(messages.rejected(family), family, decl)\n          }\n          if (required && !hasQuotes) {\n            return complain(messages.expected(family), family, decl)\n          }\n          return\n      }\n    }\n\n    function complain(message, family, decl) {\n      report({\n        result,\n        ruleName,\n        message,\n        node: decl,\n        word: family,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/findFontFamily.js":"/* @flow */\n\"use strict\"\n\nconst keywordSets = require(\"../reference/keywordSets\")\nconst isNumbery = require(\"./isNumbery\")\nconst isStandardSyntaxValue = require(\"./isStandardSyntaxValue\")\nconst isValidFontSize = require(\"./isValidFontSize\")\nconst isVariable = require(\"./isVariable\")\nconst postcssValueParser = require(\"postcss-value-parser\")\n\nconst nodeTypesToCheck = new Set([ \"word\", \"string\", \"space\", \"div\" ])\n\nfunction joinValueNodes(firstNode, secondNode, charactersBetween) {\n  firstNode.value = firstNode.value + charactersBetween + secondNode.value\n\n  return firstNode\n}\n\n/**\n * Get the font-families within a `font` shorthand property value.\n *\n * @param {string} value\n * @return {object} Collection font-family nodes\n */\nmodule.exports = function findFontFamily(value/*: string*/)/*: Array<Object>*/ {\n  const fontFamilies = []\n\n  const valueNodes = postcssValueParser(value)\n\n  // Handle `inherit`, `initial` and etc\n  if (valueNodes.nodes.length === 1 && keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase())) {\n    return [valueNodes.nodes[0]]\n  }\n\n  let needMergeNodesByValue = false\n  let mergeCharacters = null\n\n  valueNodes.walk((valueNode, index, nodes) => {\n    if (valueNode.type === \"function\") {\n      return false\n    }\n    if (!nodeTypesToCheck.has(valueNode.type)) {\n      return\n    }\n\n    const valueLowerCase = valueNode.value.toLowerCase()\n\n    // Ignore non standard syntax\n    if (!isStandardSyntaxValue(valueLowerCase)) {\n      return\n    }\n\n    // Ignore variables\n    if (isVariable(valueLowerCase)) {\n      return\n    }\n\n    // Ignore keywords for other font parts\n    if (keywordSets.fontShorthandKeywords.has(valueLowerCase) && !keywordSets.fontFamilyKeywords.has(valueLowerCase)) {\n      return\n    }\n\n    // Ignore font-sizes\n    if (isValidFontSize(valueNode.value)) {\n      return\n    }\n\n    // Ignore anything come after a <font-size>/, because it's a line-height\n    if (nodes[index - 1] && nodes[index - 1].value === \"/\" && nodes[index - 2] && isValidFontSize(nodes[index - 2].value)) {\n      return\n    }\n\n    // Ignore number values\n    if (isNumbery(valueLowerCase)) {\n      return\n    }\n\n    // Detect when a space or comma is dividing a list of font-families, and save the joining character.\n    if ((valueNode.type === \"space\" || valueNode.type === \"div\" && valueNode.value !== \",\") && fontFamilies.length !== 0) {\n      needMergeNodesByValue = true\n      mergeCharacters = valueNode.value\n      return\n    } else if (valueNode.type === \"space\" || valueNode.type === \"div\") {\n      return\n    }\n\n    const fontFamily = valueNode\n\n    if (needMergeNodesByValue) {\n      joinValueNodes(fontFamilies[fontFamilies.length - 1], valueNode, mergeCharacters)\n      needMergeNodesByValue = false\n      mergeCharacters = null\n    } else {\n      fontFamilies.push(fontFamily)\n    }\n  })\n\n  return fontFamilies\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isNumbery.js":"// Too weird for Flow\n\"use strict\"\n\n/**\n * Check whether it's a number or a number-like string:\n * i.e. when coerced to a number it == itself.\n */\nmodule.exports = function (value) {\n  return value.trim().length !== 0 && Number(value) == value\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isValidFontSize.js":"/* @flow */\n\"use strict\"\n\nconst keywordSets = require(\"../reference/keywordSets\")\nconst valueParser = require(\"postcss-value-parser\")\n\n/**\n * Check if a word is a font-size value.\n */\nmodule.exports = function (word/*: string*/)/*: boolean*/ {\n  if (!word) {\n    return false\n  }\n\n  if (keywordSets.fontSizeKeywords.has(word)) {\n    return true\n  }\n\n  const numberUnit = valueParser.unit(word)\n  if (!numberUnit) {\n    return false\n  }\n\n  const unit = numberUnit.unit\n\n  if (unit === \"%\") {\n    return true\n  }\n  if (keywordSets.lengthUnits.has(unit.toLowerCase())) {\n    return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isVariable.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a word is a variable i.e var(--custom-property).\n */\nmodule.exports = function (word/*: string*/)/*: boolean*/ {\n  return word.toLowerCase().slice(0, 4) === \"var(\"\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/font-family-no-duplicate-names/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst findFontFamily = require(\"../../utils/findFontFamily\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst _ = require(\"lodash\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\n\nconst ruleName = \"font-family-no-duplicate-names\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected duplicate name ${name}`,\n})\n\nconst isFamilyNameKeyword = node => !node.quote && keywordSets.fontFamilyKeywords.has(node.value.toLowerCase())\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignoreFontFamilyNames: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(/^font(-family)?$/i, decl => {\n      const keywords = new Set()\n      const familyNames = new Set()\n\n      const fontFamilies = findFontFamily(decl.value)\n\n      if (fontFamilies.length === 0) {\n        return\n      }\n\n      fontFamilies.forEach(fontFamilyNode => {\n        const family = fontFamilyNode.value.trim()\n\n        if (optionsMatches(options, \"ignoreFontFamilyNames\", fontFamilyNode.value.trim())) {\n          return\n        }\n\n        if (isFamilyNameKeyword(fontFamilyNode)) {\n          if (keywords.has(family.toLowerCase())) {\n            complain(messages.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, decl)\n            return\n          }\n\n          keywords.add(family)\n          return\n        }\n\n        if (familyNames.has(family)) {\n          complain(messages.rejected(family), declarationValueIndex(decl) + fontFamilyNode.sourceIndex, decl)\n          return\n        }\n\n        familyNames.add(family)\n      })\n    })\n\n    function complain(message, index, decl) {\n      report({\n        result,\n        ruleName,\n        message,\n        node: decl,\n        index,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/font-weight-notation/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isNumbery = require(\"../../utils/isNumbery\")\nconst isStandardSyntaxValue = require(\"../../utils/isStandardSyntaxValue\")\nconst isVariable = require(\"../../utils/isVariable\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"font-weight-notation\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: type => `Expected ${type} font-weight notation`,\n  invalidNamed: name => `Unexpected invalid font-weight name \"${name}\"`,\n})\n\nconst INHERIT_KEYWORD = \"inherit\"\nconst INITIAL_KEYWORD = \"initial\"\nconst NORMAL_KEYWORD = \"normal\"\nconst WEIGHTS_WITH_KEYWORD_EQUIVALENTS = [\n  \"400\",\n  \"700\",\n]\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"numeric\",\n        \"named-where-possible\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\"relative\"],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (decl.prop.toLowerCase() === \"font-weight\") {\n        checkWeight(decl.value, decl)\n      }\n\n      if (decl.prop.toLowerCase() === \"font\") {\n        checkFont(decl)\n      }\n    })\n\n    function checkFont(decl) {\n      const valueList = postcss.list.space(decl.value)\n      // We do not need to more carefully distinguish font-weight\n      // numbers from unitless line-heights because line-heights in\n      // `font` values need to be part of a font-size/line-height pair\n      const hasNumericFontWeight = valueList.some(isNumbery)\n\n      for (const value of postcss.list.space(decl.value)) {\n        if (value.toLowerCase() === NORMAL_KEYWORD && !hasNumericFontWeight || isNumbery(value) || value.toLowerCase() !== NORMAL_KEYWORD && keywordSets.fontWeightKeywords.has(value.toLowerCase())) {\n          checkWeight(value, decl)\n          return\n        }\n      }\n    }\n\n    function checkWeight(weightValue, decl) {\n      if (!isStandardSyntaxValue(weightValue)) {\n        return\n      }\n      if (isVariable(weightValue)) {\n        return\n      }\n      if (weightValue.toLowerCase() === INHERIT_KEYWORD || weightValue.toLowerCase() === INITIAL_KEYWORD) {\n        return\n      }\n\n      if (optionsMatches(options, \"ignore\", \"relative\") && keywordSets.fontWeightRelativeKeywords.has(weightValue.toLowerCase())) {\n        return\n      }\n\n      const weightValueOffset = decl.value.indexOf(weightValue)\n\n      if (expectation === \"numeric\") {\n        if (!isNumbery(weightValue)) {\n          return complain(messages.expected(\"numeric\"))\n        }\n      }\n\n      if (expectation === \"named-where-possible\") {\n        if (isNumbery(weightValue)) {\n          if (_.includes(WEIGHTS_WITH_KEYWORD_EQUIVALENTS, weightValue)) {\n            complain(messages.expected(\"named\"))\n          }\n          return\n        }\n        if (!keywordSets.fontWeightKeywords.has(weightValue.toLowerCase()) && weightValue.toLowerCase() !== NORMAL_KEYWORD) {\n          return complain(messages.invalidNamed(weightValue))\n        }\n        return\n      }\n\n      function complain(message) {\n        report({\n          ruleName,\n          result,\n          message,\n          node: decl,\n          index: declarationValueIndex(decl) + weightValueOffset,\n        })\n      }\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-blacklist/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isStandardSyntaxFunction = require(\"../../utils/isStandardSyntaxFunction\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"function-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected function \"${name}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n    root.walkDecls(decl => {\n      const value = decl.value\n\n      valueParser(value).walk(function (node) {\n        if (node.type !== \"function\") {\n          return\n        }\n        if (!isStandardSyntaxFunction(node)) {\n          return\n        }\n        if (!matchesStringOrRegExp(postcss.vendor.unprefixed(node.value).toLowerCase(), blacklist)) {\n          return\n        }\n\n        report({\n          message: messages.rejected(node.value),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-calc-no-unspaced-operator/index.js":"\"use strict\"\n\nconst isWhitespace = require(\"../../utils/isWhitespace\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst balancedMatch = require(\"balanced-match\")\nconst styleSearch = require(\"style-search\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"function-calc-no-unspaced-operator\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: operator => `Expected single space before \"${operator}\" operator`,\n  expectedAfter: operator => `Expected single space after \"${operator}\" operator`,\n  expectedOperatorBeforeSign: operator => `Expected an operator before sign \"${operator}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    function complain(message, node, index) {\n      report({ message, node, index, result, ruleName })\n    }\n\n    root.walkDecls(decl => {\n      valueParser(decl.value).walk(node => {\n        if (node.type !== \"function\" || node.value.toLowerCase() !== \"calc\") {\n          return\n        }\n\n        const parensMatch = balancedMatch(\"(\", \")\", valueParser.stringify(node))\n        const rawExpression = parensMatch.body\n        const expressionIndex = decl.source.start.column + decl.prop.length + (decl.raws.between || \"\").length + node.sourceIndex\n        const expression = blurVariables(rawExpression)\n\n        checkSymbol(\"+\")\n        checkSymbol(\"-\")\n        checkSymbol(\"*\")\n        checkSymbol(\"/\")\n\n        function checkSymbol(symbol) {\n          const styleSearchOptions = {\n            source: expression,\n            target: symbol,\n            functionArguments: \"skip\",\n          }\n\n          styleSearch(styleSearchOptions, match => {\n            const index = match.startIndex\n\n            // Deal with signs.\n            // (@ and $ are considered \"digits\" here to allow for variable syntaxes\n            // that permit signs in front of variables, e.g. `-$number`)\n            // As is \".\" to deal with fractional numbers without a leading zero\n            if ((symbol === \"+\" || symbol === \"-\") && /[\\d@\\$.]/.test(expression[index + 1])) {\n              const expressionBeforeSign = expression.substr(0, index)\n\n              // Ignore signs that directly follow a opening bracket\n              if (expressionBeforeSign[expressionBeforeSign.length - 1] === \"(\") {\n                return\n              }\n\n              // Ignore signs at the beginning of the expression\n              if (/^\\s*$/.test(expressionBeforeSign)) {\n                return\n              }\n\n              // Otherwise, ensure that there is a real operator preceeding them\n              if (/[\\*/+-]\\s*$/.test(expressionBeforeSign)) {\n                return\n              }\n\n              // And if not, complain\n              complain(messages.expectedOperatorBeforeSign(symbol), decl, expressionIndex + index)\n              return\n            }\n\n            const beforeOk = expression[index - 1] === \" \" && !isWhitespace(expression[index - 2]) || newlineBefore(expression, index - 1)\n            if (!beforeOk) {\n              complain(messages.expectedBefore(symbol), decl, expressionIndex + index)\n            }\n\n            const afterOk = expression[index + 1] === \" \" && !isWhitespace(expression[index + 2]) || expression[index + 1] === \"\\n\" || expression.substr(index + 1, 2) === \"\\r\\n\"\n\n            if (!afterOk) {\n              complain(messages.expectedAfter(symbol), decl, expressionIndex + index)\n            }\n          })\n        }\n      })\n    })\n  }\n}\n\nfunction blurVariables(source) {\n  return source.replace(/[\\$@][^\\)\\s]+|#{.+?}/g, \"0\")\n}\n\nfunction newlineBefore(str, startIndex) {\n  let index = startIndex\n  while (index && isWhitespace(str[index])) {\n    if (str[index] === \"\\n\") return true\n    index--\n  }\n  return false\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-comma-newline-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst functionCommaSpaceChecker = require(\"../functionCommaSpaceChecker\")\n\nconst ruleName = \"function-comma-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\",\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\",\\\" in a multi-line function\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\",\\\" in a multi-line function\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    functionCommaSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.afterOneOnly,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/functionCommaSpaceChecker.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../utils/declarationValueIndex\")\nconst isStandardSyntaxFunction = require(\"../utils/isStandardSyntaxFunction\")\nconst report = require(\"../utils/report\")\nconst _ = require(\"lodash\")\nconst styleSearch = require(\"style-search\")\nconst valueParser = require(\"postcss-value-parser\")\n\nmodule.exports = function (opts) {\n  opts.root.walkDecls(decl => {\n    const declValue = _.get(decl, \"raws.value.raw\", decl.value)\n\n    valueParser(declValue).walk(valueNode => {\n      if (valueNode.type !== \"function\") {\n        return\n      }\n\n      if (!isStandardSyntaxFunction(valueNode)) {\n        return\n      }\n\n      // Ignore `url()` arguments, which may contain data URIs or other funky stuff\n      if (valueNode.value.toLowerCase() === \"url\") {\n        return\n      }\n\n      const functionArguments = (() => {\n        let result = valueParser.stringify(valueNode)\n        // Remove function name and opening paren\n        result = result.slice(valueNode.value.length + 1)\n        // Remove closing paren\n        result = result.slice(0, result.length - 1)\n        // 1. Remove comments including preceeding whitespace (when only succeeded by whitespace)\n        // 2. Remove all other comments, but leave adjacent whitespace intact\n        result = result.replace(/(\\ *\\/(\\*.*\\*\\/(?!\\S)|\\/.*)|(\\/(\\*.*\\*\\/|\\/.*)))/, \"\")\n        return result\n      })()\n\n      styleSearch({\n        source: functionArguments,\n        target: \",\",\n        functionArguments: \"skip\",\n      }, match => {\n        opts.locationChecker({\n          source: functionArguments,\n          index: match.startIndex,\n          err: message => {\n            const index = declarationValueIndex(decl) + valueNode.value.length + 1 + valueNode.sourceIndex + match.startIndex\n            report({\n              index,\n              message,\n              node: decl,\n              result: opts.result,\n              ruleName: opts.checkedRuleName,\n            })\n          },\n        })\n      })\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-comma-newline-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst functionCommaSpaceChecker = require(\"../functionCommaSpaceChecker\")\n\nconst ruleName = \"function-comma-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected newline before \\\",\\\"\",\n  expectedBeforeMultiLine: () => \"Expected newline before \\\",\\\" in a multi-line function\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\",\\\" in a multi-line function\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    functionCommaSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.beforeAllowingIndentation,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-comma-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst functionCommaSpaceChecker = require(\"../functionCommaSpaceChecker\")\n\nconst ruleName = \"function-comma-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\",\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\",\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\",\\\" in a single-line function\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\",\\\" in a single-line function\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    functionCommaSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-comma-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst functionCommaSpaceChecker = require(\"../functionCommaSpaceChecker\")\n\nconst ruleName = \"function-comma-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\",\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\",\\\"\",\n  expectedBeforeSingleLine: () => \"Expected single space before \\\",\\\" in a single-line function\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\",\\\" in a single-line function\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    functionCommaSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-linear-gradient-no-nonstandard-direction/index.js":"\"use strict\"\n\nconst functionArgumentsSearch = require(\"../../utils/functionArgumentsSearch\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"function-linear-gradient-no-nonstandard-direction\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected nonstandard direction\",\n})\n\nfunction isStandardDirection(source, withToPrefix) {\n  const regexp = withToPrefix ? /^to (top|left|bottom|right)(?: (top|left|bottom|right))?$/ : /^(top|left|bottom|right)(?: (top|left|bottom|right))?$/\n\n  const matches = source.match(regexp)\n  if (!matches) {\n    return false\n  }\n  if (matches.length === 2) {\n    return true\n  }\n  // Cannot repeat side-or-corner, e.g. \"to top top\"\n  if (matches.length === 3 && matches[1] !== matches[2]) {\n    return true\n  }\n  return false\n}\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      functionArgumentsSearch(decl.toString().toLowerCase(), \"linear-gradient\", (expression, expressionIndex) => {\n        const firstArg = expression.split(\",\")[0].trim()\n\n        // If the first character is a number, we can assume the user intends an angle\n        if (/[\\d\\.]/.test(firstArg[0])) {\n          if (/^[\\d\\.]+(?:deg|grad|rad|turn)$/.test(firstArg)) {\n            return\n          }\n          complain()\n          return\n        }\n\n        // The first argument may not be a direction: it may be an angle,\n        // or a color stop (in which case user gets default direction, \"to bottom\")\n        // cf. https://drafts.csswg.org/css-images-3/#linear-gradient-syntax\n        if (!/left|right|top|bottom/.test(firstArg)) {\n          return\n        }\n\n        const withToPrefix = !postcss.vendor.prefix(decl.value)\n        if (!isStandardDirection(firstArg, withToPrefix)) {\n          complain()\n          return\n        }\n\n        function complain() {\n          report({\n            message: messages.rejected,\n            node: decl,\n            index: expressionIndex,\n            result,\n            ruleName,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/functionArgumentsSearch.js":"/* @flow */\n\"use strict\"\n\nconst balancedMatch = require(\"balanced-match\")\nconst styleSearch = require(\"style-search\")\n\n/**\n * Search a CSS string for functions by name.\n * For every match, invoke the callback, passing the function's\n * \"argument(s) string\" (whatever is inside the parentheses)\n * as an argument.\n *\n * Callback will be called once for every matching function found,\n * with the function's \"argument(s) string\" and its starting index\n * as the arguments.\n */\nmodule.exports = function (\n  source/*: string*/,\n  functionName/*: string*/,\n  callback/*: Function*/\n) {\n  styleSearch({\n    source,\n    target: functionName,\n    functionNames: \"check\",\n  }, match => {\n    if (source[match.endIndex] !== \"(\") {\n      return\n    }\n    const parensMatch = balancedMatch(\"(\", \")\", source.substr(match.startIndex))\n    callback(parensMatch.body, match.endIndex + 1)\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-max-empty-lines/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"function-max-empty-lines\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty line(s)`,\n})\n\nconst rule = function (max) {\n  const maxAdjacentNewlines = max + 1\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (decl.value.indexOf(\"(\") === -1) {\n        return\n      }\n\n      const declString = decl.toString()\n      const repeatLFNewLines = _.repeat(\"\\n\", maxAdjacentNewlines)\n      const repeatCRLFNewLines = _.repeat(\"\\r\\n\", maxAdjacentNewlines)\n\n      styleSearch({\n        source: declString,\n        target: \"\\n\",\n        functionArguments: \"only\",\n      }, match => {\n        if (declString.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || declString.substr(match.startIndex + 1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {\n          // Put index at `\\r` if it's CRLF, otherwise leave it at `\\n`\n          let index = match.startIndex\n          if (declString[index - 1] === \"\\r\") {\n            index -= 1\n          }\n\n          report({\n            message: messages.expected(max),\n            node: decl,\n            index,\n            result,\n            ruleName,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-name-case/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isStandardSyntaxFunction = require(\"../../utils/isStandardSyntaxFunction\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"function-name-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst mapLowercaseFunctionNamesToCamelCase = new Map()\nkeywordSets.camelCaseFunctionNames.forEach(func => {\n  mapLowercaseFunctionNamesToCamelCase.set(func.toLowerCase(), func)\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignoreFunctions: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const value = decl.value\n\n      valueParser(value).walk(function (node) {\n        if (node.type !== \"function\" || !isStandardSyntaxFunction(node)) {\n          return\n        }\n\n        const functionName = node.value\n        const functionNameLowerCase = functionName.toLowerCase()\n\n        const ignoreFunctions = options && options.ignoreFunctions || []\n\n        if (ignoreFunctions.length > 0 && matchesStringOrRegExp(functionName, ignoreFunctions)) {\n          return\n        }\n\n        let expectedFunctionName = null\n\n        if (expectation === \"lower\" && mapLowercaseFunctionNamesToCamelCase.has(functionNameLowerCase)) {\n          expectedFunctionName = mapLowercaseFunctionNamesToCamelCase.get(functionNameLowerCase)\n        } else if (expectation === \"lower\") {\n          expectedFunctionName = functionNameLowerCase\n        } else {\n          expectedFunctionName = functionName.toUpperCase()\n        }\n\n        if (functionName === expectedFunctionName) {\n          return\n        }\n\n        report({\n          message: messages.expected(functionName, expectedFunctionName),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-parentheses-newline-inside/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst isStandardSyntaxFunction = require(\"../../utils/isStandardSyntaxFunction\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"function-parentheses-newline-inside\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: \"Expected newline after \\\"(\\\"\",\n  expectedClosing: \"Expected newline before \\\")\\\"\",\n  expectedOpeningMultiLine: \"Expected newline after \\\"(\\\" in a multi-line function\",\n  rejectedOpeningMultiLine: \"Unexpected whitespace after \\\"(\\\" in a multi-line function\",\n  expectedClosingMultiLine: \"Expected newline before \\\")\\\" in a multi-line function\",\n  rejectedClosingMultiLine: \"Unexpected whitespace before \\\")\\\" in a multi-line function\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (decl.value.indexOf(\"(\") === -1) {\n        return\n      }\n\n      valueParser(decl.value).walk(valueNode => {\n        if (valueNode.type !== \"function\") {\n          return\n        }\n\n        if (!isStandardSyntaxFunction(valueNode)) {\n          return\n        }\n\n        const functionString = valueParser.stringify(valueNode)\n        const isMultiLine = !isSingleLineString(functionString)\n        function containsNewline(str) {\n          return str.indexOf(\"\\n\") !== -1\n        }\n\n        // Check opening ...\n\n        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1\n\n        if (expectation === \"always\" && !containsNewline(valueNode.before)) {\n          complain(messages.expectedOpening, openingIndex)\n        }\n\n        if (isMultiLine && expectation === \"always-multi-line\" && !containsNewline(valueNode.before)) {\n          complain(messages.expectedOpeningMultiLine, openingIndex)\n        }\n\n        if (isMultiLine && expectation === \"never-multi-line\" && valueNode.before !== \"\") {\n          complain(messages.rejectedOpeningMultiLine, openingIndex)\n        }\n\n        // Check closing ...\n\n        const closingIndex = valueNode.sourceIndex + functionString.length - 2\n\n        if (expectation === \"always\" && !containsNewline(valueNode.after)) {\n          complain(messages.expectedClosing, closingIndex)\n        }\n\n        if (isMultiLine && expectation === \"always-multi-line\" && !containsNewline(valueNode.after)) {\n          complain(messages.expectedClosingMultiLine, closingIndex)\n        }\n\n        if (isMultiLine && expectation === \"never-multi-line\" && valueNode.after !== \"\") {\n          complain(messages.rejectedClosingMultiLine, closingIndex)\n        }\n      })\n\n      function complain(message, offset) {\n        report({\n          ruleName,\n          result,\n          message,\n          node: decl,\n          index: declarationValueIndex(decl) + offset,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-parentheses-space-inside/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst isStandardSyntaxFunction = require(\"../../utils/isStandardSyntaxFunction\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"function-parentheses-space-inside\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: \"Expected single space after \\\"(\\\"\",\n  rejectedOpening: \"Unexpected whitespace after \\\"(\\\"\",\n  expectedClosing: \"Expected single space before \\\")\\\"\",\n  rejectedClosing: \"Unexpected whitespace before \\\")\\\"\",\n  expectedOpeningSingleLine: \"Expected single space after \\\"(\\\" in a single-line function\",\n  rejectedOpeningSingleLine: \"Unexpected whitespace after \\\"(\\\" in a single-line function\",\n  expectedClosingSingleLine: \"Expected single space before \\\")\\\" in a single-line function\",\n  rejectedClosingSingleLine: \"Unexpected whitespace before \\\")\\\" in a single-line function\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (decl.value.indexOf(\"(\") === -1) {\n        return\n      }\n\n      valueParser(decl.value).walk(valueNode => {\n        if (valueNode.type !== \"function\") {\n          return\n        }\n\n        if (!isStandardSyntaxFunction(valueNode)) {\n          return\n        }\n\n        const functionString = valueParser.stringify(valueNode)\n        const isSingleLine = isSingleLineString(functionString)\n\n        // Check opening ...\n\n        const openingIndex = valueNode.sourceIndex + valueNode.value.length + 1\n\n        if (expectation === \"always\" && valueNode.before !== \" \") {\n          complain(messages.expectedOpening, openingIndex)\n        }\n\n        if (expectation === \"never\" && valueNode.before !== \"\") {\n          complain(messages.rejectedOpening, openingIndex)\n        }\n\n        if (isSingleLine && expectation === \"always-single-line\" && valueNode.before !== \" \") {\n          complain(messages.expectedOpeningSingleLine, openingIndex)\n        }\n\n        if (isSingleLine && expectation === \"never-single-line\" && valueNode.before !== \"\") {\n          complain(messages.rejectedOpeningSingleLine, openingIndex)\n        }\n\n        // Check closing ...\n\n        const closingIndex = valueNode.sourceIndex + functionString.length - 2\n\n        if (expectation === \"always\" && valueNode.after !== \" \") {\n          complain(messages.expectedClosing, closingIndex)\n        }\n\n        if (expectation === \"never\" && valueNode.after !== \"\") {\n          complain(messages.rejectedClosing, closingIndex)\n        }\n\n        if (isSingleLine && expectation === \"always-single-line\" && valueNode.after !== \" \") {\n          complain(messages.expectedClosingSingleLine, closingIndex)\n        }\n\n        if (isSingleLine && expectation === \"never-single-line\" && valueNode.after !== \"\") {\n          complain(messages.rejectedClosingSingleLine, closingIndex)\n        }\n      })\n\n      function complain(message, offset) {\n        report({\n          ruleName,\n          result,\n          message,\n          node: decl,\n          index: declarationValueIndex(decl) + offset,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-url-data-uris/index.js":"\"use strict\"\n\nconst isStandardSyntaxValue = require(\"../../utils/isStandardSyntaxValue\")\nconst isVariable = require(\"../../utils/isVariable\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"function-url-data-uris\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected a data URI\",\n  rejected: \"Unexpected data URI\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(function (decl) {\n      valueParser(decl.value).walk(valueNode => {\n        if (valueNode.type !== \"function\" || valueNode.value.toLowerCase() !== \"url\" || !valueNode.nodes.length > 0) {\n          return\n        }\n\n        const urlValueNode = valueNode.nodes[0]\n\n        if (!urlValueNode.value || !isStandardSyntaxValue(urlValueNode.value) || isVariable(urlValueNode.value)) {\n          return\n        }\n\n        const valueContainDataUris = urlValueNode.value.toLowerCase().indexOf(\"data:\") === 0\n        const needUrlDataUris = expectation === \"always\"\n\n        if (valueContainDataUris && needUrlDataUris || !valueContainDataUris && !needUrlDataUris) {\n          return\n        }\n\n        const message = needUrlDataUris ? messages.expected : messages.rejected\n\n        report({\n          message,\n          node: decl,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-url-no-scheme-relative/index.js":"\"use strict\"\n\nconst functionArgumentsSearch = require(\"../../utils/functionArgumentsSearch\")\nconst isStandardSyntaxUrl = require(\"../../utils/isStandardSyntaxUrl\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"function-url-no-scheme-relative\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected scheme-relative url\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(function (decl) {\n      functionArgumentsSearch(decl.toString().toLowerCase(), \"url\", (args, index) => {\n        const url = _.trim(args, \" '\\\"\")\n\n        if (!isStandardSyntaxUrl(url) || url.indexOf(\"//\") !== 0) {\n          return\n        }\n\n        report({\n          message: messages.rejected,\n          node: decl,\n          index,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxUrl.js":"/* @flow */\n\"use strict\"\n\nconst hasLessInterpolation = require(\"../utils/hasLessInterpolation\")\nconst hasPsvInterpolation = require(\"../utils/hasPsvInterpolation\")\nconst hasScssInterpolation = require(\"../utils/hasScssInterpolation\")\n\n/**\n * Check whether a URL is standard\n */\nmodule.exports = function (url/*: string*/)/*: boolean*/ {\n  if (url.length === 0) {\n    return true\n  }\n\n  // Sass interpolation works anywhere\n  if (hasScssInterpolation(url) || hasPsvInterpolation(url)) {\n    return false\n  }\n\n  // Inside `'` and `\"` work only LESS interpolation\n  if (url[0] === \"'\" && url[url.length - 1] === \"'\" || url[0] === \"\\\"\" && url[url.length - 1] === \"\\\"\") {\n    if (hasLessInterpolation(url)) {\n      return false\n    }\n\n    return true\n  }\n\n  // Less variable works only at the beginning\n  // Check is less variable, allow use '@url/some/path'\n  // https://github.com/less/less.js/blob/3.x/lib/less/parser/parser.js#L547\n  if (url[0] === \"@\" && /^@@?[\\w-]+$/.test(url)) {\n    return false\n  }\n\n  // In url without quotes scss variable can be everywhere\n  // But in this case it is allowed to use only specific characters\n  // Also forbidden \"/\" at the end of url\n  if (url.indexOf(\"$\") !== -1 && /^[\\$\\sA-Za-z0-9+-/*_'\"\\/]+$/.test(url) && url[url.length - 1] !== \"/\") {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-url-quotes/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst functionArgumentsSearch = require(\"../../utils/functionArgumentsSearch\")\nconst isStandardSyntaxUrl = require(\"../../utils/isStandardSyntaxUrl\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"function-url-quotes\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: () => \"Expected quotes\",\n  rejected: () => \"Unexpected quotes\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        except: [\"empty\"],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(checkStatement)\n    root.walkRules(checkStatement)\n\n    function checkStatement(statement) {\n      if (statement.type === \"atrule\") {\n        checkAtRuleParams(statement)\n      }\n\n      statement.walkDecls(function (decl) {\n        functionArgumentsSearch(decl.toString().toLowerCase(), \"url\", (args, index) => {\n          checkArgs(args, decl, index, \"url\")\n        })\n      })\n    }\n\n    function checkAtRuleParams(atRule) {\n      const atRuleParamsLowerCase = atRule.params.toLowerCase()\n      functionArgumentsSearch(atRuleParamsLowerCase, \"url\", (args, index) => {\n        checkArgs(args, atRule, index + atRuleParamIndex(atRule), \"url\")\n      })\n      functionArgumentsSearch(atRuleParamsLowerCase, \"url-prefix\", (args, index) => {\n        checkArgs(args, atRule, index + atRuleParamIndex(atRule), \"url-prefix\")\n      })\n      functionArgumentsSearch(atRuleParamsLowerCase, \"domain\", (args, index) => {\n        checkArgs(args, atRule, index + atRuleParamIndex(atRule), \"domain\")\n      })\n    }\n\n    function checkArgs(args, node, index, functionName) {\n      let shouldHasQuotes = expectation === \"always\"\n\n      const leftTrimmedArgs = args.trimLeft()\n      if (!isStandardSyntaxUrl(leftTrimmedArgs)) {\n        return\n      }\n      const complaintIndex = index + args.length - leftTrimmedArgs.length\n      const hasQuotes = leftTrimmedArgs[0] === \"'\" || leftTrimmedArgs[0] === \"\\\"\"\n\n      const trimmedArg = args.trim()\n      const isEmptyArgument = _.includes([\n        \"\",\n        \"''\",\n        \"\\\"\\\"\",\n      ], trimmedArg)\n      if (optionsMatches(options, \"except\", \"empty\") && isEmptyArgument) {\n        shouldHasQuotes = !shouldHasQuotes\n      }\n\n      if (shouldHasQuotes) {\n        if (hasQuotes) {\n          return\n        }\n        complain(messages.expected(functionName), node, complaintIndex)\n      } else {\n        if (!hasQuotes) {\n          return\n        }\n        complain(messages.rejected(functionName), node, complaintIndex)\n      }\n    }\n\n    function complain(message, node, index) {\n      report({\n        message,\n        node,\n        index,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-url-scheme-whitelist/index.js":"\"use strict\"\n\nconst containsString = require(\"../../utils/containsString\")\nconst functionArgumentsSearch = require(\"../../utils/functionArgumentsSearch\")\nconst isStandardSyntaxUrl = require(\"../../utils/isStandardSyntaxUrl\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst parse = require(\"url\").parse\n\nconst ruleName = \"function-url-scheme-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: scheme => `Unexpected url scheme \"${scheme}:\"`,\n})\n\nconst rule = function (whitelist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(function (decl) {\n      functionArgumentsSearch(decl.toString().toLowerCase(), \"url\", (args, index) => {\n        const unspacedUrlString = _.trim(args, \" \")\n        if (!isStandardSyntaxUrl(unspacedUrlString)) {\n          return\n        }\n        const urlString = _.trim(unspacedUrlString, \"'\\\"\")\n\n        const url = parse(urlString)\n        if (url.protocol === null) {\n          return\n        }\n\n        const scheme = url.protocol.toLowerCase().slice(0, -1) // strip trailing `:`\n\n        // The URL spec does not require a scheme to be followed by `//`, but checking\n        // for it allows this rule to differentiate <scheme>:<hostname> urls from\n        // <hostname>:<port> urls. `data:` scheme urls are an exception to this rule.\n        const slashIndex = url.protocol.length\n        const expectedSlashes = urlString.slice(slashIndex, slashIndex + 2)\n        const isSchemeLessUrl = expectedSlashes !== \"//\" && scheme !== \"data\"\n        if (isSchemeLessUrl) {\n          return\n        }\n\n        const whitelistLowerCase = typeof whitelist === \"string\" ? whitelist.toLowerCase() : whitelist.join(\"|\").toLowerCase().split(\"|\")\n\n        if (containsString(scheme, whitelistLowerCase)) {\n          return\n        }\n\n        report({\n          message: messages.rejected(scheme),\n          node: decl,\n          index,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-whitelist/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst isStandardSyntaxFunction = require(\"../../utils/isStandardSyntaxFunction\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"function-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected function \"${name}\"`,\n})\n\nconst rule = function (whitelistInput) {\n  const whitelist = [].concat(whitelistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n    root.walkDecls(decl => {\n      const value = decl.value\n\n      valueParser(value).walk(function (node) {\n        if (node.type !== \"function\") {\n          return\n        }\n        if (!isStandardSyntaxFunction(node)) {\n          return\n        }\n        if (matchesStringOrRegExp(postcss.vendor.unprefixed(node.value).toLowerCase(), whitelist)) {\n          return\n        }\n        report({\n          message: messages.rejected(node.value),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/function-whitespace-after/index.js":"\"use strict\"\n\nconst isWhitespace = require(\"../../utils/isWhitespace\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"function-whitespace-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected whitespace after \\\")\\\"\",\n  rejected: \"Unexpected whitespace after \\\")\\\"\",\n})\n\nconst ACCEPTABLE_AFTER_CLOSING_PAREN = new Set([\n  \")\",\n  \",\",\n  \"}\",\n  \":\",\n  undefined,\n])\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const declString = decl.toString()\n\n      styleSearch({\n        source: declString,\n        target: \")\",\n        functionArguments: \"only\",\n      }, match => {\n        checkClosingParen(declString, match.startIndex, decl)\n      })\n    })\n\n    function checkClosingParen(source, index, node) {\n      const nextChar = source[index + 1]\n      if (expectation === \"always\") {\n        // Allow for the next character to be a single empty space,\n        // another closing parenthesis, a comma, or the end of the value\n        if (nextChar === \" \") {\n          return\n        }\n        if (nextChar === \"\\n\") {\n          return\n        }\n        if (source.substr(index + 1, 2) === \"\\r\\n\") {\n          return\n        }\n        if (ACCEPTABLE_AFTER_CLOSING_PAREN.has(nextChar)) {\n          return\n        }\n        report({\n          message: messages.expected,\n          node,\n          index: index + 1,\n          result,\n          ruleName,\n        })\n      } else if (expectation === \"never\") {\n        if (isWhitespace(nextChar)) {\n          report({\n            message: messages.rejected,\n            node,\n            index: index + 1,\n            result,\n            ruleName,\n          })\n        }\n      }\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/indentation/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"indentation\"\nconst messages = ruleMessages(ruleName, {\n  expected: x => `Expected indentation of ${x}`,\n})\n\n/**\n * @param {number|\"tab\"} space - Number of whitespaces to expect, or else\n *   keyword \"tab\" for single `\\t`\n * @param {object} [options]\n */\nconst rule = function (space) {\n  const options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}\n\n  const isTab = space === \"tab\"\n  const indentChar = isTab ? \"\\t\" : _.repeat(\" \", space)\n  const warningWord = isTab ? \"tab\" : \"space\"\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: space,\n      possible: [\n        _.isNumber,\n        \"tab\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        except: [\n          \"block\",\n          \"value\",\n          \"param\",\n        ],\n        ignore: [\n          \"value\",\n          \"param\",\n          \"inside-parens\",\n        ],\n        indentInsideParens: [\n          \"twice\",\n          \"once-at-root-twice-in-block\",\n        ],\n        indentClosingBrace: [_.isBoolean],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Cycle through all nodes using walk.\n    root.walk(node => {\n      const nodeLevel = indentationLevel(node)\n      const expectedWhitespace = _.repeat(indentChar, nodeLevel)\n\n      let before = (node.raws.before || \"\")\n      const after = (node.raws.after || \"\")\n\n      // Only inspect the spaces before the node\n      // if this is the first node in root\n      // or there is a newline in the `before` string.\n      // (If there is no newline before a node,\n      // there is no \"indentation\" to check.)\n      const inspectBefore = root.first === node || before.indexOf(\"\\n\") !== -1\n\n      // Cut out any * hacks from `before`\n      before = before[before.length - 1] === \"*\" || before[before.length - 1] === \"_\" ? before.slice(0, before.length - 1) : before\n\n      // Inspect whitespace in the `before` string that is\n      // *after* the *last* newline character,\n      // because anything besides that is not indentation for this node:\n      // it is some other kind of separation, checked by some separate rule\n      if (inspectBefore && before.slice(before.lastIndexOf(\"\\n\") + 1) !== expectedWhitespace) {\n        report({\n          message: messages.expected(legibleExpectation(nodeLevel)),\n          node,\n          result,\n          ruleName,\n        })\n      }\n\n      // Only blocks have the `after` string to check.\n      // Only inspect `after` strings that start with a newline;\n      // otherwise there's no indentation involved.\n      // And check `indentClosingBrace` to see if it should be indented an extra level.\n      const closingBraceLevel = options.indentClosingBrace ? nodeLevel + 1 : nodeLevel\n      if (hasBlock(node) && after && after.indexOf(\"\\n\") !== -1 && after.slice(after.lastIndexOf(\"\\n\") + 1) !== _.repeat(indentChar, closingBraceLevel)) {\n        report({\n          message: messages.expected(legibleExpectation(closingBraceLevel)),\n          node,\n          index: node.toString().length - 1,\n          result,\n          ruleName,\n        })\n      }\n\n      // If this is a declaration, check the value\n      if (node.value) {\n        checkValue(node, nodeLevel)\n      }\n\n      // If this is a rule, check the selector\n      if (node.selector) {\n        checkSelector(node, nodeLevel)\n      }\n\n      // If this is an at rule, check the params\n      if (node.type === \"atrule\") {\n        checkAtRuleParams(node, nodeLevel)\n      }\n    })\n\n    function indentationLevel(node) {\n      const level = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0\n\n      if (node.parent.type === \"root\") {\n        return level\n      }\n\n      let calculatedLevel\n\n      // Indentation level equals the ancestor nodes\n      // separating this node from root; so recursively\n      // run this operation\n      calculatedLevel = indentationLevel(node.parent, level + 1)\n\n      // If options.except includes \"block\",\n      // blocks are taken down one from their calculated level\n      // (all blocks are the same level as their parents)\n      if (optionsMatches(options, \"except\", \"block\") && (node.type === \"rule\" || node.type === \"atrule\") && hasBlock(node)) {\n        calculatedLevel--\n      }\n\n      return calculatedLevel\n    }\n\n    function checkValue(decl, declLevel) {\n      if (decl.value.indexOf(\"\\n\") === -1) {\n        return\n      }\n      if (optionsMatches(options, \"ignore\", \"value\")) {\n        return\n      }\n\n      const declString = decl.toString()\n      const valueLevel = optionsMatches(options, \"except\", \"value\") ? declLevel : declLevel + 1\n\n      checkMultilineBit(declString, valueLevel, decl)\n    }\n\n    function checkSelector(rule, ruleLevel) {\n      const selector = rule.selector\n\n      // Less mixins have params, and they should be indented extra\n      if (rule.params) {\n        ruleLevel += 1\n      }\n\n      checkMultilineBit(selector, ruleLevel, rule)\n    }\n\n    function checkAtRuleParams(atRule, ruleLevel) {\n      if (optionsMatches(options, \"ignore\", \"param\")) {\n        return\n      }\n\n      // @nest rules should be treated like regular rules, not expected\n      // to have their params (selectors) indented\n      const paramLevel = optionsMatches(options, \"except\", \"param\") || atRule.name === \"nest\" ? ruleLevel : ruleLevel + 1\n      checkMultilineBit(beforeBlockString(atRule).trim(), paramLevel, atRule)\n    }\n\n    function checkMultilineBit(source, newlineIndentLevel, node) {\n      if (source.indexOf(\"\\n\") === -1) {\n        return\n      }\n      // `outsideParens` because function arguments and also non-standard parenthesized stuff like\n      // Sass maps are ignored to allow for arbitrary indentation\n      let parentheticalDepth = 0\n      styleSearch({\n        source,\n        target: \"\\n\",\n        outsideParens: optionsMatches(options, \"ignore\", \"inside-parens\"),\n      }, (match, matchCount) => {\n        const precedesClosingParenthesis = /^[ \\t]*\\)/.test(source.slice(match.startIndex + 1))\n\n        if (optionsMatches(options, \"ignore\", \"inside-parens\") && (precedesClosingParenthesis || match.insideParens)) {\n          return\n        }\n\n        let expectedIndentLevel = newlineIndentLevel\n        // Modififications for parenthetical content\n        if (!optionsMatches(options, \"ignore\", \"inside-parens\") && match.insideParens) {\n          // If the first match in is within parentheses, reduce the parenthesis penalty\n          if (matchCount === 1) parentheticalDepth -= 1\n          // Account for windows line endings\n          let newlineIndex = match.startIndex\n          if (source[match.startIndex - 1] === \"\\r\") {\n            newlineIndex--\n          }\n          const followsOpeningParenthesis = /\\([ \\t]*$/.test(source.slice(0, newlineIndex))\n          if (followsOpeningParenthesis) {\n            parentheticalDepth += 1\n          }\n          expectedIndentLevel += parentheticalDepth\n          if (precedesClosingParenthesis) {\n            parentheticalDepth -= 1\n          }\n\n          switch (options.indentInsideParens) {\n            case \"twice\":\n              if (!precedesClosingParenthesis || options.indentClosingBrace) {\n                expectedIndentLevel += 1\n              }\n              break\n            case \"once-at-root-twice-in-block\":\n              if (node.parent === root) {\n                if (precedesClosingParenthesis && !options.indentClosingBrace) {\n                  expectedIndentLevel -= 1\n                }\n                break\n              }\n              if (!precedesClosingParenthesis || options.indentClosingBrace) {\n                expectedIndentLevel += 1\n              }\n              break\n            default:\n              if (precedesClosingParenthesis && !options.indentClosingBrace) {\n                expectedIndentLevel -= 1\n              }\n          }\n        }\n\n        // Starting at the index after the newline, we want to\n        // check that the whitespace characters (excluding newlines) before the first\n        // non-whitespace character equal the expected indentation\n        const afterNewlineSpaceMatches = /^([ \\t]*)\\S/.exec(source.slice(match.startIndex + 1))\n        if (!afterNewlineSpaceMatches) {\n          return\n        }\n        const afterNewlineSpace = afterNewlineSpaceMatches[1]\n\n        if (afterNewlineSpace !== _.repeat(indentChar, expectedIndentLevel)) {\n          report({\n            message: messages.expected(legibleExpectation(expectedIndentLevel)),\n            node,\n            index: match.startIndex + afterNewlineSpace.length + 1,\n            result,\n            ruleName,\n          })\n        }\n      })\n    }\n  }\n\n  function legibleExpectation(level) {\n    const count = isTab ? level : level * space\n    const quantifiedWarningWord = count === 1 ? warningWord : warningWord + \"s\"\n    return `${count} ${quantifiedWarningWord}`\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/keyframe-declaration-no-important/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"keyframe-declaration-no-important\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected !important\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^(-(moz|webkit)-)?keyframes$/i, atRuleKeyframes => {\n      atRuleKeyframes.walkDecls(decl => {\n        if (!decl.important) {\n          return\n        }\n        report({\n          message: messages.rejected,\n          node: decl,\n          word: \"important\",\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/length-zero-no-unit/index.js":"\"use strict\"\n\nconst beforeBlockString = require(\"../../utils/beforeBlockString\")\nconst blurComments = require(\"../../utils/blurComments\")\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst styleSearch = require(\"style-search\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"length-zero-no-unit\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected unit\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      check(blurComments(decl.toString()), decl)\n    })\n\n    root.walkAtRules(atRule => {\n      const source = hasBlock(atRule) ? beforeBlockString(atRule, { noRawBefore: true }) : atRule.toString()\n      check(source, atRule)\n    })\n\n    function check(value, node) {\n      const ignorableIndexes = new Set()\n\n      styleSearch({ source: value, target: \"0\" }, match => {\n        const index = match.startIndex\n\n        // Given a 0 somewhere in the full property value (not in a string, thanks\n        // to styleSearch) we need to isolate the value that contains the zero.\n        // To do so, we'll find the last index before the 0 of a character that would\n        // divide one value in a list from another, and the next index of such a\n        // character; then we build a substring from those indexes, which we can\n        // assess.\n\n        // If a single value includes multiple 0's (e.g. 100.01px), we don't want\n        // each 0 to be treated as a separate value, possibly resulting in multiple\n        // warnings for the same value (e.g. 0.00px).\n        //\n        // This check prevents that from happening: we build and check against a\n        // Set containing all the indexes that are part of a value already validated.\n        if (ignorableIndexes.has(index)) {\n          return\n        }\n\n        const prevValueBreakIndex = _.findLastIndex(value.substr(0, index), char => {\n          return [\n            \" \",\n            \",\",\n            \")\",\n            \"(\",\n            \"#\",\n          ].indexOf(char) !== -1\n        })\n\n        // Ignore hex colors\n        if (value[prevValueBreakIndex] === \"#\") {\n          return\n        }\n\n        // If no prev break was found, this value starts at 0\n        const valueWithZeroStart = prevValueBreakIndex === -1 ? 0 : prevValueBreakIndex + 1\n\n        const nextValueBreakIndex = _.findIndex(value.substr(valueWithZeroStart), char => {\n          return [\n            \" \",\n            \",\",\n            \")\",\n          ].indexOf(char) !== -1\n        })\n\n        // If no next break was found, this value ends at the end of the string\n        const valueWithZeroEnd = nextValueBreakIndex === -1 ? value.length : nextValueBreakIndex + valueWithZeroStart\n\n        const valueWithZero = value.slice(valueWithZeroStart, valueWithZeroEnd)\n        const parsedValue = valueParser.unit(valueWithZero)\n\n        if (!parsedValue || parsedValue && !parsedValue.unit) {\n          return\n        }\n\n        // Add the indexes to ignorableIndexes so the same value will not\n        // be checked multiple times.\n        _.range(valueWithZeroStart, valueWithZeroEnd).forEach(i => ignorableIndexes.add(i))\n\n        // Only pay attention if the value parses to 0\n        // and units with lengths\n        if (parseFloat(valueWithZero, 10) !== 0 || !keywordSets.lengthUnits.has(parsedValue.unit.toLowerCase())) {\n          return\n        }\n\n        report({\n          message: messages.rejected,\n          node,\n          index: valueWithZeroEnd - parsedValue.unit.length,\n          result,\n          ruleName,\n        })\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/blurComments.js":"/* @flow */\n\"use strict\"\nmodule.exports = function (source/*: string*/)/*: string*/ {\n  const blurChar/*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"`\"\n\n  return source.replace(/\\/\\*.*\\*\\//g, blurChar)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/max-empty-lines/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"max-empty-lines\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty line(s)`,\n})\n\nconst rule = function (max, options) {\n  const maxAdjacentNewlines = max + 1\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber,\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"comments\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const rootString = root.toString()\n    const repeatLFNewLines = _.repeat(\"\\n\", maxAdjacentNewlines)\n    const repeatCRLFNewLines = _.repeat(\"\\r\\n\", maxAdjacentNewlines)\n    const ignoreComments = optionsMatches(options, \"ignore\", \"comments\")\n\n    styleSearch({ source: rootString, target: \"\\n\" }, match => {\n      checkMatch(rootString, match.endIndex, root)\n    })\n\n    // We must check comments separately in order to accommodate stupid\n    // `//`-comments from SCSS, which postcss-scss converts to `/* ... */`,\n    // which adds to extra characters at the end, which messes up our\n    // warning position\n    if (!ignoreComments) {\n      root.walkComments(comment => {\n        const source = (comment.raws.left || \"\") + comment.text + (comment.raws.right || \"\")\n        styleSearch({ source, target: \"\\n\" }, match => {\n          checkMatch(source, match.endIndex, comment, 2)\n        })\n      })\n    }\n\n    function checkMatch(source, matchEndIndex, node) {\n      const offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0\n\n      let violationIndex = false\n      if (source.substr(matchEndIndex, maxAdjacentNewlines) === repeatLFNewLines) {\n        violationIndex = matchEndIndex + maxAdjacentNewlines\n      } else if (source.substr(matchEndIndex, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {\n        violationIndex = matchEndIndex + maxAdjacentNewlines * 2\n      }\n\n      if (!violationIndex) {\n        return\n      }\n\n      report({\n        message: messages.expected(max),\n        node,\n        index: violationIndex + offset,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/max-line-length/index.js":"\"use strict\"\n\nconst execall = require(\"execall\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"max-line-length\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: l => `Expected line length to be no more than ${l} characters`,\n})\n\nconst rule = function (maxLength, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: maxLength,\n      possible: _.isNumber,\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"non-comments\",\n          \"comments\",\n        ],\n        ignorePattern: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const rootString = root.source.input.css\n\n    const ignoreNonComments = optionsMatches(options, \"ignore\", \"non-comments\")\n    const ignoreComments = optionsMatches(options, \"ignore\", \"comments\")\n\n    // Check first line\n    checkNewline({ endIndex: 0 })\n\n    // Check subsequent lines\n    styleSearch({ source: rootString, target: [\"\\n\"], comments: \"check\" }, checkNewline)\n\n    function complain(index) {\n      report({\n        index,\n        result,\n        ruleName,\n        message: messages.expected(maxLength),\n        node: root,\n      })\n    }\n\n    function checkNewline(match) {\n      let nextNewlineIndex = rootString.indexOf(\"\\n\", match.endIndex)\n      if (rootString[nextNewlineIndex - 1] === \"\\r\") {\n        nextNewlineIndex -= 1\n      }\n\n      // Accommodate last line\n      if (nextNewlineIndex === -1) {\n        nextNewlineIndex = rootString.length\n      }\n\n      const rawLineLength = nextNewlineIndex - match.endIndex\n      const lineText = rootString.slice(match.endIndex, nextNewlineIndex)\n\n      if (optionsMatches(options, \"ignorePattern\", lineText)) {\n        return\n      }\n\n      const urlArgumentsLength = execall(/url\\((.*)\\)/ig, lineText).reduce((result, match) => {\n        return result + _.get(match, \"sub[0].length\", 0)\n      }, 0)\n\n      const importUrlsLength = execall(/\\@import\\s+(['\"].*['\"])/ig, lineText).reduce((result, match) => {\n        return result + _.get(match, \"sub[0].length\", 0)\n      }, 0)\n\n      // If the line's length is less than or equal to the specified\n      // max, ignore it ... So anything below is liable to be complained about.\n      // **Note that the length of any url arguments or import urls\n      // are excluded from the calculation.**\n      if (rawLineLength - urlArgumentsLength - importUrlsLength <= maxLength) {\n        return\n      }\n\n      const complaintIndex = nextNewlineIndex - 1\n\n      if (ignoreComments) {\n        if (match.insideComment) {\n          return\n        }\n\n        // This trimming business is to notice when the line starts a\n        // comment but that comment is indented, e.g.\n        //       /* something here */\n        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2)\n        if (nextTwoChars === \"/*\" || nextTwoChars === \"//\") {\n          return\n        }\n      }\n\n      if (ignoreNonComments) {\n        if (match.insideComment) {\n          return complain(complaintIndex)\n        }\n\n        // This trimming business is to notice when the line starts a\n        // comment but that comment is indented, e.g.\n        //       /* something here */\n        const nextTwoChars = rootString.slice(match.endIndex).trim().slice(0, 2)\n        if (nextTwoChars !== \"/*\" && nextTwoChars !== \"//\") {\n          return\n        }\n        return complain(complaintIndex)\n      }\n\n      // If there are no spaces besides initial (indent) spaces, ignore it\n      const lineString = rootString.slice(match.endIndex, nextNewlineIndex)\n      if (lineString.replace(/^\\s+/, \"\").indexOf(\" \") === -1) {\n        return\n      }\n\n      return complain(complaintIndex)\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/max-nesting-depth/index.js":"\"use strict\"\n\nconst hasBlock = require(\"../../utils/hasBlock\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"max-nesting-depth\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: depth => `Expected nesting depth to be no more than ${depth}`,\n})\n\nconst rule = function (max, options) {\n  const ignoreAtRulesWithoutDeclarationBlocks = optionsMatches(options, \"ignore\", \"at-rules-without-declaration-blocks\") || optionsMatches(options, \"ignore\", \"blockless-at-rules\")\n  const isIgnoreAtRule = node => node.type === \"atrule\" && optionsMatches(options, \"ignoreAtRules\", node.name)\n\n  return (root, result) => {\n    validateOptions(result, ruleName, {\n      actual: max,\n      possible: [_.isNumber],\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignore: [\n          \"at-rules-without-declaration-blocks\",\n          \"blockless-at-rules\",\n        ],\n        ignoreAtRules: [_.isString],\n      },\n    })\n\n    if (optionsMatches(options, \"ignore\", \"at-rules-without-declaration-blocks\")) {\n      result.warn((\n        \"'max-nesting-depth\\'s' \\\"at-rules-without-declaration-blocks\\\" option has been deprecated and in 8.0 will be removed. Instead use the \\\"blockless-at-rules\\\" option.\"\n      ), {\n        stylelintType: \"deprecation\",\n        stylelintReference: \"https://stylelint.io/user-guide/rules/max-nesting-depth/\",\n      })\n    }\n\n    root.walkRules(checkStatement)\n    root.walkAtRules(checkStatement)\n\n    function checkStatement(statement) {\n      if (isIgnoreAtRule(statement)) {\n        return\n      }\n      if (!hasBlock(statement)) {\n        return\n      }\n      const depth = nestingDepth(statement)\n      if (depth > max) {\n        report({\n          ruleName,\n          result,\n          node: statement,\n          message: messages.expected(max),\n        })\n      }\n    }\n  }\n\n  function nestingDepth(node, level) {\n    level = level || 0\n    const parent = node.parent\n\n    if (isIgnoreAtRule(parent)) {\n      return 0\n    }\n\n    // The nesting depth level's computation has finished\n    // when this function, recursively called, receives\n    // a node that is not nested -- a direct child of the\n    // root node\n    if (parent.type === \"root\" || parent.type === \"atrule\" && parent.parent.type === \"root\") {\n      return level\n    }\n\n    if (ignoreAtRulesWithoutDeclarationBlocks && node.type === \"atrule\" && node.every(child => child.type !== \"decl\")) {\n      return nestingDepth(parent, level)\n    }\n\n    // Unless any of the conditions above apply, we want to\n    // add 1 to the nesting depth level and then check the parent,\n    // continuing to add and move up the hierarchy\n    // until we hit the root node\n    return nestingDepth(parent, level + 1)\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-colon-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst mediaFeatureColonSpaceChecker = require(\"../mediaFeatureColonSpaceChecker\")\n\nconst ruleName = \"media-feature-colon-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\":\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\":\\\"\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    mediaFeatureColonSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/mediaFeatureColonSpaceChecker.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../utils/atRuleParamIndex\")\nconst report = require(\"../utils/report\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (opts) {\n  opts.root.walkAtRules(/^media$/i, atRule => {\n    const params = atRule.params\n\n    styleSearch({ source: params, target: \":\" }, match => {\n      checkColon(params, match.startIndex, atRule)\n    })\n  })\n\n  function checkColon(source, index, node) {\n    opts.locationChecker({ source, index, err: m => report({\n      message: m,\n      node,\n      index: index + atRuleParamIndex(node),\n      result: opts.result,\n      ruleName: opts.checkedRuleName,\n    }),\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-colon-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst mediaFeatureColonSpaceChecker = require(\"../mediaFeatureColonSpaceChecker\")\n\nconst ruleName = \"media-feature-colon-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\":\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\":\\\"\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    mediaFeatureColonSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-name-blacklist/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst isCustomMediaQuery = require(\"../../utils/isCustomMediaQuery\")\nconst isRangeContextMediaFeature = require(\"../../utils/isRangeContextMediaFeature\")\nconst isStandardSyntaxMediaFeatureName = require(\"../../utils/isStandardSyntaxMediaFeatureName\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst mediaParser = require(\"postcss-media-query-parser\").default\n\nconst ruleName = \"media-feature-name-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected media feature name \"${name}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {\n        const parent = mediaFeatureNode.parent,\n          sourceIndex = mediaFeatureNode.sourceIndex,\n          value = mediaFeatureNode.value\n\n        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {\n          return\n        }\n\n        if (!matchesStringOrRegExp(value.toLowerCase(), blacklist)) {\n          return\n        }\n\n        report({\n          index: atRuleParamIndex(atRule) + sourceIndex,\n          message: messages.rejected(value),\n          node: atRule,\n          ruleName,\n          result,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isCustomMediaQuery.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a media query is a custom\n */\nmodule.exports = function (mediaQuery/*: string*/)/*: boolean*/ {\n  return mediaQuery.slice(0, 2) === \"--\"\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isRangeContextMediaFeature.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a media feature is a range context one\n *\n * @param {string} media feature\n * @return {boolean} If `true`, media feature is a range context one\n */\nmodule.exports = function (mediaFeature/*: string*/)/*: boolean*/ {\n  return mediaFeature.indexOf(\"=\") !== -1 || mediaFeature.indexOf(\"<\") !== -1 || mediaFeature.indexOf(\">\") !== -1\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxMediaFeatureName.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a media feature name is standard\n */\nmodule.exports = function (mediaFeatureName/*: string*/)/*: boolean*/ {\n  // SCSS interpolation\n  if (/#{.+?}|\\$.+?/.test(mediaFeatureName)) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-name-case/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst isCustomMediaQuery = require(\"../../utils/isCustomMediaQuery\")\nconst isRangeContextMediaFeature = require(\"../../utils/isRangeContextMediaFeature\")\nconst isStandardSyntaxMediaFeatureName = require(\"../../utils/isStandardSyntaxMediaFeatureName\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst mediaParser = require(\"postcss-media-query-parser\").default\n\nconst ruleName = \"media-feature-name-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {\n        const parent = mediaFeatureNode.parent,\n          sourceIndex = mediaFeatureNode.sourceIndex,\n          value = mediaFeatureNode.value\n\n        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {\n          return\n        }\n\n        const expectedFeatureName = expectation === \"lower\" ? value.toLowerCase() : value.toUpperCase()\n\n        if (value === expectedFeatureName) {\n          return\n        }\n\n        report({\n          index: atRuleParamIndex(atRule) + sourceIndex,\n          message: messages.expected(value, expectedFeatureName),\n          node: atRule,\n          ruleName,\n          result,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-name-no-unknown/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst isCustomMediaQuery = require(\"../../utils/isCustomMediaQuery\")\nconst isRangeContextMediaFeature = require(\"../../utils/isRangeContextMediaFeature\")\nconst isStandardSyntaxMediaFeatureName = require(\"../../utils/isStandardSyntaxMediaFeatureName\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst mediaParser = require(\"postcss-media-query-parser\").default\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"media-feature-name-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: mediaFeatureName => `Unexpected unknown media feature name \"${mediaFeatureName}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignoreMediaFeatureNames: [_.isString],\n      },\n      optional: true,\n    })\n\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {\n        const parent = mediaFeatureNode.parent,\n          sourceIndex = mediaFeatureNode.sourceIndex,\n          value = mediaFeatureNode.value\n\n        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {\n          return\n        }\n\n        if (optionsMatches(options, \"ignoreMediaFeatureNames\", value)) {\n          return\n        }\n\n        if (postcss.vendor.prefix(value) || keywordSets.mediaFeatureNames.has(value.toLowerCase())) {\n          return\n        }\n\n        report({\n          index: atRuleParamIndex(atRule) + sourceIndex,\n          message: messages.rejected(value),\n          node: atRule,\n          ruleName,\n          result,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-name-no-vendor-prefix/index.js":"\"use strict\"\n\nconst isAutoprefixable = require(\"../../utils/isAutoprefixable\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"media-feature-name-no-vendor-prefix\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected vendor-prefix\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      const params = atRule.params\n\n      if (!isAutoprefixable.mediaFeatureName(params)) {\n        return\n      }\n      const matches = atRule.toString().match(/[a-z-]+device-pixel-ratio/ig)\n\n      if (!matches) { return }\n\n      matches.forEach(match => {\n        report({\n          message: messages.rejected,\n          node: atRule,\n          word: match,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-name-whitelist/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst isCustomMediaQuery = require(\"../../utils/isCustomMediaQuery\")\nconst isRangeContextMediaFeature = require(\"../../utils/isRangeContextMediaFeature\")\nconst isStandardSyntaxMediaFeatureName = require(\"../../utils/isStandardSyntaxMediaFeatureName\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst mediaParser = require(\"postcss-media-query-parser\").default\n\nconst ruleName = \"media-feature-name-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: name => `Unexpected media feature name \"${name}\"`,\n})\n\nconst rule = function (whitelist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      mediaParser(atRule.params).walk(/^media-feature$/i, mediaFeatureNode => {\n        const parent = mediaFeatureNode.parent,\n          sourceIndex = mediaFeatureNode.sourceIndex,\n          value = mediaFeatureNode.value\n\n        if (isRangeContextMediaFeature(parent.value) || !isStandardSyntaxMediaFeatureName(value) || isCustomMediaQuery(value)) {\n          return\n        }\n\n        if (matchesStringOrRegExp(value.toLowerCase(), whitelist)) {\n          return\n        }\n\n        report({\n          index: atRuleParamIndex(atRule) + sourceIndex,\n          message: messages.rejected(value),\n          node: atRule,\n          ruleName,\n          result,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-no-missing-punctuation/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst isStandardSyntaxMediaFeature = require(\"../../utils/isStandardSyntaxMediaFeature\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst execall = require(\"execall\")\nconst punctuationSets = require(\"../../reference/punctuationSets\")\n\nconst ruleName = \"media-feature-no-missing-punctuation\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected missing punctuation\",\n})\n\nfunction isPunctuation(str) {\n  return punctuationSets.mediaFeaturePunctuation.has(str)\n}\n\nfunction endsWithPunctuation(str) {\n  return isPunctuation(str.slice(-1)) || isPunctuation(str.slice(-2))\n}\n\nfunction startsWithPunctuation(str) {\n  return isPunctuation(str[0]) || isPunctuation(str.slice(0, 2))\n}\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      \"'media-feature-no-missing-punctuation' has been deprecated and in 8.0 will be removed.\"\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: \"https://stylelint.io/user-guide/rules/media-feature-no-missing-punctuation/\",\n    })\n\n    root.walkAtRules(/^media$/i, atRule => {\n      execall(/\\((.*?)\\)/g, atRule.params).forEach(mediaFeatureMatch => {\n        if (!isStandardSyntaxMediaFeature(mediaFeatureMatch.match)) {\n          return\n        }\n\n        const splitMediaFeature = mediaFeatureMatch.sub[0].trim().split(/\\s+/)\n        if (splitMediaFeature.length === 1) {\n          return\n        }\n\n        // Ignore the last one\n        for (let i = 0, l = splitMediaFeature.length - 1; i < l; i++) {\n          const mediaFeaturePart = splitMediaFeature[i]\n\n          // This part is valid if it is punctuation,\n          // it ends with punctuation,\n          // the next part is punctuation,\n          // or the next part begins with punctuation\n          if (isPunctuation(mediaFeaturePart)) {\n            continue\n          }\n          if (endsWithPunctuation(mediaFeaturePart)) {\n            continue\n          }\n          const nextPart = splitMediaFeature[i + 1]\n          if (isPunctuation(nextPart)) {\n            continue\n          }\n          if (startsWithPunctuation(nextPart)) {\n            continue\n          }\n\n          return report({\n            result,\n            ruleName,\n            message: messages.rejected,\n            node: atRule,\n            index: atRuleParamIndex(atRule) + mediaFeatureMatch.index,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxMediaFeature.js":"/* @flow */\n\"use strict\"\n\nconst hasInterpolation = require(\"../utils/hasInterpolation\")\n/**\n * Check whether a media feature is standard\n */\nmodule.exports = function (mediaFeature/*: string*/)/*: boolean*/ {\n  // Remove outside parens\n  mediaFeature = mediaFeature.slice(1, -1)\n\n  // Parentheticals used for non-standard operations e.g. ($var - 10)\n  if (mediaFeature.indexOf(\"(\") !== -1) {\n    return false\n  }\n\n  // SCSS or Less interpolation\n  if (hasInterpolation(mediaFeature)) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/reference/punctuationSets.js":"\"use strict\"\n\nconst punctuationSets = {}\n\npunctuationSets.mediaFeaturePunctuation = new Set([\n  \":\",\n  \"=\",\n  \">\",\n  \">=\",\n  \"<\",\n  \"<=\",\n])\n\npunctuationSets.nonSpaceCombinators = new Set([\n  \">\",\n  \"+\",\n  \"~\",\n])\n\nmodule.exports = punctuationSets\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-parentheses-space-inside/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"media-feature-parentheses-space-inside\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: \"Expected single space after \\\"(\\\"\",\n  rejectedOpening: \"Unexpected whitespace after \\\"(\\\"\",\n  expectedClosing: \"Expected single space before \\\")\\\"\",\n  rejectedClosing: \"Unexpected whitespace before \\\")\\\"\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      // If there are comments in the params, the complete string\n      // will be at atRule.raws.params.raw\n      const params = _.get(atRule, \"raws.params.raw\", atRule.params)\n      const indexBoost = atRuleParamIndex(atRule)\n\n      styleSearch({ source: params, target: \"(\" }, match => {\n        const nextCharIsSpace = params[match.startIndex + 1] === \" \"\n        if (nextCharIsSpace && expectation === \"never\") {\n          report({\n            message: messages.rejectedOpening,\n            node: atRule,\n            index: match.startIndex + 1 + indexBoost,\n            result,\n            ruleName,\n          })\n        }\n        if (!nextCharIsSpace && expectation === \"always\") {\n          report({\n            message: messages.expectedOpening,\n            node: atRule,\n            index: match.startIndex + 1 + indexBoost,\n            result,\n            ruleName,\n          })\n        }\n      })\n\n      styleSearch({ source: params, target: \")\" }, match => {\n        const prevCharIsSpace = params[match.startIndex - 1] === \" \"\n        if (prevCharIsSpace && expectation === \"never\") {\n          report({\n            message: messages.rejectedClosing,\n            node: atRule,\n            index: match.startIndex - 1 + indexBoost,\n            result,\n            ruleName,\n          })\n        }\n        if (!prevCharIsSpace && expectation === \"always\") {\n          report({\n            message: messages.expectedClosing,\n            node: atRule,\n            index: match.startIndex - 1 + indexBoost,\n            result,\n            ruleName,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-range-operator-space-after/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst findMediaOperator = require(\"../findMediaOperator\")\n\nconst ruleName = \"media-feature-range-operator-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after range operator\",\n  rejectedAfter: () => \"Unexpected whitespace after range operator\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      findMediaOperator(atRule, checkAfterOperator)\n    })\n\n    function checkAfterOperator(match, params, node) {\n      const endIndex = match.index + match[1].length\n\n      checker.after({\n        source: params,\n        index: endIndex,\n        err: m => {\n          report({\n            message: m,\n            node,\n            index: endIndex + atRuleParamIndex(node) + 1,\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/findMediaOperator.js":"\"use strict\"\n\nconst rangeOperatorRegex = /[^><](>=?|<=?|=)/g\n\nmodule.exports = function (atRule, cb) {\n  if (atRule.name.toLowerCase() !== \"media\") {\n    return\n  }\n\n  const params = atRule.params\n  let match\n  while ((match = rangeOperatorRegex.exec(params)) !== null) {\n    cb(match, params, atRule)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-feature-range-operator-space-before/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst findMediaOperator = require(\"../findMediaOperator\")\n\nconst ruleName = \"media-feature-range-operator-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before range operator\",\n  rejectedBefore: () => \"Unexpected whitespace before range operator\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(/^media$/i, atRule => {\n      findMediaOperator(atRule, checkBeforeOperator)\n    })\n\n    function checkBeforeOperator(match, params, node) {\n      // The extra `+ 1` is because the match itself contains\n      // the character before the operator\n      checker.before({\n        source: params,\n        index: match.index + 1,\n        err: m => {\n          report({\n            message: m,\n            node,\n            index: match.index + atRuleParamIndex(node),\n            result,\n            ruleName,\n          })\n        },\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-query-list-comma-newline-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst mediaQueryListCommaWhitespaceChecker = require(\"../mediaQueryListCommaWhitespaceChecker\")\n\nconst ruleName = \"media-query-list-comma-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\",\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\",\\\" in a multi-line list\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\",\\\" in a multi-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Only check for the newline after the comma, while allowing\n    // arbitrary indentation after the newline\n    mediaQueryListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.afterOneOnly,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/mediaQueryListCommaWhitespaceChecker.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../utils/atRuleParamIndex\")\nconst report = require(\"../utils/report\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (opts) {\n  opts.root.walkAtRules(/^media$/i, atRule => {\n    const params = atRule.params\n    styleSearch({ source: params, target: \",\" }, match => {\n      checkComma(params, match.startIndex, atRule)\n    })\n  })\n\n  function checkComma(source, index, node) {\n    opts.locationChecker({ source, index, err: m => report({\n      message: m,\n      node,\n      index: index + atRuleParamIndex(node),\n      result: opts.result,\n      ruleName: opts.checkedRuleName,\n    }),\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-query-list-comma-newline-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst mediaQueryListCommaWhitespaceChecker = require(\"../mediaQueryListCommaWhitespaceChecker\")\n\nconst ruleName = \"media-query-list-comma-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected newline before \\\",\\\"\",\n  expectedBeforeMultiLine: () => \"Expected newline before \\\",\\\" in a multi-line list\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\",\\\" in a multi-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n    mediaQueryListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.beforeAllowingIndentation,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-query-list-comma-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst mediaQueryListCommaWhitespaceChecker = require(\"../mediaQueryListCommaWhitespaceChecker\")\n\nconst ruleName = \"media-query-list-comma-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\",\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\",\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\",\\\" in a single-line list\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\",\\\" in a single-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n    mediaQueryListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/media-query-list-comma-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst mediaQueryListCommaWhitespaceChecker = require(\"../mediaQueryListCommaWhitespaceChecker\")\n\nconst ruleName = \"media-query-list-comma-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\",\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\",\\\"\",\n  expectedBeforeSingleLine: () => \"Expected single space before \\\",\\\" in a single-line list\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\",\\\" in a single-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    mediaQueryListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-browser-hacks/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst Result = require(\"postcss/lib/result\")\nconst _ = require(\"lodash\")\nconst stylehacks = require(\"stylehacks\")\n\nconst ruleName = \"no-browser-hacks\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (type, hack) => `Unexpected ${type} hack \"${hack}\"`,\n})\n\nconst rule = function (on, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual: on }, {\n      optional: true,\n      actual: options,\n      possible: {\n        browsers: [_.isString],\n      },\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Use 'stylelint-no-browser-hacks' plugin instead.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    const stylehacksOptions = { lint: true }\n    if (options && options.browsers) {\n      stylehacksOptions.browsers = options.browsers\n    }\n\n    const stylehacksResult = new Result()\n    stylehacks(stylehacksOptions)(root, stylehacksResult)\n    stylehacksResult.warnings().forEach(stylehacksWarning => {\n      const message = messages.rejected(stylehacksWarning.identifier, stylehacksWarning.hack)\n      report({\n        ruleName,\n        result,\n        message,\n        node: stylehacksWarning.node,\n        line: stylehacksWarning.line,\n        column: stylehacksWarning.column,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-descending-specificity/index.js":"\"use strict\"\n\nconst specificity = require(\"specificity\")\nconst findAtRuleContext = require(\"../../utils/findAtRuleContext\")\nconst isCustomPropertySet = require(\"../../utils/isCustomPropertySet\")\nconst nodeContextLookup = require(\"../../utils/nodeContextLookup\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst resolvedNestedSelector = require(\"postcss-resolve-nested-selector\")\n\nconst ruleName = \"no-descending-specificity\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (b, a) => `Expected selector \"${b}\" to come before selector \"${a}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    const selectorContextLookup = nodeContextLookup()\n\n    root.walkRules(rule => {\n      // Ignore custom property set `--foo: {};`\n      if (isCustomPropertySet(rule)) {\n        return\n      }\n\n      const comparisonContext = selectorContextLookup.getContext(rule, findAtRuleContext(rule))\n\n      rule.selectors.forEach(selector => {\n        const trimSelector = selector.trim()\n        // Ignore `.selector, { }`\n        if (trimSelector === \"\") {\n          return\n        }\n\n        // The edge-case of duplicate selectors will act acceptably\n        const index = rule.selector.indexOf(trimSelector)\n        // Resolve any nested selectors before checking\n        resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {\n          parseSelector(resolvedSelector, result, rule, s => checkSelector(s, rule, index, comparisonContext))\n        })\n      })\n    })\n\n    function checkSelector(selectorNode, rule, sourceIndex, comparisonContext) {\n      const selector = selectorNode.toString()\n      const referenceSelectorNode = lastCompoundSelectorWithoutPseudoClasses(selectorNode)\n      const selectorSpecificity = specificity.calculate(selector)[0].specificityArray\n      const entry = { selector, specificity: selectorSpecificity }\n\n      if (!comparisonContext.has(referenceSelectorNode)) {\n        comparisonContext.set(referenceSelectorNode, [entry])\n        return\n      }\n\n      const priorComparableSelectors = comparisonContext.get(referenceSelectorNode)\n\n      priorComparableSelectors.forEach(priorEntry => {\n        if (specificity.compare(selectorSpecificity, priorEntry.specificity) === -1) {\n          report({\n            ruleName,\n            result,\n            node: rule,\n            message: messages.rejected(selector, priorEntry.selector),\n            index: sourceIndex,\n          })\n        }\n      })\n\n      priorComparableSelectors.push(entry)\n    }\n  }\n}\n\nfunction lastCompoundSelectorWithoutPseudoClasses(selectorNode) {\n  const nodesAfterLastCombinator = _.last(selectorNode.nodes[0].split(node => {\n    return node.type === \"combinator\"\n  }))\n\n  const nodesWithoutPseudoClasses = nodesAfterLastCombinator.filter(node => {\n    return node.type !== \"pseudo\" || keywordSets.pseudoElements.has(node.value.replace(/:/g, \"\"))\n  }).join(\"\")\n\n  return nodesWithoutPseudoClasses.toString()\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/findAtRuleContext.js":"/* @flow */\n\"use strict\"\n\n/**\n * Find the at-rule in which a rule is nested.\n *\n * Returns `null` if the rule is not nested within an at-rule.\n */\nmodule.exports = function findAtRuleContext(\n  rule/*: postcss$rule */\n)/*: ?postcss$atRule*/ {\n  const parent = rule.parent\n\n  if (parent.type === \"root\") {\n    return null\n  }\n  if (parent.type === \"atrule\") {\n    return parent\n  }\n  return findAtRuleContext(parent)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isCustomPropertySet.js":"/* @flow */\n\"use strict\"\n\nconst _ = require(\"lodash\")\nconst hasBlock = require(\"../utils/hasBlock\")\n\n/**\n * Check whether a Node is a custom property set\n */\nmodule.exports = function (node/*: Object*/)/*: boolean*/ {\n  const selector = _.get(node, \"raws.selector.raw\", node.selector)\n\n  return node.type === \"rule\" && hasBlock(node) && selector.slice(0, 2) === \"--\" && selector.slice(-1) === \":\"\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/nodeContextLookup.js":"// Too weird for Flow\n\"use strict\"\n\n/**\n * Create a collection of Maps that serve to contextualize a given node.\n * This is useful to ensure that you only compare nodes that share a certain\n * context.\n *\n * All nodes are initially contextualized by their input source.\n * From there, you can contextualize them however you want.\n *\n * For a usage example, see `selector-no-descending-specificity`.\n */\nmodule.exports = function () {\n  const contextMap = new Map()\n\n  return {\n    getContext(node) {\n      const nodeSource = node.source.input.from\n      const baseContext = creativeGetMap(contextMap, nodeSource)\n      const subContexts = Array.from(arguments).slice(1)\n\n      return subContexts.reduce((result, context) => {\n        return creativeGetMap(result, context)\n      }, baseContext)\n    },\n  }\n}\n\nfunction creativeGetMap(someMap, someThing) {\n  if (!someMap.has(someThing)) {\n    someMap.set(someThing, new Map())\n  }\n  return someMap.get(someThing)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/parseSelector.js":"/* @flow */\n\"use strict\"\n\nconst selectorParser = require(\"postcss-selector-parser\")\n\nmodule.exports = function (\n  selector/*: string*/,\n  result/*: Object*/,\n  node/*: Object*/,\n  cb/*: Function*/\n) {\n  try {\n    selectorParser(cb).process(selector)\n  } catch (e) {\n    result.warn(\"Cannot parse selector\", { node })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-duplicate-selectors/index.js":"\"use strict\"\n\nconst findAtRuleContext = require(\"../../utils/findAtRuleContext\")\nconst isKeyframeRule = require(\"../../utils/isKeyframeRule\")\nconst nodeContextLookup = require(\"../../utils/nodeContextLookup\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst normalizeSelector = require(\"normalize-selector\")\nconst resolvedNestedSelector = require(\"postcss-resolve-nested-selector\")\n\nconst ruleName = \"no-duplicate-selectors\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (selector, firstDuplicateLine) => `Unexpected duplicate selector \"${selector}\", first used at line ${firstDuplicateLine}`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    // The top level of this map will be rule sources.\n    // Each source maps to another map, which maps rule parents to a set of selectors.\n    // This ensures that selectors are only checked against selectors\n    // from other rules that share the same parent and the same source.\n    const selectorContextLookup = nodeContextLookup()\n\n    root.walkRules(rule => {\n      if (isKeyframeRule(rule)) {\n        return\n      }\n\n      const contextSelectorSet = selectorContextLookup.getContext(rule, findAtRuleContext(rule))\n      const resolvedSelectors = rule.selectors.reduce((result, selector) => {\n        return _.union(result, resolvedNestedSelector(selector, rule))\n      }, [])\n      const normalizedSelectorList = resolvedSelectors.map(normalizeSelector)\n      const selectorLine = rule.source.start.line\n\n      // Complain if the same selector list occurs twice\n\n      // Sort the selectors list so that the order of the constituents\n      // doesn't matter\n      const sortedSelectorList = normalizedSelectorList.slice().sort().join(\",\")\n      if (contextSelectorSet.has(sortedSelectorList)) {\n        // If the selector isn't nested we can use its raw value; otherwise,\n        // we have to approximate something for the message -- which is close enough\n        const isNestedSelector = resolvedSelectors.join(\",\") !== rule.selectors.join(\",\")\n        const selectorForMessage = isNestedSelector ? resolvedSelectors.join(\", \") : rule.selector\n        const previousDuplicatePosition = contextSelectorSet.get(sortedSelectorList)\n\n        return report({\n          result,\n          ruleName,\n          node: rule,\n          message: messages.rejected(selectorForMessage, previousDuplicatePosition),\n        })\n      }\n\n      contextSelectorSet.set(sortedSelectorList, selectorLine)\n\n      // Or complain if one selector list contains the same selector more than one\n      rule.selectors.forEach((selector, i) => {\n        if (_.includes(normalizedSelectorList.slice(0, i), normalizeSelector(selector))) {\n          report({\n            result,\n            ruleName,\n            node: rule,\n            message: messages.rejected(selector, selectorLine),\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isKeyframeRule.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check if a rule is a keyframe one\n */\nmodule.exports = function (rule/*: postcss$rule*/)/*: boolean*/ {\n  const parent = rule.parent\n\n  return parent.type === \"atrule\" && parent.name.toLowerCase() === \"keyframes\"\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-empty-source/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"no-empty-source\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected empty source\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    if (!/^\\s*$/.test(root.toString())) {\n      return\n    }\n\n    report({\n      message: messages.rejected,\n      node: root,\n      result,\n      ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-eol-whitespace/index.js":"\"use strict\"\n\nconst isOnlyWhitespace = require(\"../../utils/isOnlyWhitespace\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"no-eol-whitespace\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected whitespace at end of line\",\n})\n\nconst whitespacesToReject = new Set([\n  \" \",\n  \"\\t\",\n])\n\nconst rule = function (on, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: on,\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignore: [\"empty-lines\"],\n      },\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const rootString = root.toString()\n    styleSearch({\n      source: rootString,\n      target: [\n        \"\\n\",\n        \"\\r\",\n      ],\n      comments: \"check\",\n    }, match => {\n      // If the character before newline is not whitespace, ignore\n      if (!whitespacesToReject.has(rootString[match.startIndex - 1])) {\n        return\n      }\n\n      if (optionsMatches(options, \"ignore\", \"empty-lines\")) {\n        // If there is only whitespace between the previous newline and\n        // this newline, ignore\n        const lineBefore = rootString.substring(match.startIndex + 1, rootString.lastIndexOf(\"\\n\", match.startIndex - 1))\n        if (isOnlyWhitespace(lineBefore)) {\n          return\n        }\n      }\n\n      report({\n        message: messages.rejected,\n        node: root,\n        index: match.startIndex - 1,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isOnlyWhitespace.js":"/* @flow */\n\"use strict\"\n\nconst isWhitespace = require(\"./isWhitespace\")\n\n/**\n * Returns a Boolean indicating whether the the input string is only whitespace.\n */\nmodule.exports = function (input/*: string*/)/*: boolean*/ {\n  let isOnlyWhitespace = true\n  for (let i = 0, l = input.length; i < l; i++) {\n    if (!isWhitespace(input[i])) {\n      isOnlyWhitespace = false\n      break\n    }\n  }\n  return isOnlyWhitespace\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-extra-semicolons/index.js":"\"use strict\"\n\nconst hasEmptyBlock = require(\"../../utils/hasEmptyBlock\")\nconst isCustomPropertySet = require(\"../../utils/isCustomPropertySet\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"no-extra-semicolons\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected extra semicolon\",\n})\n\nfunction getOffsetByNode(node) {\n  const string = node.root().source.input.css\n  const nodeColumn = node.source.start.column\n  const nodeLine = node.source.start.line\n  let line = 1\n  let column = 1\n  let index = 0\n\n  for (let i = 0; i < string.length; i++) {\n    if (column === nodeColumn && nodeLine === line) {\n      index = i\n      break\n    }\n\n    if (string[i] === \"\\n\") {\n      column = 1\n      line += 1\n    } else {\n      column += 1\n    }\n  }\n\n  return index\n}\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    const rawAfterRoot = root.raws.after\n\n    if (rawAfterRoot && rawAfterRoot.trim().length !== 0) {\n      styleSearch({ source: rawAfterRoot, target: \";\" }, match => {\n        complain(root.toString().length - rawAfterRoot.length + match.startIndex)\n      })\n    }\n\n    root.walk(node => {\n      let rawBeforeNode = node.raws.before\n\n      if (rawBeforeNode && rawBeforeNode.trim().length !== 0) {\n        let allowedSemi = 0\n\n        // Forbid semicolon before first custom properties sets\n        if (isCustomPropertySet(node) && node.parent.index(node) > 0) {\n          allowedSemi = 1\n        }\n\n        const next = node.next()\n\n        // Ignore semicolon before comment if next node is custom properties sets or comment\n        if (node.type === \"comment\" && next\n          && (isCustomPropertySet(next) && node.parent.index(next) > 0 || next.type === \"comment\")\n        ) {\n          allowedSemi = 1\n        }\n\n        const prev = node.prev()\n\n        // Adding previous node string to custom properties set if previous node is comment\n        if (isCustomPropertySet(node) && node.parent.index(node) > 0 && prev && prev.type === \"comment\") {\n          rawBeforeNode = prev.toString() + rawBeforeNode\n          allowedSemi = 0\n        }\n\n        styleSearch({ source: rawBeforeNode, target: \";\" }, (match, count) => {\n          if (count === allowedSemi) {\n            return\n          }\n\n          complain(getOffsetByNode(node) - rawBeforeNode.length + match.startIndex)\n        })\n      }\n\n      const rawAfterNode = node.raws.after\n\n      if (rawAfterNode && rawAfterNode.trim().length !== 0) {\n        let allowedSemi = 0\n\n        if (!hasEmptyBlock(node) && isCustomPropertySet(node.nodes[node.nodes.length - 1])) {\n          allowedSemi = 1\n        }\n\n        styleSearch({ source: rawAfterNode, target: \";\" }, (match, count) => {\n          if (count === allowedSemi) {\n            return\n          }\n\n          const index = getOffsetByNode(node) + node.toString().length - 1 - rawAfterNode.length + match.startIndex\n          complain(index)\n        })\n      }\n    })\n\n    function complain(index) {\n      report({\n        message: messages.rejected,\n        node: root,\n        index,\n        result,\n        ruleName,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-indistinguishable-colors/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isValidHex = require(\"../../utils/isValidHex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst Result = require(\"postcss/lib/result\")\nconst colorguard = require(\"colorguard\")\n\nconst ruleName = \"no-indistinguishable-colors\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (a, b) => `Unexpected indistinguishable colors \"${a}\" and \"${b}\"`,\n})\n\nconst rule = function (on, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual: on }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignore: isValidHex,\n        threshold: x => _.isNumber(x) && x >= 0 && x <= 100,\n        whitelist: x => _.isArray(x) && x.every(isValidHex),\n      },\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    const colorguardResult = new Result()\n    colorguard(options)(root, colorguardResult)\n    colorguardResult.warnings().forEach(colorguardWarning => {\n      const message = messages.rejected(colorguardWarning.secondColor, colorguardWarning.firstColor)\n      report({\n        ruleName,\n        result,\n        message,\n        node: colorguardWarning.node,\n        index: colorguardWarning.node.toString().indexOf(colorguardWarning.secondColor),\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-invalid-double-slash-comments/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"no-invalid-double-slash-comments\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected double-slash CSS comment\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (decl.prop.indexOf(\"//\") === 0) {\n        report({\n          message: messages.rejected,\n          node: decl,\n          result,\n          ruleName,\n        })\n      }\n    })\n    root.walkRules(rule => {\n      rule.selectors.forEach(selector => {\n        if (selector.indexOf(\"//\") === 0) {\n          report({\n            message: messages.rejected,\n            node: rule,\n            result,\n            ruleName,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-missing-end-of-source-newline/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"no-missing-end-of-source-newline\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected missing end-of-source newline\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    const sourceCss = root.source.input.css\n    if (sourceCss === \"\" || sourceCss.slice(-1) === \"\\n\") {\n      return\n    }\n\n    report({\n      message: messages.rejected,\n      node: root,\n      index: sourceCss.length - 1,\n      result,\n      ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-unsupported-browser-features/index.js":"\"use strict\"\n\nconst doiuse = require(\"doiuse\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst Result = require(\"postcss/lib/result\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"no-unsupported-browser-features\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: details => `Unexpected browser feature ${details}`,\n})\n\nconst rule = function (on, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual: on }, {\n      optional: true,\n      actual: options,\n      possible: {\n        browsers: [_.isString],\n        ignore: [_.isString],\n      },\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    const doiuseOptions = {}\n\n    if (options && options.browsers) {\n      doiuseOptions.browsers = options.browsers\n    }\n\n    if (options && options.ignore) {\n      doiuseOptions.ignore = options.ignore\n    }\n\n    const doiuseResult = new Result()\n    doiuse(doiuseOptions).postcss(root, doiuseResult)\n    doiuseResult.warnings().forEach(doiuseWarning => {\n      report({\n        ruleName,\n        result,\n        message: messages.rejected(cleanDoiuseWarningText(doiuseWarning.text)),\n        node: doiuseWarning.node,\n        line: doiuseWarning.line,\n        column: doiuseWarning.column,\n      })\n    })\n  }\n}\n\nfunction cleanDoiuseWarningText(warningText) {\n  // Get index of feature Id\n  const featureIdIndex = warningText.lastIndexOf(\"(\")\n\n  // Get feature Id, then replace brackets with quotes\n  const featureId = warningText.slice(featureIdIndex, warningText.length).replace(/\\(|\\)/g, \"\\\"\")\n\n  // Get start of support text i.e. \"x not supported by...\", or \"y only partially supported by...\"\n  const browserSupportStartIndex = warningText.indexOf(\"not\") !== -1 ? warningText.indexOf(\"not\") : warningText.indexOf(\"only\")\n\n  // Get browser support text, then strip brackets.\n  const browserSupport = warningText.slice(browserSupportStartIndex, featureIdIndex - 1).replace(/\\(|\\)|:/g, \"\")\n\n  return `${featureId} is ${browserSupport}`\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/no-unknown-animations/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst findAnimationName = require(\"../../utils/findAnimationName\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\n\nconst ruleName = \"no-unknown-animations\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: animationName => `Unexpected unknown animation name \"${animationName}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    const declaredAnimations = new Set()\n    root.walkAtRules(/(-(moz|webkit)-)?keyframes/i, atRule => {\n      declaredAnimations.add(atRule.params)\n    })\n\n    root.walkDecls(decl => {\n      if (decl.prop.toLowerCase() === \"animation\" || decl.prop.toLowerCase() === \"animation-name\") {\n        const animationNames = findAnimationName(decl.value)\n\n        if (animationNames.length === 0) {\n          return\n        }\n\n        animationNames.forEach(animationNameNode => {\n          if (keywordSets.animationNameKeywords.has(animationNameNode.value.toLowerCase())) {\n            return\n          }\n          if (declaredAnimations.has(animationNameNode.value)) {\n            return\n          }\n\n          report({\n            result,\n            ruleName,\n            message: messages.rejected(animationNameNode.value),\n            node: decl,\n            index: declarationValueIndex(decl) + animationNameNode.sourceIndex,\n          })\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/findAnimationName.js":"/* @flow */\n\"use strict\"\n\nconst keywordSets = require(\"../reference/keywordSets\")\nconst getUnitFromValueNode = require(\"./getUnitFromValueNode\")\nconst isStandardSyntaxValue = require(\"./isStandardSyntaxValue\")\nconst isVariable = require(\"./isVariable\")\nconst postcssValueParser = require(\"postcss-value-parser\")\n\n/**\n * Get the font-families within a `font` shorthand property value.\n */\nmodule.exports = function findAnimationName(value/*: string*/)/*: Array<Object>*/ {\n  const animationNames = []\n\n  const valueNodes = postcssValueParser(value)\n\n  // Handle `inherit`, `initial` and etc\n  if (valueNodes.nodes.length === 1 && keywordSets.basicKeywords.has(valueNodes.nodes[0].value.toLowerCase())) {\n    return [valueNodes.nodes[0]]\n  }\n\n  valueNodes.walk(valueNode => {\n    if (valueNode.type === \"function\") {\n      return false\n    }\n    if (valueNode.type !== \"word\") {\n      return\n    }\n\n    const valueLowerCase = valueNode.value.toLowerCase()\n\n    // Ignore non standard syntax\n    if (!isStandardSyntaxValue(valueLowerCase)) {\n      return\n    }\n    // Ignore variables\n    if (isVariable(valueLowerCase)) {\n      return\n    }\n    // Ignore keywords for other font parts\n    if (keywordSets.animationShorthandKeywords.has(valueLowerCase)) {\n      return\n    }\n    // Ignore numbers with units\n    const unit = getUnitFromValueNode(valueNode)\n    if (unit || unit === \"\") {\n      return\n    }\n\n    animationNames.push(valueNode)\n  })\n\n  return animationNames\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/number-leading-zero/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"number-leading-zero\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected a leading zero\",\n  rejected: \"Unexpected leading zero\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      if (atRule.name.toLowerCase() === \"import\") {\n        return\n      }\n\n      check(atRule, atRule.params, atRuleParamIndex)\n    })\n\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n\n    function check(node, value, getIndex) {\n      // Get out quickly if there are no periods\n      if (value.indexOf(\".\") === -1) {\n        return\n      }\n\n      valueParser(value).walk(valueNode => {\n        // Ignore `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        // Ignore strings, comments, etc\n        if (valueNode.type !== \"word\") {\n          return\n        }\n\n        // Check leading zero\n        if (expectation === \"always\") {\n          const match = /(?:\\D|^)(\\.\\d+)/.exec(valueNode.value)\n\n          if (match === null) {\n            return\n          }\n\n          // The regexp above consists of 2 capturing groups (or capturing parentheses).\n          // We need the index of the second group. This makes sanse when we have \"-.5\" as an input\n          // for regex. And we need the index of \".5\".\n          const capturingGroupIndex = match[0].length - match[1].length\n          complain(messages.expected, node, getIndex(node) + valueNode.sourceIndex + match.index + capturingGroupIndex)\n        }\n\n        if (expectation === \"never\") {\n          const match = /(?:\\D|^)(0+\\.\\d+)/.exec(valueNode.value)\n\n          if (match === null) {\n            return\n          }\n\n          const capturingGroupIndex = match[0].length - match[1].length\n          complain(messages.rejected, node, getIndex(node) + valueNode.sourceIndex + match.index + capturingGroupIndex)\n        }\n      })\n    }\n\n    function complain(message, node, index) {\n      report({\n        result,\n        ruleName,\n        message,\n        node,\n        index,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/number-max-precision/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"number-max-precision\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (number, precision) => `Expected \"${number}\" to be \"${number.toFixed(precision)}\"`,\n})\n\nconst rule = function (precision) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: precision,\n      possible: [_.isNumber],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      if (atRule.name.toLowerCase() === \"import\") {\n        return\n      }\n\n      check(atRule, atRule.params, atRuleParamIndex)\n    })\n\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n\n    function check(node, value, getIndex) {\n      // Get out quickly if there are no periods\n      if (value.indexOf(\".\") === -1) {\n        return\n      }\n\n      valueParser(value).walk(valueNode => {\n        // Ignore `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        // Ignore strings, comments, etc\n        if (valueNode.type !== \"word\") {\n          return\n        }\n\n        const match = /\\d*\\.(\\d+)/.exec(valueNode.value)\n\n        if (match === null) {\n          return\n        }\n\n        if (match[1].length <= precision) {\n          return\n        }\n\n        report({\n          result,\n          ruleName,\n          node,\n          index: getIndex(node) + valueNode.sourceIndex + match.index,\n          message: messages.expected(parseFloat(match[0]), precision),\n        })\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/number-no-trailing-zeros/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"number-no-trailing-zeros\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected trailing zero(s)\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkAtRules(atRule => {\n      if (atRule.name.toLowerCase() === \"import\") {\n        return\n      }\n\n      check(atRule, atRule.params, atRuleParamIndex)\n    })\n\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n\n    function check(node, value, getIndex) {\n      // Get out quickly if there are no periods\n      if (value.indexOf(\".\") === -1) {\n        return\n      }\n\n      valueParser(value).walk(valueNode => {\n        // Ignore `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        // Ignore strings, comments, etc\n        if (valueNode.type !== \"word\") {\n          return\n        }\n\n        const match = /(\\.\\d*)0+(?:\\D|$)/.exec(valueNode.value)\n\n        if (match === null) {\n          return\n        }\n\n        report({\n          message: messages.rejected,\n          node,\n          index: getIndex(node) + valueNode.sourceIndex + match.index + match[1].length,\n          result,\n          ruleName,\n        })\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/property-blacklist/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"property-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: property => `Unexpected property \"${property}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop\n\n      if (!isStandardSyntaxProperty(prop)) {\n        return\n      }\n      if (isCustomProperty(prop)) {\n        return\n      }\n      if (!matchesStringOrRegExp(postcss.vendor.unprefixed(prop), blacklist)) {\n        return\n      }\n\n      report({\n        message: messages.rejected(prop),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/property-case/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"property-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop\n\n      if (!isStandardSyntaxProperty(prop)) {\n        return\n      }\n      if (isCustomProperty(prop)) {\n        return\n      }\n\n      const expectedProp = expectation === \"lower\" ? prop.toLowerCase() : prop.toUpperCase()\n      if (prop === expectedProp) {\n        return\n      }\n\n      report({\n        message: messages.expected(prop, expectedProp),\n        node: decl,\n        ruleName,\n        result,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/property-no-unknown/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxDeclaration = require(\"../../utils/isStandardSyntaxDeclaration\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst properties = require(\"known-css-properties\").all\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"property-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: property => `Unexpected unknown property \"${property}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignoreProperties: [_.isString],\n        checkPrefixed: _.isBoolean,\n      },\n      optional: true,\n    })\n\n    if (!validOptions) {\n      return\n    }\n\n    const shouldCheckPrefixed = _.get(options, \"checkPrefixed\")\n\n    root.walkDecls(decl => {\n      const prop = decl.prop\n\n      if (!isStandardSyntaxProperty(prop)) {\n        return\n      }\n      if (!isStandardSyntaxDeclaration(decl)) {\n        return\n      }\n      if (isCustomProperty(prop)) {\n        return\n      }\n\n      if (!shouldCheckPrefixed && postcss.vendor.prefix(prop)) {\n        return\n      }\n\n      if (optionsMatches(options, \"ignoreProperties\", prop)) {\n        return\n      }\n\n      if (properties.indexOf(prop.toLowerCase()) !== -1) {\n        return\n      }\n\n      report({\n        message: messages.rejected(prop),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/property-no-vendor-prefix/index.js":"\"use strict\"\n\nconst isAutoprefixable = require(\"../../utils/isAutoprefixable\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"property-no-vendor-prefix\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: property => `Unexpected vendor-prefix \"${property}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop\n\n      // Make sure there's a vendor prefix,\n      // but this isn't a custom property\n\n      if (prop[0] !== \"-\" || prop[1] === \"-\") {\n        return\n      }\n\n      if (!isAutoprefixable.property(prop)) {\n        return\n      }\n      report({\n        message: messages.rejected(prop),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/property-whitelist/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"property-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: property => `Unexpected property \"${property}\"`,\n})\n\nconst rule = function (whitelist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop\n\n      if (!isStandardSyntaxProperty(prop)) {\n        return\n      }\n      if (isCustomProperty(prop)) {\n        return\n      }\n      if (matchesStringOrRegExp(postcss.vendor.unprefixed(prop), whitelist)) {\n        return\n      }\n\n      report({\n        message: messages.rejected(prop),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/root-no-standard-properties/index.js":"\"use strict\"\n\nconst isCustomProperty = require(\"../../utils/isCustomProperty\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"root-no-standard-properties\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: property => `Unexpected standard property \"${property}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use the community 'stylelint-suitcss' plugin pack.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkRules(rule => {\n      if (rule.selector.toLowerCase().indexOf(\":root\") === -1) {\n        return\n      }\n      parseSelector(rule.selector, result, rule, checkSelector)\n\n      function checkSelector(selectorAST) {\n        if (ignoreRule(selectorAST)) {\n          return\n        }\n\n        rule.each(function (node) {\n          if (node.type !== \"decl\") {\n            return\n          }\n\n          const prop = node.prop\n\n          if (!isStandardSyntaxProperty(prop)) {\n            return\n          }\n          if (isCustomProperty(prop)) {\n            return\n          }\n\n          report({\n            message: messages.rejected(prop),\n            node,\n            result,\n            ruleName,\n          })\n        })\n      }\n    })\n  }\n}\n\nfunction ignoreRule(selectorAST) {\n  let ignore = false\n  selectorAST.walk(selectorNode => {\n    // ignore `:root` selector inside a `:not()` selector\n    if (selectorNode.value && selectorNode.value.toLowerCase() === \":root\" && selectorNode.parent.parent.value && selectorNode.parent.parent.value.toLowerCase() === \":not\") {\n      ignore = true\n    }\n  })\n  return ignore\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/rule-empty-line-before/index.js":"\"use strict\"\n\nconst hasEmptyLine = require(\"../../utils/hasEmptyLine\")\nconst isSingleLineString = require(\"../../utils/isSingleLineString\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"rule-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before rule\",\n  rejected: \"Unexpected empty line before rule\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"after-comment\",\n          \"inside-block\",\n        ],\n        except: [\n          \"after-rule\",\n          \"after-single-line-comment\",\n          \"first-nested\",\n          \"inside-block-and-after-rule\",\n        ],\n      },\n      optional: true,\n    })\n\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n\n      // Ignore the first node\n      if (rule === root.first) {\n        return\n      }\n\n      let expectEmptyLineBefore = expectation.indexOf(\"always\") !== -1 ? true : false\n\n      // Optionally ignore the expectation if a comment precedes this node\n      if (\n        optionsMatches(options, \"ignore\", \"after-comment\")\n        && rule.prev()\n        && rule.prev().type === \"comment\"\n      ) {\n        return\n      }\n\n      // Optionally ignore the expectation if inside a block\n      if (\n        optionsMatches(options, \"ignore\", \"inside-block\")\n        && rule.parent !== root\n      ) {\n        return\n      }\n\n      // Ignore if the expectation is for multiple and the rule is single-line\n      if (\n        expectation.indexOf(\"multi-line\") !== -1\n        && isSingleLineString(rule.toString())\n      ) {\n        return\n      }\n\n      // Optionally reverse the expectation for the first nested node\n      if (\n        optionsMatches(options, \"except\", \"first-nested\")\n        && rule === rule.parent.first\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation if a rule precedes this node\n      if (\n        optionsMatches(options, \"except\", \"after-rule\")\n        && rule.prev()\n        && rule.prev().type === \"rule\"\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation if a rule precedes this node and is inside a block\n      if (\n        optionsMatches(options, \"except\", \"inside-block-and-after-rule\")\n        && rule.prev()\n        && rule.prev().type === \"rule\"\n        && rule.parent !== root\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      // Optionally reverse the expectation for single line comments\n      if (\n        optionsMatches(options, \"except\", \"after-single-line-comment\")\n        && rule.prev()\n        && rule.prev().type === \"comment\"\n        && isSingleLineString(rule.prev().toString())\n      ) {\n        expectEmptyLineBefore = !expectEmptyLineBefore\n      }\n\n      const hasEmptyLineBefore = hasEmptyLine(rule.raws.before)\n\n      // Return if the expectation is met\n      if (expectEmptyLineBefore === hasEmptyLineBefore) {\n        return\n      }\n\n      const message = expectEmptyLineBefore ? messages.expected : messages.rejected\n\n      report({\n        message,\n        node: rule,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxRule.js":"/* @flow */\n\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isCustomPropertySet = require(\"../utils/isCustomPropertySet\")\n\n/**\n * Check whether a Node is a standard rule\n */\nmodule.exports = function (rule/*: Object*/)/*: boolean*/ {\n  // Get full selector\n  const selector = _.get(rule, \"raws.selector.raw\", rule.selector)\n\n  // Custom property set (e.g. --custom-property-set: {})\n  if (isCustomPropertySet(rule)) {\n    return false\n  }\n\n  // Called Less mixin (e.g. a { .mixin() })\n  if (rule.ruleWithoutBody) {\n    return false\n  }\n\n  // Less detached rulesets\n  if (selector.slice(0, 1) === \"@\" && selector.slice(-1) === \":\") {\n    return false\n  }\n\n  // Ignore mixin or &:extend rule\n  // https://github.com/webschik/postcss-less/blob/master/lib/less-parser.js#L52\n  if (rule.params && rule.params[0]) {\n    return false\n  }\n\n  // Non-outputting Less mixin definition (e.g. .mixin() {})\n  if (_.endsWith(selector, \")\") && !_.includes(selector, \":\")) {\n    return false\n  }\n\n  // Ignore Scss nested properties\n  if (selector.slice(-1) === \":\") {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/rule-nested-empty-line-before/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst checkRuleEmptyLineBefore = require(\"../checkRuleEmptyLineBefore\")\n\nconst ruleName = \"rule-nested-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before nested rule\",\n  rejected: \"Unexpected empty line before nested rule\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\"after-comment\"],\n        except: [\n          \"first-nested\",\n          \"after-comment\",\n          \"after-rule\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use 'rule-empty-line-before'.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n\n      // Only attend to nested rule sets\n      if (rule.parent === root) {\n        return\n      }\n\n      checkRuleEmptyLineBefore({ rule, expectation, options, result, messages, checkedRuleName: ruleName })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/checkRuleEmptyLineBefore.js":"\"use strict\"\n\nconst hasEmptyLine = require(\"../utils/hasEmptyLine\")\nconst isSingleLineString = require(\"../utils/isSingleLineString\")\nconst optionsMatches = require(\"../utils/optionsMatches\")\nconst report = require(\"../utils/report\")\n\nmodule.exports = function (opts) {\n  let expectEmptyLineBefore = opts.expectation.indexOf(\"always\") !== -1 ? true : false\n\n  // Optionally ignore the expectation if a comment precedes this node\n  if (optionsMatches(opts.options, \"ignore\", \"after-comment\") && opts.rule.prev() && opts.rule.prev().type === \"comment\") {\n    return\n  }\n\n  // Ignore if the expectation is for multiple and the rule is single-line\n  if (opts.expectation.indexOf(\"multi-line\") !== -1 && isSingleLineString(opts.rule.toString())) {\n    return\n  }\n\n  // Optionally reverse the expectation for the first nested node\n  if (optionsMatches(opts.options, \"except\", \"first-nested\") && opts.rule === opts.rule.parent.first) {\n    expectEmptyLineBefore = !expectEmptyLineBefore\n  }\n\n  // Optionally reverse the expectation if a rule precedes this node\n  if (optionsMatches(opts.options, \"except\", \"after-rule\") && opts.rule.prev() && opts.rule.prev().type === \"rule\") {\n    expectEmptyLineBefore = !expectEmptyLineBefore\n  }\n\n  // Optionally reverse the expectation for single line comments\n  if (optionsMatches(opts.options, \"except\", \"after-single-line-comment\") && opts.rule.prev() && opts.rule.prev().type === \"comment\" && isSingleLineString(opts.rule.prev().toString())) {\n    expectEmptyLineBefore = !expectEmptyLineBefore\n  }\n\n  const hasEmptyLineBefore = hasEmptyLine(opts.rule.raws.before)\n\n  // Return if the expectation is met\n  if (expectEmptyLineBefore === hasEmptyLineBefore) {\n    return\n  }\n\n  const message = expectEmptyLineBefore ? opts.messages.expected : opts.messages.rejected\n\n  report({\n    message,\n    node: opts.rule,\n    result: opts.result,\n    ruleName: opts.checkedRuleName,\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/rule-non-nested-empty-line-before/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst checkRuleEmptyLineBefore = require(\"../checkRuleEmptyLineBefore\")\n\nconst ruleName = \"rule-non-nested-empty-line-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: \"Expected empty line before non-nested rule\",\n  rejected: \"Unexpected empty line before non-nested rule\",\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\"after-comment\"],\n        except: [\"after-single-line-comment\"],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use 'rule-empty-line-before'.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n\n      // Ignore nested rule sets\n      if (rule.parent !== root) {\n        return\n      }\n\n      // Ignore the first node\n      if (rule === root.first) {\n        return\n      }\n\n      checkRuleEmptyLineBefore({ rule, expectation, options, result, messages, checkedRuleName: ruleName })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-attribute-brackets-space-inside/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"selector-attribute-brackets-space-inside\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: \"Expected single space after \\\"[\\\"\",\n  rejectedOpening: \"Unexpected whitespace after \\\"[\\\"\",\n  expectedClosing: \"Expected single space before \\\"]\\\"\",\n  rejectedClosing: \"Unexpected whitespace before \\\"]\\\"\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (rule.selector.indexOf(\"[\") === -1) {\n        return\n      }\n\n      parseSelector(rule.selector, result, rule, selectorTree => {\n        selectorTree.walkAttributes(attributeNode => {\n          const attributeSelectorString = attributeNode.toString()\n\n          styleSearch({ source: attributeSelectorString, target: \"[\" }, match => {\n            const nextCharIsSpace = attributeSelectorString[match.startIndex + 1] === \" \"\n            const index = attributeNode.sourceIndex + match.startIndex + 1\n            if (nextCharIsSpace && expectation === \"never\") {\n              complain(messages.rejectedOpening, index)\n            }\n            if (!nextCharIsSpace && expectation === \"always\") {\n              complain(messages.expectedOpening, index)\n            }\n          })\n\n          styleSearch({ source: attributeSelectorString, target: \"]\" }, match => {\n            const prevCharIsSpace = attributeSelectorString[match.startIndex - 1] === \" \"\n            const index = attributeNode.sourceIndex + match.startIndex - 1\n            if (prevCharIsSpace && expectation === \"never\") {\n              complain(messages.rejectedClosing, index)\n            }\n            if (!prevCharIsSpace && expectation === \"always\") {\n              complain(messages.expectedClosing, index)\n            }\n          })\n        })\n      })\n\n      function complain(message, index) {\n        report({\n          message,\n          index,\n          result,\n          ruleName,\n          node: rule,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-attribute-operator-blacklist/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"selector-attribute-operator-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: operator => `Unexpected operator \"${operator}\"`,\n})\n\nconst rule = function (blacklistInput) {\n  const blacklist = [].concat(blacklistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (rule.selector.indexOf(\"[\") === -1 || rule.selector.indexOf(\"=\") === -1) {\n        return\n      }\n\n      parseSelector(rule.selector, result, rule, selectorTree => {\n        selectorTree.walkAttributes(attributeNode => {\n          const operator = attributeNode.operator\n\n          if (!operator || operator && blacklist.indexOf(operator) === -1) {\n            return\n          }\n\n          report({\n            message: messages.rejected(operator),\n            node: rule,\n            index: attributeNode.attribute.length + 1,\n            result,\n            ruleName,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-attribute-operator-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorAttributeOperatorSpaceChecker = require(\"../selectorAttributeOperatorSpaceChecker\")\n\nconst ruleName = \"selector-attribute-operator-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: operator => `Expected single space after \"${operator}\"`,\n  rejectedAfter: operator => `Unexpected whitespace after \"${operator}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const checker = whitespaceChecker(\"space\", expectation, messages)\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorAttributeOperatorSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n      checkBeforeOperator: false,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selectorAttributeOperatorSpaceChecker.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../utils/parseSelector\")\nconst report = require(\"../utils/report\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (options) {\n  options.root.walkRules(rule => {\n    if (!isStandardSyntaxRule(rule)) {\n      return\n    }\n    if (rule.selector.indexOf(\"[\") === -1 || rule.selector.indexOf(\"=\") === -1) {\n      return\n    }\n\n    parseSelector(rule.selector, options.result, rule, selectorTree => {\n      selectorTree.walkAttributes(attributeNode => {\n        const operator = attributeNode.operator\n\n        if (!operator) {\n          return\n        }\n\n        const attributeNodeString = attributeNode.toString()\n\n        styleSearch({ source: attributeNodeString, target: operator }, match => {\n          const index = options.checkBeforeOperator ? match.startIndex : match.endIndex - 1\n          checkOperator(attributeNodeString, index, rule, attributeNode.sourceIndex, operator)\n        })\n      })\n    })\n\n    function checkOperator(source, index, node, attributeIndex, operator) {\n      options.locationChecker({\n        source,\n        index,\n        err: m => report({\n          message: m.replace(options.checkBeforeOperator ? operator[0] : operator[operator.length - 1], operator),\n          node,\n          index: attributeIndex + index,\n          result: options.result,\n          ruleName: options.checkedRuleName,\n        }),\n      })\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-attribute-operator-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorAttributeOperatorSpaceChecker = require(\"../selectorAttributeOperatorSpaceChecker\")\n\nconst ruleName = \"selector-attribute-operator-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: operator => `Expected single space before \"${operator}\"`,\n  rejectedBefore: operator => `Unexpected whitespace before \"${operator}\"`,\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorAttributeOperatorSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n      checkBeforeOperator: true,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-attribute-operator-whitelist/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\n\nconst ruleName = \"selector-attribute-operator-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: operator => `Unexpected operator \"${operator}\"`,\n})\n\nconst rule = function (whitelistInput) {\n  const whitelist = [].concat(whitelistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (rule.selector.indexOf(\"[\") === -1 || rule.selector.indexOf(\"=\") === -1) {\n        return\n      }\n\n      parseSelector(rule.selector, result, rule, selectorTree => {\n        selectorTree.walkAttributes(attributeNode => {\n          const operator = attributeNode.operator\n\n          if (!operator || operator && whitelist.indexOf(operator) !== -1) {\n            return\n          }\n\n          report({\n            message: messages.rejected(operator),\n            node: rule,\n            index: attributeNode.attribute.length + 1,\n            result,\n            ruleName,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-attribute-quotes/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-attribute-quotes\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: value => `Expected quotes around \"${value}\"`,\n  rejected: value => `Unexpected quotes around \"${value}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (rule.selector.indexOf(\"[\") === -1 || rule.selector.indexOf(\"=\") === -1) {\n        return\n      }\n\n      parseSelector(rule.selector, result, rule, selectorTree => {\n        selectorTree.walkAttributes(attributeNode => {\n          if (!attributeNode.operator) {\n            return\n          }\n\n          const attributeSelectorString = attributeNode.toString()\n\n          if (!attributeNode.quoted && expectation === \"always\") {\n            complain(messages.expected(attributeNode.raws.unquoted), attributeNode.sourceIndex + attributeSelectorString.indexOf(attributeNode.value))\n          }\n\n          if (attributeNode.quoted && expectation === \"never\") {\n            complain(messages.rejected(attributeNode.raws.unquoted), attributeNode.sourceIndex + attributeSelectorString.indexOf(attributeNode.value))\n          }\n        })\n      })\n\n      function complain(message, index) {\n        report({\n          message,\n          index,\n          result,\n          ruleName,\n          node: rule,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-class-pattern/index.js":"\"use strict\"\n\nconst isKeyframeSelector = require(\"../../utils/isKeyframeSelector\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst resolveNestedSelector = require(\"postcss-resolve-nested-selector\")\n\nconst ruleName = \"selector-class-pattern\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: selectorValue => `Expected class selector \".${selectorValue}\" to match specified pattern`,\n})\n\nconst rule = function (pattern, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [\n        _.isRegExp,\n        _.isString,\n      ],\n    }, {\n      actual: options,\n      possible: {\n        resolveNestedSelectors: _.isBoolean,\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const shouldResolveNestedSelectors = _.get(options, \"resolveNestedSelectors\")\n    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern\n\n    root.walkRules(rule => {\n      const selector = rule.selector,\n        selectors = rule.selectors\n\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      if (selectors.some(s => isKeyframeSelector(s))) {\n        return\n      }\n\n      // Only bother resolving selectors that have an interpolating &\n      if (shouldResolveNestedSelectors && hasInterpolatingAmpersand(selector)) {\n        resolveNestedSelector(selector, rule).forEach(selector => {\n          if (!isStandardSyntaxSelector(selector)) {\n            return\n          }\n\n          parseSelector(selector, result, rule, s => checkSelector(s, rule))\n        })\n      } else {\n        parseSelector(selector, result, rule, s => checkSelector(s, rule))\n      }\n    })\n\n    function checkSelector(fullSelector, rule) {\n      fullSelector.walkClasses(classNode => {\n        const value = classNode.value,\n          sourceIndex = classNode.sourceIndex\n\n        if (normalizedPattern.test(value)) {\n          return\n        }\n        report({\n          result,\n          ruleName,\n          message: messages.expected(value),\n          node: rule,\n          index: sourceIndex,\n        })\n      })\n    }\n  }\n}\n\n// An \"interpolating ampersand\" means an \"&\" used to interpolate\n// within another simple selector, rather than an \"&\" that\n// stands on its own as a simple selector\nfunction hasInterpolatingAmpersand(selector) {\n  for (let i = 0, l = selector.length; i < l; i++) {\n    if (selector[i] !== \"&\") {\n      continue\n    }\n    if (!_.isUndefined(selector[i - 1]) && !isCombinator(selector[i - 1])) {\n      return true\n    }\n    if (!_.isUndefined(selector[i + 1]) && !isCombinator(selector[i + 1])) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction isCombinator(x) {\n  return (/[\\s+>~]/.test(x)\n  )\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isKeyframeSelector.js":"/* @flow */\n\"use strict\"\n\nconst keywordSets = require(\"../reference/keywordSets\")\n\n/**\n * Check whether a string is a keyframe selector.\n */\nmodule.exports = function (selector/*: string*/)/*: boolean*/ {\n  if (keywordSets.keyframeSelectorKeywords.has(selector)) {\n    return true\n  }\n\n  // Percentages\n  if (/^(?:\\d+\\.?\\d*|\\d*\\.?\\d+)%$/.test(selector)) {\n    return true\n  }\n\n  return false\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxSelector.js":"/* @flow */\n\"use strict\"\n\nconst hasInterpolation = require(\"../utils/hasInterpolation\")\n/**\n * Check whether a selector is standard\n */\nmodule.exports = function (selector/*: string*/)/*: boolean*/ {\n  // SCSS or Less interpolation\n  if (hasInterpolation(selector)) {\n    return false\n  }\n\n  // SCSS placeholder selectors\n  if (selector.indexOf(\"%\") === 0) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-combinator-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorCombinatorSpaceChecker = require(\"../selectorCombinatorSpaceChecker\")\n\nconst ruleName = \"selector-combinator-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: combinator => `Expected single space after \"${combinator}\"`,\n  rejectedAfter: combinator => `Unexpected whitespace after \"${combinator}\"`,\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorCombinatorSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selectorCombinatorSpaceChecker.js":"\"use strict\"\n\nconst report = require(\"../utils/report\")\nconst _ = require(\"lodash\")\nconst punctuationSets = require(\"../reference/punctuationSets\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (opts) {\n  opts.root.walkRules(rule => {\n    // Check each selector individually, instead of all as one string,\n    // in case some that aren't the first begin with combinators (nesting syntax)\n    rule.selectors.forEach(selector => {\n      styleSearch({\n        source: selector,\n        target: _.toArray(punctuationSets.nonSpaceCombinators),\n        parentheticals: \"skip\",\n      }, match => {\n        const endIndex = match.endIndex,\n          startIndex = match.startIndex,\n          target = match.target\n\n        // Catch ~= in attribute selectors\n\n        if (target === \"~\" && selector[endIndex] === \"=\") {\n          return\n        }\n\n        // Catch escaped combinator-like character\n        if (selector[startIndex - 1] === \"\\\\\") {\n          return\n        }\n\n        check(selector, startIndex, rule)\n      })\n    })\n  })\n\n  function check(source, index, node) {\n    opts.locationChecker({ source, index, err: m => report({\n      message: m,\n      node,\n      index,\n      result: opts.result,\n      ruleName: opts.checkedRuleName,\n    }),\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-combinator-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorCombinatorSpaceChecker = require(\"../selectorCombinatorSpaceChecker\")\n\nconst ruleName = \"selector-combinator-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: combinator => `Expected single space before \"${combinator}\"`,\n  rejectedBefore: combinator => `Unexpected whitespace before \"${combinator}\"`,\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorCombinatorSpaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-descendant-combinator-no-non-space/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst punctuationSets = require(\"../../reference/punctuationSets\")\n\nconst ruleName = \"selector-descendant-combinator-no-non-space\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: nonSpaceCharacter => `Unexpected \"${nonSpaceCharacter}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n\n      const selector = rule.selector\n\n      parseSelector(selector, result, rule, fullSelector => {\n        fullSelector.walkCombinators(combinatorNode => {\n          const value = combinatorNode.value\n\n          if (punctuationSets.nonSpaceCombinators.has(value)) {\n            return\n          }\n          if (value === \" \") {\n            return\n          }\n\n          report({\n            result,\n            ruleName,\n            message: messages.rejected(value),\n            node: rule,\n            index: combinatorNode.sourceIndex,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-id-pattern/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-id-pattern\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: selectorValue => `Expected id selector \"#${selectorValue}\" to match specified pattern`,\n})\n\nconst rule = function (pattern) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [\n        _.isRegExp,\n        _.isString,\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n\n      parseSelector(selector, result, rule, fullSelector => {\n        fullSelector.walk(selectorNode => {\n          if (selectorNode.type !== \"id\") {\n            return\n          }\n          const value = selectorNode.value,\n            sourceIndex = selectorNode.sourceIndex\n\n          if (normalizedPattern.test(value)) {\n            return\n          }\n\n          report({\n            result,\n            ruleName,\n            message: messages.expected(value),\n            node: rule,\n            index: sourceIndex,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-list-comma-newline-after/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"selector-list-comma-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\",\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\",\\\" in a multi-line list\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\",\\\" in a multi-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      // Get raw selector so we can allow end-of-line comments, e.g.\n      // a, /* comment */\n      // b {}\n      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector\n      styleSearch({\n        source: selector,\n        target: \",\",\n        functionArguments: \"skip\",\n      }, match => {\n        const nextThreeChars = selector.substr(match.endIndex, 3)\n\n        // If there's a // comment, that means there has to be a newline\n        // ending the comment so we're fine\n        if (nextThreeChars === \" //\") {\n          return\n        }\n\n        // If there is a space and then a comment begins, look for the newline\n        // after that comment\n        const indextoCheckAfter = nextThreeChars === \" /*\" ? selector.indexOf(\"*/\", match.endIndex) + 1 : match.startIndex\n        checker.afterOneOnly({\n          source: selector,\n          index: indextoCheckAfter,\n          err: m => report({\n            message: m,\n            node: rule,\n            index: match.startIndex,\n            result,\n            ruleName,\n          }),\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-list-comma-newline-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorListCommaWhitespaceChecker = require(\"../selectorListCommaWhitespaceChecker\")\n\nconst ruleName = \"selector-list-comma-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected newline before \\\",\\\"\",\n  expectedBeforeMultiLine: () => \"Expected newline before \\\",\\\" in a multi-line list\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\",\\\" in a multi-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.beforeAllowingIndentation,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selectorListCommaWhitespaceChecker.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../utils/isStandardSyntaxRule\")\nconst report = require(\"../utils/report\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (opts) {\n  opts.root.walkRules(rule => {\n    if (!isStandardSyntaxRule(rule)) {\n      return\n    }\n    const selector = rule.selector\n    styleSearch({\n      source: selector,\n      target: \",\",\n      functionArguments: \"skip\",\n    }, match => {\n      checkDelimiter(selector, match.startIndex, rule)\n    })\n  })\n\n  function checkDelimiter(source, index, node) {\n    opts.locationChecker({ source, index, err: m => report({\n      message: m,\n      node,\n      index,\n      result: opts.result,\n      ruleName: opts.checkedRuleName,\n    }),\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-list-comma-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorListCommaWhitespaceChecker = require(\"../selectorListCommaWhitespaceChecker\")\n\nconst ruleName = \"selector-list-comma-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\",\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\",\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\",\\\" in a single-line list\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\",\\\" in a single-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-list-comma-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst selectorListCommaWhitespaceChecker = require(\"../selectorListCommaWhitespaceChecker\")\n\nconst ruleName = \"selector-list-comma-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\",\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\",\\\"\",\n  expectedBeforeSingleLine: () => \"Expected single space before \\\",\\\" in a single-line list\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\",\\\" in a single-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    selectorListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-max-compound-selectors/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst resolvedNestedSelector = require(\"postcss-resolve-nested-selector\")\nconst selectorParser = require(\"postcss-selector-parser\")\n\nconst ruleName = \"selector-max-compound-selectors\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (selector, max) => `Expected \"${selector}\" to have no more than ${max} compound selectors`,\n})\n\nconst rule = function (max) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: [\n        function (max) {\n          return typeof max === \"number\" && max > 0\n        },\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    // Finds actual selectors in selectorNode object and checks them\n    function checkSelector(selectorNode, rule) {\n      let compoundCount = 1\n\n      selectorNode.each(childNode => {\n        // Only traverse inside actual selectors and :not()\n        if (childNode.type === \"selector\" || childNode.value === \":not\") {\n          checkSelector(childNode, rule)\n        }\n\n        // Compound selectors are separated by combinators, so increase count when meeting one\n        if (childNode.type === \"combinator\") {\n          compoundCount++\n        }\n      })\n\n      if (selectorNode.type !== \"root\" && selectorNode.type !== \"pseudo\" && compoundCount > max) {\n        report({\n          ruleName,\n          result,\n          node: rule,\n          message: messages.expected(selectorNode, max),\n          word: selectorNode,\n        })\n      }\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (!isStandardSyntaxSelector(rule.selector)) {\n        return\n      }\n\n      // Nested selectors are processed in steps, as nesting levels are resolved.\n      // Here we skip processing the intermediate parts of selectors (to process only fully resolved selectors)\n      if (rule.nodes.some(node => node.type === \"rule\" || node.type === \"atrule\")) {\n        return\n      }\n\n      // Using `rule.selectors` gets us each selector if there is a comma separated set\n      rule.selectors.forEach(selector => {\n        resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {\n          // Process each resolved selector with `checkSelector` via postcss-selector-parser\n          selectorParser(s => checkSelector(s, rule)).process(resolvedSelector)\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-max-empty-lines/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"selector-max-empty-lines\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty line(s)`,\n})\n\nconst rule = function (max) {\n  const maxAdjacentNewlines = max + 1\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      const selector = rule.raws.selector ? rule.raws.selector.raw : rule.selector\n      const repeatLFNewLines = _.repeat(\"\\n\", maxAdjacentNewlines)\n      const repeatCRLFNewLines = _.repeat(\"\\r\\n\", maxAdjacentNewlines)\n\n      styleSearch({ source: selector, target: \"\\n\" }, match => {\n        if (selector.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || selector.substr(match.startIndex + 1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {\n          // Put index at `\\r` if it's CRLF, otherwise leave it at `\\n`\n          let index = match.startIndex\n          if (selector[index - 1] === \"\\r\") {\n            index -= 1\n          }\n\n          report({\n            message: messages.expected(max),\n            node: rule,\n            index,\n            result,\n            ruleName,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-max-specificity/index.js":"\"use strict\"\n\nconst specificity = require(\"specificity\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst resolvedNestedSelector = require(\"postcss-resolve-nested-selector\")\n\nconst ruleName = \"selector-max-specificity\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (selector, specificity) => `Expected \"${selector}\" to have a specificity no more than \"${specificity}\"`,\n})\n\nconst rule = function (max) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: [\n        function (max) {\n        // Check that the max specificity is in the form \"a,b,c\"\n          const pattern = new RegExp(\"^\\\\d+,\\\\d+,\\\\d+$\")\n          return pattern.test(max)\n        },\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const maxSpecificityArray = (\"0,\" + max).split(\",\").map(parseFloat)\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (!isStandardSyntaxSelector(rule.selector)) {\n        return\n      }\n      // Using rule.selectors gets us each selector in the eventuality we have a comma separated set\n      rule.selectors.forEach(selector => {\n        resolvedNestedSelector(selector, rule).forEach(resolvedSelector => {\n          // Return early if selector contains a not pseudo-class\n          if (selector.indexOf(\":not(\") !== -1) {\n            return\n          }\n          // Return early if selector contains a matches\n          if (selector.indexOf(\":matches(\") !== -1) {\n            return\n          }\n          // Check if the selector specificity exceeds the allowed maximum\n          try {\n            if (specificity.compare(resolvedSelector, maxSpecificityArray) === 1) {\n              report({\n                ruleName,\n                result,\n                node: rule,\n                message: messages.expected(resolvedSelector, max),\n                word: selector,\n              })\n            }\n          } catch (e) {\n            result.warn(\"Cannot parse selector\", { node: rule })\n          }\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-nested-pattern/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-nested-pattern\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: selector => `Expected nested selector \"${selector}\" to match specified pattern`,\n})\n\nconst rule = function (pattern) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: pattern,\n      possible: [\n        _.isRegExp,\n        _.isString,\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const normalizedPattern = _.isString(pattern) ? new RegExp(pattern) : pattern\n\n    root.walkRules(rule => {\n      if (rule.parent.type !== \"rule\") {\n        return\n      }\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n\n      if (normalizedPattern.test(selector)) {\n        return\n      }\n\n      report({\n        result,\n        ruleName,\n        message: messages.expected(selector),\n        node: rule,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-attribute/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-no-attribute\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected attribute selector\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      parseSelector(selector, result, rule, selectorAST => {\n        selectorAST.walkAttributes(attribute => {\n          report({\n            message: messages.rejected,\n            node: rule,\n            index: attribute.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-combinator/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-no-combinator\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected combinator\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      parseSelector(selector, result, rule, selectorAST => {\n        selectorAST.walkCombinators(combinator => {\n          report({\n            message: messages.rejected,\n            node: rule,\n            index: combinator.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-empty/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-no-empty\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected empty selector\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      \"'selector-no-empty' has been deprecated and in 8.0 will be removed.\"\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: \"https://stylelint.io/user-guide/rules/selector-no-empty/\",\n    })\n\n    root.walkRules(rule => {\n      let index = 0\n\n      rule.selector.split(\",\").forEach(item => {\n        index += item.length + 1\n\n        if (item.trim() !== \"\") {\n          return\n        }\n\n        report({\n          message: messages.rejected,\n          node: rule,\n          index: index - 1,\n          ruleName,\n          result,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-id/index.js":"\"use strict\"\n\nconst isKeyframeRule = require(\"../../utils/isKeyframeRule\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-no-id\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected id selector\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (isKeyframeRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      parseSelector(selector, result, rule, selectorAST => {\n        selectorAST.walkIds(idNode => {\n          if (idNode.parent.parent.type === \"pseudo\") {\n            return\n          }\n\n          report({\n            message: messages.rejected,\n            node: rule,\n            index: idNode.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-qualifying-type/index.js":"\"use strict\"\n\nconst isKeyframeRule = require(\"../../utils/isKeyframeRule\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst resolvedNestedSelector = require(\"postcss-resolve-nested-selector\")\n\nconst ruleName = \"selector-no-qualifying-type\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected qualifying type selector\",\n})\n\nconst selectorCharacters = [\n  \"#\",\n  \".\",\n  \"[\",\n]\n\nfunction isSelectorCharacters(value) {\n  return selectorCharacters.some(char => value.indexOf(char) !== -1)\n}\n\nfunction getRightNodes(node) {\n  const result = []\n  let rightNode = node\n\n  while ((rightNode = rightNode.next())) {\n    if (rightNode.type === \"combinator\") {\n      break\n    }\n    if (rightNode.type !== \"id\" && rightNode.type !== \"class\" && rightNode.type !== \"attribute\") {\n      continue\n    }\n\n    result.push(rightNode)\n  }\n\n  return result\n}\n\nconst rule = function (enabled, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: enabled,\n      possible: [\n        true,\n        false,\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"attribute\",\n          \"class\",\n          \"id\",\n        ],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (isKeyframeRule(rule)) {\n        return\n      }\n      // Increasing performance\n      if (!isStandardSyntaxSelector(rule.selector)) {\n        return\n      }\n      if (!isSelectorCharacters(rule.selector)) {\n        return\n      }\n\n      function checkSelector(selectorAST) {\n        selectorAST.walkTags(selector => {\n          const selectorParent = selector.parent\n\n          if (selectorParent.nodes.length === 1) {\n            return\n          }\n\n          const selectorNodes = getRightNodes(selector)\n          const index = selector.sourceIndex\n\n          selectorNodes.forEach(selectorNode => {\n            if (selectorNode.type === \"id\" && !optionsMatches(options, \"ignore\", \"id\")) {\n              complain(index)\n            }\n\n            if (selectorNode.type === \"class\" && !optionsMatches(options, \"ignore\", \"class\")) {\n              complain(index)\n            }\n\n            if (selectorNode.type === \"attribute\" && !optionsMatches(options, \"ignore\", \"attribute\")) {\n              complain(index)\n            }\n          })\n        })\n      }\n\n      resolvedNestedSelector(rule.selector, rule).forEach(resolvedSelector => {\n        if (!isStandardSyntaxSelector(resolvedSelector)) {\n          return\n        }\n\n        parseSelector(resolvedSelector, result, rule, checkSelector)\n      })\n\n      function complain(index) {\n        report({\n          ruleName,\n          result,\n          node: rule,\n          message: messages.rejected,\n          index,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-type/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst isKeyframeSelector = require(\"../../utils/isKeyframeSelector\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst isStandardSyntaxTypeSelector = require(\"../../utils/isStandardSyntaxTypeSelector\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst resolveNestedSelector = require(\"postcss-resolve-nested-selector\")\n\nconst ruleName = \"selector-no-type\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected type selector\",\n})\n\nconst rule = function (on, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual: on }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"descendant\",\n          \"compounded\",\n        ],\n        ignoreTypes: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const ignoreDescendant = optionsMatches(options, \"ignore\", \"descendant\")\n    const ignoreCompounded = optionsMatches(options, \"ignore\", \"compounded\")\n\n    root.walkRules(rule => {\n      const selector = rule.selector,\n        selectors = rule.selectors\n\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      if (selectors.some(s => isKeyframeSelector(s))) {\n        return\n      }\n\n      if (ignoreDescendant) {\n        // Resolve each selector within the list before checking\n        selectors.forEach(selector => {\n          resolveNestedSelector(selector, rule).forEach(selector => {\n            checkSelector(selector, rule)\n          })\n        })\n      } else {\n        checkSelector(selector, rule)\n      }\n    })\n\n    function checkSelector(selector, rule) {\n      parseSelector(selector, result, rule, selectorAST => {\n        selectorAST.walkTags(tag => {\n          if (!isStandardSyntaxTypeSelector(tag)) {\n            return\n          }\n\n          if (optionsMatches(options, \"ignoreTypes\", tag.value)) {\n            return\n          }\n\n          if (ignoreDescendant && hasCombinatorBefore(tag)) {\n            return\n          }\n\n          if (ignoreCompounded && isCompounded(tag)) {\n            return\n          }\n\n          report({\n            message: messages.rejected,\n            node: rule,\n            index: tag.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    }\n  }\n}\n\nfunction hasCombinatorBefore(node) {\n  return node.parent.nodes.slice(0, node.parent.nodes.indexOf(node)).some(isCombinator)\n}\n\nfunction isCompounded(node) {\n  if (node.prev() && !isCombinator(node.prev())) {\n    return true\n  }\n  if (node.next() && !isCombinator(node.next())) {\n    return true\n  }\n  return false\n}\n\nfunction isCombinator(node) {\n  if (!node) return false\n  return _.get(node, \"type\") === \"combinator\"\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isStandardSyntaxTypeSelector.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a type selector is standard\n *\n * @param {Node} postcss-selector-parser node (of type tag)\n * @return {boolean} If `true`, the type selector is standard\n */\n\nconst keywordSets = require(\"../reference/keywordSets\")\n\nmodule.exports = function (node/*: Object*/)/*: boolean*/ {\n  // postcss-selector-parser includes the arguments to nth-child() functions\n  // as \"tags\", so we need to ignore them ourselves.\n  // The fake-tag's \"parent\" is actually a selector node, whose parent\n  // should be the :nth-child pseudo node.\n  const _node$parent$parent = node.parent.parent\n  const parentType = _node$parent$parent.type,\n    parentValue = _node$parent$parent.value\n\n  if (parentValue) {\n    const normalisedParentName = parentValue.toLowerCase().replace(/:+/, \"\")\n    if (parentType === \"pseudo\" && (keywordSets.aNPlusBNotationPseudoClasses.has(normalisedParentName) || keywordSets.linguisticPseudoClasses.has(normalisedParentName))) {\n      return false\n    }\n  }\n\n  // &-bar is a nesting selector combined with a suffix\n  if (node.prev() && node.prev().type === \"nesting\") {\n    return false\n  }\n\n  if (node.value[0] === \"%\") {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-universal/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-no-universal\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected universal selector\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      parseSelector(selector, result, rule, selectorAST => {\n        selectorAST.walkUniversals(universal => {\n          report({\n            message: messages.rejected,\n            node: rule,\n            index: universal.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-no-vendor-prefix/index.js":"\"use strict\"\n\nconst isAutoprefixable = require(\"../../utils/isAutoprefixable\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-no-vendor-prefix\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: selector => `Unexpected vendor-prefix \"${selector}\"`,\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          if (isAutoprefixable.selector(pseudoNode.value)) {\n            report({\n              result,\n              ruleName,\n              message: messages.rejected(pseudoNode.value),\n              node: rule,\n              index: (rule.raws.before || \"\").length + pseudoNode.sourceIndex,\n            })\n          }\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-class-blacklist/index.js":"\"use strict\"\n\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"selector-pseudo-class-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: selector => `Unexpected pseudo-class \"${selector}\"`,\n})\n\nconst rule = function (blacklist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      if (selector.indexOf(\":\") === -1) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          const value = pseudoNode.value\n\n          // Ignore pseudo-elements\n\n          if (value.slice(0, 2) === \"::\") {\n            return\n          }\n\n          const name = value.slice(1)\n\n          if (!matchesStringOrRegExp(postcss.vendor.unprefixed(name).toLowerCase(), blacklist)) {\n            return\n          }\n\n          report({\n            index: pseudoNode.sourceIndex,\n            message: messages.rejected(name),\n            node: rule,\n            result,\n            ruleName,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-class-case/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\n\nconst ruleName = \"selector-pseudo-class-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n      const startIndexPseudo = selector.indexOf(\":\")\n\n      if (startIndexPseudo === -1) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          const pseudo = pseudoNode.value\n\n          if (!isStandardSyntaxSelector(pseudo)) {\n            return\n          }\n\n          if (pseudo.indexOf(\"::\") !== -1 || keywordSets.levelOneAndTwoPseudoElements.has(pseudo.toLowerCase().slice(1))) {\n            return\n          }\n\n          const expectedPseudo = expectation === \"lower\" ? pseudo.toLowerCase() : pseudo.toUpperCase()\n\n          if (pseudo === expectedPseudo) {\n            return\n          }\n\n          report({\n            message: messages.expected(pseudo, expectedPseudo),\n            node: rule,\n            index: pseudoNode.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-class-no-unknown/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst isCustomSelector = require(\"../../utils/isCustomSelector\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"selector-pseudo-class-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: selector => `Unexpected unknown pseudo-class selector \"${selector}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignorePseudoClasses: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      // Return early before parse if no pseudos for performance\n\n      if (selector.indexOf(\":\") === -1) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          const value = pseudoNode.value\n\n          if (!isStandardSyntaxSelector(value)) {\n            return\n          }\n\n          if (isCustomSelector(value)) {\n            return\n          }\n\n          // Ignore pseudo-elements\n          if (value.slice(0, 2) === \"::\") {\n            return\n          }\n\n          if (optionsMatches(options, \"ignorePseudoClasses\", pseudoNode.value.slice(1))) {\n            return\n          }\n\n          const name = value.slice(1)\n\n          if (postcss.vendor.prefix(name)\n            || keywordSets.pseudoClasses.has(name.toLowerCase())\n            || keywordSets.pseudoElements.has(name.toLowerCase())\n          ) {\n            return\n          }\n\n          if (pseudoNode.prev()) {\n            const prevPseudoNodeValue = postcss.vendor.unprefixed(pseudoNode.prev().value.toLowerCase().slice(2))\n\n            if (keywordSets.webkitProprietaryPseudoElements.has(prevPseudoNodeValue)\n              && keywordSets.webkitProprietaryPseudoClasses.has(name.toLowerCase())\n            ) {\n              return\n            }\n          }\n\n          report({\n            message: messages.rejected(value),\n            node: rule,\n            index: pseudoNode.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isCustomSelector.js":"/* @flow */\n\"use strict\"\n\n/**\n * Check whether a selector is a custom one\n */\nmodule.exports = function (selector/*: string*/)/*: boolean*/ {\n  return (selector.slice(0, 3) === \":--\")\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-class-parentheses-space-inside/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"selector-pseudo-class-parentheses-space-inside\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedOpening: \"Expected single space after \\\"(\\\"\",\n  rejectedOpening: \"Unexpected whitespace after \\\"(\\\"\",\n  expectedClosing: \"Expected single space before \\\")\\\"\",\n  rejectedClosing: \"Unexpected whitespace before \\\")\\\"\",\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (rule.selector.indexOf(\"(\") === -1) {\n        return\n      }\n\n      parseSelector(rule.selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          if (_.get(pseudoNode, \"parent.parent.type\") === \"pseudo\") {\n            return\n          }\n\n          const pseudoSelectorString = pseudoNode.toString()\n\n          styleSearch({ source: pseudoSelectorString, target: \"(\" }, match => {\n            const nextCharIsSpace = pseudoSelectorString[match.startIndex + 1] === \" \"\n            const index = pseudoNode.sourceIndex + match.startIndex + 1\n            if (nextCharIsSpace && expectation === \"never\") {\n              complain(messages.rejectedOpening, index)\n            }\n            if (!nextCharIsSpace && expectation === \"always\") {\n              complain(messages.expectedOpening, index)\n            }\n          })\n\n          styleSearch({ source: pseudoSelectorString, target: \")\" }, match => {\n            const prevCharIsSpace = pseudoSelectorString[match.startIndex - 1] === \" \"\n            const index = pseudoNode.sourceIndex + match.startIndex - 1\n            if (prevCharIsSpace && expectation === \"never\") {\n              complain(messages.rejectedClosing, index)\n            }\n            if (!prevCharIsSpace && expectation === \"always\") {\n              complain(messages.expectedClosing, index)\n            }\n          })\n        })\n      })\n\n      function complain(message, index) {\n        report({\n          message,\n          index,\n          result,\n          ruleName,\n          node: rule,\n        })\n      }\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-class-whitelist/index.js":"\"use strict\"\n\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"selector-pseudo-class-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: selector => `Unexpected pseudo-class \"${selector}\"`,\n})\n\nconst rule = function (whitelist) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      const selector = rule.selector\n\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      if (selector.indexOf(\":\") === -1) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          const value = pseudoNode.value\n\n          // Ignore pseudo-elements\n\n          if (value.slice(0, 2) === \"::\") {\n            return\n          }\n\n          const name = value.slice(1)\n\n          if (matchesStringOrRegExp(postcss.vendor.unprefixed(name).toLowerCase(), whitelist)) {\n            return\n          }\n\n          report({\n            index: pseudoNode.sourceIndex,\n            message: messages.rejected(name),\n            node: rule,\n            result,\n            ruleName,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-element-case/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\n\nconst ruleName = \"selector-pseudo-element-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n      const startIndexPseudoElement = selector.indexOf(\":\")\n\n      if (startIndexPseudoElement === -1) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          const pseudoElement = pseudoNode.value\n\n          if (!isStandardSyntaxSelector(pseudoElement)) {\n            return\n          }\n\n          if (pseudoElement.indexOf(\"::\") === -1 && !keywordSets.levelOneAndTwoPseudoElements.has(pseudoElement.toLowerCase().slice(1))) {\n            return\n          }\n\n          const expectedPseudoElement = expectation === \"lower\" ? pseudoElement.toLowerCase() : pseudoElement.toUpperCase()\n\n          if (pseudoElement === expectedPseudoElement) {\n            return\n          }\n\n          report({\n            message: messages.expected(pseudoElement, expectedPseudoElement),\n            node: rule,\n            index: pseudoNode.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-element-colon-notation/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"selector-pseudo-element-colon-notation\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: q => `Expected ${q} colon pseudo-element notation`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"single\",\n        \"double\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      // get out early if no pseudo elements or classes\n      if (selector.indexOf(\":\") === -1) {\n        return\n      }\n\n      // match only level 1 and 2 pseudo elements\n      const pseudoElementsWithColons = _.toArray(keywordSets.levelOneAndTwoPseudoElements).map(x => `:${x}`)\n      styleSearch({ source: selector.toLowerCase(), target: pseudoElementsWithColons }, match => {\n        const prevCharIsColon = selector[match.startIndex - 1] === \":\"\n\n        if (expectation === \"single\" && !prevCharIsColon) {\n          return\n        }\n        if (expectation === \"double\" && prevCharIsColon) {\n          return\n        }\n\n        report({\n          message: messages.expected(expectation),\n          node: rule,\n          index: match.startIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-pseudo-element-no-unknown/index.js":"\"use strict\"\n\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"selector-pseudo-element-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: selector => `Unexpected unknown pseudo-element selector \"${selector}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignorePseudoElements: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      const selector = rule.selector\n\n      // Return early before parse if no pseudos for performance\n\n      if (selector.indexOf(\":\") === -1) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkPseudos(pseudoNode => {\n          const value = pseudoNode.value\n\n          if (!isStandardSyntaxSelector(value)) {\n            return\n          }\n\n          // Ignore pseudo-classes\n          if (value.slice(0, 2) !== \"::\") {\n            return\n          }\n\n          if (optionsMatches(options, \"ignorePseudoElements\", pseudoNode.value.slice(2))) {\n            return\n          }\n\n          const name = value.slice(2)\n\n          if (postcss.vendor.prefix(name) || keywordSets.pseudoElements.has(name.toLowerCase())) {\n            return\n          }\n\n          report({\n            message: messages.rejected(value),\n            node: rule,\n            index: pseudoNode.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-root-no-composition/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-root-no-composition\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected composition\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use the community 'stylelint-suitcss' plugin pack.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkRules(rule => {\n      if (rule.selector.toLowerCase().indexOf(\":root\") === -1 || rule.selector.toLowerCase().trim() === \":root\") {\n        return\n      }\n\n      report({\n        message: messages.rejected,\n        node: rule,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-type-case/index.js":"\"use strict\"\n\nconst isKeyframeSelector = require(\"../../utils/isKeyframeSelector\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst isStandardSyntaxTypeSelector = require(\"../../utils/isStandardSyntaxTypeSelector\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"selector-type-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      const selector = rule.selector,\n        selectors = rule.selectors\n\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      if (selectors.some(s => isKeyframeSelector(s))) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorAST => {\n        selectorAST.walkTags(tag => {\n          if (!isStandardSyntaxTypeSelector(tag)) {\n            return\n          }\n\n          const sourceIndex = tag.sourceIndex,\n            value = tag.value\n\n          const expectedValue = expectation === \"lower\" ? value.toLowerCase() : value.toUpperCase()\n\n          if (value === expectedValue) {\n            return\n          }\n\n          report({\n            message: messages.expected(value, expectedValue),\n            node: rule,\n            index: sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/selector-type-no-unknown/index.js":"\"use strict\"\n\nconst isKeyframeSelector = require(\"../../utils/isKeyframeSelector\")\nconst isStandardSyntaxRule = require(\"../../utils/isStandardSyntaxRule\")\nconst isStandardSyntaxSelector = require(\"../../utils/isStandardSyntaxSelector\")\nconst isStandardSyntaxTypeSelector = require(\"../../utils/isStandardSyntaxTypeSelector\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst parseSelector = require(\"../../utils/parseSelector\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst htmlTags = require(\"html-tags\")\nconst _ = require(\"lodash\")\nconst svgTags = require(\"svg-tags\")\n\nconst ruleName = \"selector-type-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: selector => `Unexpected unknown type selector \"${selector}\"`,\n})\n\n// htmlTags includes only \"standard\" tags. So we augment it with older tags etc.\nconst nonStandardHtmlTags = new Set([\n  \"acronym\",\n  \"applet\",\n  \"basefont\",\n  \"big\",\n  \"blink\",\n  \"center\",\n  \"content\",\n  \"dir\",\n  \"font\",\n  \"frame\",\n  \"frameset\",\n  \"hgroup\",\n  \"isindex\",\n  \"keygen\",\n  \"listing\",\n  \"marquee\",\n  \"noembed\",\n  \"plaintext\",\n  \"spacer\",\n  \"strike\",\n  \"tt\",\n  \"xmp\",\n])\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignore: [\n          \"default-namespace\",\n        ],\n        ignoreNamespaces: [_.isString],\n        ignoreTypes: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkRules(rule => {\n      const selector = rule.selector,\n        selectors = rule.selectors\n\n      if (!isStandardSyntaxRule(rule)) {\n        return\n      }\n      if (!isStandardSyntaxSelector(selector)) {\n        return\n      }\n      if (selectors.some(s => isKeyframeSelector(s))) {\n        return\n      }\n\n      parseSelector(selector, result, rule, selectorTree => {\n        selectorTree.walkTags(tagNode => {\n          if (!isStandardSyntaxTypeSelector(tagNode)) {\n            return\n          }\n\n          if (\n            optionsMatches(options, \"ignore\", \"default-namespace\")\n            && !tagNode.hasOwnProperty(\"namespace\")\n          ) {\n            return\n          }\n\n          if (optionsMatches(options, \"ignoreNamespaces\", tagNode.namespace)) {\n            return\n          }\n\n          if (optionsMatches(options, \"ignoreTypes\", tagNode.value)) {\n            return\n          }\n\n          const tagName = tagNode.value\n          const tagNameLowerCase = tagName.toLowerCase()\n\n          if (htmlTags.indexOf(tagNameLowerCase) !== -1 || svgTags.indexOf(tagNameLowerCase) !== -1 || nonStandardHtmlTags.has(tagNameLowerCase)) {\n            return\n          }\n\n          report({\n            message: messages.rejected(tagName),\n            node: rule,\n            index: tagNode.sourceIndex,\n            ruleName,\n            result,\n          })\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/shorthand-property-no-redundant-values/index.js":"\"use strict\"\n\nconst isStandardSyntaxDeclaration = require(\"../../utils/isStandardSyntaxDeclaration\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst shorthandData = require(\"../../reference/shorthandData\")\nconst valueParser = require(\"postcss-value-parser\")\nconst postcss = require(\"postcss\")\n\nconst ruleName = \"shorthand-property-no-redundant-values\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: (unexpected, expected) => `Unexpected longhand value '${unexpected}' instead of '${expected}'`,\n})\n\nconst shorthandableProperties = new Set(Object.keys(shorthandData))\n\nconst ignoredCharacters = [\n  \"+\",\n  \"-\",\n  \"*\",\n  \"/\",\n  \"(\",\n  \")\",\n  \"$\",\n  \"@\",\n  \"--\",\n  \"var(\",\n]\n\nconst ignoredShorthandProperties = new Set([\n  \"background\",\n  \"font\",\n  \"border\",\n  \"border-top\",\n  \"border-bottom\",\n  \"border-left\",\n  \"border-right\",\n  \"list-style\",\n  \"transition\",\n])\n\nfunction isIgnoredCharacters(value) {\n  return ignoredCharacters.some(char => value.indexOf(char) !== -1)\n}\n\nfunction canCondense(top, right) {\n  const bottom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null\n  const left = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null\n\n  const lowerTop = top.toLowerCase()\n  const lowerRight = right.toLowerCase()\n  const lowerBottom = bottom && bottom.toLowerCase()\n  const lowerLeft = left && left.toLowerCase()\n\n  if (canCondenseToOneValue(lowerTop, lowerRight, lowerBottom, lowerLeft)) {\n    return [top]\n  } else if (canCondenseToTwoValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {\n    return [\n      top,\n      right,\n    ]\n  } else if (canCondenseToThreeValues(lowerTop, lowerRight, lowerBottom, lowerLeft)) {\n    return [\n      top,\n      right,\n      bottom,\n    ]\n  } else {\n    return [\n      top,\n      right,\n      bottom,\n      left,\n    ]\n  }\n}\n\nfunction canCondenseToOneValue(top, right, bottom, left) {\n  if (top !== right) {\n    return false\n  }\n\n  return top === bottom && (bottom === left || !left) || !bottom && !left\n}\n\nfunction canCondenseToTwoValues(top, right, bottom, left) {\n  return top === bottom && right === left || top === bottom && !left && top !== right\n}\n\nfunction canCondenseToThreeValues(top, right, bottom, left) {\n  return right === left\n}\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {\n        return\n      }\n\n      const prop = decl.prop,\n        value = decl.value\n\n      const normalizedProp = postcss.vendor.unprefixed(prop.toLowerCase())\n\n      // Ignore not shorthandable properties, and math operations\n      if (isIgnoredCharacters(value) || !shorthandableProperties.has(normalizedProp) || ignoredShorthandProperties.has(normalizedProp)) {\n        return\n      }\n\n      const valuesToShorthand = []\n\n      valueParser(value).walk(valueNode => {\n        if (valueNode.type !== \"word\") {\n          return\n        }\n\n        valuesToShorthand.push(valueParser.stringify(valueNode))\n      })\n\n      if (valuesToShorthand.length <= 1 || valuesToShorthand.length > 4) {\n        return\n      }\n\n      const shortestForm = canCondense.apply(undefined, valuesToShorthand)\n      const shortestFormString = shortestForm.filter(value => {\n        return value\n      }).join(\" \")\n      const valuesFormString = valuesToShorthand.join(\" \")\n\n      if (shortestFormString.toLowerCase() === valuesFormString.toLowerCase()) {\n        return\n      }\n\n      report({\n        message: messages.rejected(value, shortestFormString),\n        node: decl,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/string-no-newline/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"string-no-newline\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: \"Unexpected newline in string\",\n})\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    const cssString = root.toString()\n    styleSearch({\n      source: cssString,\n      target: \"\\n\",\n      strings: \"only\",\n    }, match => {\n      const charBefore = cssString[match.startIndex - 1]\n      let index = match.startIndex\n      if (charBefore === \"\\\\\") {\n        return\n      }\n      if (charBefore === \"\\r\") index -= 1\n      report({\n        message: messages.rejected,\n        node: root,\n        index,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/string-quotes/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"string-quotes\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: q => `Expected ${q} quotes`,\n})\n\nconst rule = function (expectation) {\n  const erroneousQuote = expectation === \"single\" ? \"\\\"\" : \"'\"\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"single\",\n        \"double\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    const cssString = root.toString()\n    styleSearch({ source: cssString, target: erroneousQuote }, match => {\n      report({\n        message: messages.expected(expectation),\n        node: root,\n        index: match.startIndex,\n        result,\n        ruleName,\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/stylelint-disable-reason/index.js":"\"use strict\"\n\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\n\nconst ruleName = \"stylelint-disable-reason\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: \"Expected comment reason before `stylelint-disable` comment\",\n  expectedAfter: \"Expected comment reason after `stylelint-disable` comment\",\n})\n\nconst stylelintDisableCommand = \"stylelint-disable\"\nconst stylelintDisableLineCommand = \"stylelint-disable-line\"\n\nconst rule = function (expectation) {\n  return function (root, result) {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always-before\",\n        \"always-after\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkComments(function (comment) {\n      if (comment.text.indexOf(stylelintDisableCommand) !== 0) {\n        return\n      }\n\n      if (expectation === \"always-before\") {\n        const prev = comment.prev()\n        const prevIsCommentAndValid = prev && prev.type === \"comment\" && !isDisableCommand(prev.text)\n\n        let prevDisableLineIsCommentAndValid = false\n\n        if (comment.text.indexOf(stylelintDisableLineCommand) === 0 && !prevIsCommentAndValid && prev) {\n          const friendlyPrev = prev.prev()\n\n          prevDisableLineIsCommentAndValid = friendlyPrev && friendlyPrev.type === \"comment\" && !isDisableCommand(friendlyPrev.text)\n        }\n\n        if (!prevIsCommentAndValid && !prevDisableLineIsCommentAndValid) {\n          const disabledRanges = result.stylelint.disabledRanges\n          result.stylelint.disabledRanges = false\n\n          report({\n            message: messages.expectedBefore,\n            node: comment,\n            result,\n            ruleName,\n          })\n          result.stylelint.disabledRanges = disabledRanges\n        }\n      } else if (expectation === \"always-after\") {\n        const next = comment.next()\n        const nextIsCommentAndValid = next && next.type === \"comment\" && !isDisableCommand(next.text)\n\n        if (!nextIsCommentAndValid) {\n          const disabledRanges = result.stylelint.disabledRanges\n          result.stylelint.disabledRanges = false\n\n          report({\n            message: messages.expectedAfter,\n            node: comment,\n            result,\n            ruleName,\n          })\n          result.stylelint.disabledRanges = disabledRanges\n        }\n      }\n    })\n\n    function isDisableCommand(text) {\n      return text.indexOf(stylelintDisableCommand) === 0\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/time-min-milliseconds/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst postcss = require(\"postcss\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"time-min-milliseconds\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: time => `Expected a minimum of ${time} milliseconds`,\n})\n\nconst rule = function (minimum) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: minimum,\n      possible: _.isNumber,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const propertyName = postcss.vendor.unprefixed(decl.prop.toLowerCase())\n\n      if (\n        keywordSets.longhandTimeProperties.has(propertyName)\n        && !isAcceptableTime(decl.value)\n      ) {\n        complain(decl)\n      }\n\n      if (keywordSets.shorthandTimeProperties.has(propertyName)) {\n        const valueList = postcss.list.space(decl.value)\n\n        for (const value of valueList) {\n          if (!isAcceptableTime(value)) {\n            complain(decl, decl.value.indexOf(value))\n          }\n        }\n      }\n    })\n\n    function isAcceptableTime(time) {\n      const parsedTime = valueParser.unit(time)\n\n      if (!parsedTime) return true\n\n      if (parsedTime.number <= 0) {\n        return true\n      }\n\n      if (parsedTime.unit.toLowerCase() === \"ms\" && parsedTime.number < minimum) {\n        return false\n      }\n\n      if (parsedTime.unit.toLowerCase() === \"s\" && parsedTime.number * 1000 < minimum) {\n        return false\n      }\n\n      return true\n    }\n\n    function complain(decl, offset) {\n      offset = offset || 0\n\n      report({\n        result,\n        ruleName,\n        message: messages.expected(minimum),\n        index: declarationValueIndex(decl) + offset,\n        node: decl,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/time-no-imperceptible/index.js":"\"use strict\"\n\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst postcss = require(\"postcss\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"time-no-imperceptible\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: time => `Unexpected time value \"${time}\" less than or equal to 100ms`,\n})\n\nconst MINIMUM_MILLISECONDS = 100\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    result.warn((\n      `'${ruleName}' has been deprecated and in 8.0 will be removed. Instead use 'time-min-milliseconds' with '100' as its primary option.`\n    ), {\n      stylelintType: \"deprecation\",\n      stylelintReference: `https://stylelint.io/user-guide/rules/${ruleName}/`,\n    })\n\n    root.walkDecls(decl => {\n      if (keywordSets.longhandTimeProperties.has(postcss.vendor.unprefixed(decl.prop.toLowerCase()))) {\n        if (isImperceptibleTime(decl.value)) {\n          complain(messages.rejected(decl.value), decl)\n        }\n      }\n\n      if (keywordSets.shorthandTimeProperties.has(postcss.vendor.unprefixed(decl.prop.toLowerCase()))) {\n        const valueList = postcss.list.space(decl.value)\n        for (const value of valueList) {\n          if (isImperceptibleTime(value)) {\n            complain(messages.rejected(value), decl, decl.value.indexOf(value))\n          }\n        }\n      }\n    })\n\n    function isImperceptibleTime(time) {\n      const parsedTime = valueParser.unit(time)\n      if (!parsedTime) return false\n      const absoluteTime = Math.abs(parsedTime.number)\n      if (parsedTime.unit.toLowerCase() === \"ms\" && absoluteTime <= MINIMUM_MILLISECONDS) {\n        return true\n      }\n      if (parsedTime.unit.toLowerCase() === \"s\" && absoluteTime * 1000 <= MINIMUM_MILLISECONDS) {\n        return true\n      }\n      return false\n    }\n\n    function complain(message, decl) {\n      const offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0\n\n      report({\n        result,\n        ruleName,\n        message,\n        index: declarationValueIndex(decl) + offset,\n        node: decl,\n      })\n    }\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/unit-blacklist/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst validateObjectWithStringArrayProps = require(\"../../utils/validateObjectWithStringArrayProps\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"unit-blacklist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: unit => `Unexpected unit \"${unit}\"`,\n})\n\nconst rule = function (blacklistInput, options) {\n  const blacklist = [].concat(blacklistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: blacklist,\n      possible: [_.isString],\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignoreProperties: validateObjectWithStringArrayProps,\n      },\n    })\n    if (!validOptions) {\n      return\n    }\n\n    function check(node, value, getIndex) {\n      valueParser(value).walk(function (valueNode) {\n        // Ignore wrong units within `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        const unit = getUnitFromValueNode(valueNode)\n\n        if (!unit || unit && blacklist.indexOf(unit.toLowerCase()) === -1) {\n          return\n        }\n\n        if (options && optionsMatches(options.ignoreProperties, unit.toLowerCase(), node.prop)) {\n          return\n        }\n\n        report({\n          index: getIndex(node) + valueNode.sourceIndex,\n          message: messages.rejected(unit),\n          node,\n          result,\n          ruleName,\n        })\n      })\n    }\n\n    root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex))\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/validateObjectWithStringArrayProps.js":"/* @flow */\n\"use strict\"\n\nconst _ = require(\"lodash\")\n\n/**\n * Check whether the variable is an object and all it's properties are arrays of string values:\n *\n * ignoreProperties = {\n *   value1: [\"item11\", \"item12\", \"item13\"],\n *   value2: [\"item21\", \"item22\", \"item23\"],\n *   value3: [\"item31\", \"item32\", \"item33\"],\n * }\n */\n\nmodule.exports = function (value/*: Object*/)/*: boolean*/ {\n  if (!_.isPlainObject(value)) {\n    return false\n  }\n\n  return Object.keys(value).every(key => {\n    if (!_.isArray(value[key])) {\n      return false\n    }\n\n    // Make sure the array items are strings\n    return value[key].every(item => _.isString(item))\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/unit-case/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"unit-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\nconst rule = function (expectation) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    function check(node, value, getIndex) {\n      valueParser(value).walk(valueNode => {\n        // Ignore wrong units within `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        const unit = getUnitFromValueNode(valueNode)\n\n        if (!unit) {\n          return\n        }\n\n        const expectedUnit = expectation === \"lower\" ? unit.toLowerCase() : unit.toUpperCase()\n\n        if (unit === expectedUnit) {\n          return\n        }\n\n        report({\n          index: getIndex(node) + valueNode.sourceIndex,\n          message: messages.expected(unit, expectedUnit),\n          node,\n          result,\n          ruleName,\n        })\n      })\n    }\n\n    root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex))\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/unit-no-unknown/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"unit-no-unknown\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: unit => `Unexpected unknown unit \"${unit}\"`,\n})\n\nconst rule = function (actual, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual }, {\n      actual: options,\n      possible: {\n        ignoreUnits: [_.isString],\n      },\n      optional: true,\n    })\n\n    if (!validOptions) {\n      return\n    }\n\n    function check(node, value, getIndex) {\n      valueParser(value).walk(function (valueNode) {\n        // Ignore wrong units within `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        const unit = getUnitFromValueNode(valueNode)\n        if (!unit) {\n          return\n        }\n\n        if (optionsMatches(options, \"ignoreUnits\", unit)) {\n          return\n        }\n\n        if (keywordSets.units.has(unit.toLowerCase())) {\n          return\n        }\n\n        report({\n          index: getIndex(node) + valueNode.sourceIndex,\n          message: messages.rejected(unit),\n          node,\n          result,\n          ruleName,\n        })\n      })\n    }\n\n    root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex))\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/unit-whitelist/index.js":"\"use strict\"\n\nconst atRuleParamIndex = require(\"../../utils/atRuleParamIndex\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst optionsMatches = require(\"../../utils/optionsMatches\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst validateObjectWithStringArrayProps = require(\"../../utils/validateObjectWithStringArrayProps\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"unit-whitelist\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: unit => `Unexpected unit \"${unit}\"`,\n})\n\nconst rule = function (whitelistInput, options) {\n  const whitelist = [].concat(whitelistInput)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: whitelist,\n      possible: [_.isString],\n    }, {\n      optional: true,\n      actual: options,\n      possible: {\n        ignoreProperties: validateObjectWithStringArrayProps,\n      },\n    })\n    if (!validOptions) {\n      return\n    }\n\n    function check(node, value, getIndex) {\n      valueParser(value).walk(function (valueNode) {\n        // Ignore wrong units within `url` function\n        if (valueNode.type === \"function\" && valueNode.value.toLowerCase() === \"url\") {\n          return false\n        }\n\n        const unit = getUnitFromValueNode(valueNode)\n\n        if (!unit || unit && whitelist.indexOf(unit.toLowerCase()) !== -1) {\n          return\n        }\n\n        if (options && optionsMatches(options[\"ignoreProperties\"], unit.toLowerCase(), node.prop)) {\n          return\n        }\n\n        report({\n          index: getIndex(node) + valueNode.sourceIndex,\n          message: messages.rejected(unit),\n          node,\n          result,\n          ruleName,\n        })\n      })\n    }\n\n    root.walkAtRules(/^media$/i, atRule => check(atRule, atRule.params, atRuleParamIndex))\n    root.walkDecls(decl => check(decl, decl.value, declarationValueIndex))\n  }\n}\n\nrule.primaryOptionArray = true\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-keyword-case/index.js":"\"use strict\"\n\nconst keywordSets = require(\"../../reference/keywordSets\")\nconst declarationValueIndex = require(\"../../utils/declarationValueIndex\")\nconst getUnitFromValueNode = require(\"../../utils/getUnitFromValueNode\")\nconst isCounterIncrementCustomIdentValue = require(\"../../utils/isCounterIncrementCustomIdentValue\")\nconst isCounterResetCustomIdentValue = require(\"../../utils/isCounterResetCustomIdentValue\")\nconst isStandardSyntaxValue = require(\"../../utils/isStandardSyntaxValue\")\nconst matchesStringOrRegExp = require(\"../../utils/matchesStringOrRegExp\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst _ = require(\"lodash\")\nconst valueParser = require(\"postcss-value-parser\")\n\nconst ruleName = \"value-keyword-case\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: (actual, expected) => `Expected \"${actual}\" to be \"${expected}\"`,\n})\n\n// Operators are interpreted as \"words\" by the value parser, so we want to make sure to ignore them.\nconst ignoredCharacters = new Set([\n  \"+\",\n  \"-\",\n  \"/\",\n  \"*\",\n  \"%\",\n])\n\nconst mapLowercaseKeywordsToCamelCase = new Map()\nkeywordSets.camelCaseKeywords.forEach(func => {\n  mapLowercaseKeywordsToCamelCase.set(func.toLowerCase(), func)\n})\n\nconst rule = function (expectation, options) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"lower\",\n        \"upper\",\n      ],\n    }, {\n      actual: options,\n      possible: {\n        ignoreKeywords: [_.isString],\n      },\n      optional: true,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const prop = decl.prop,\n        value = decl.value\n\n      valueParser(value).walk(node => {\n        const valueLowerCase = node.value.toLowerCase()\n\n        // Ignore system colors\n        if (keywordSets.systemColors.has(valueLowerCase)) {\n          return\n        }\n\n        // Ignore keywords within `url` and `var` function\n        if (node.type === \"function\" && (valueLowerCase === \"url\" || valueLowerCase === \"var\" || valueLowerCase === \"counter\" || valueLowerCase === \"counters\" || valueLowerCase === \"attr\")) {\n          return false\n        }\n\n        const keyword = node.value\n\n        // Ignore css variables, and hex values, and math operators, and sass interpolation\n        if (node.type !== \"word\" || !isStandardSyntaxValue(node.value) || value.indexOf(\"#\") !== -1 || ignoredCharacters.has(keyword) || getUnitFromValueNode(node)) {\n          return\n        }\n\n        if (prop === \"animation\" && !keywordSets.animationShorthandKeywords.has(valueLowerCase) && !keywordSets.animationNameKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"animation-name\" && !keywordSets.animationNameKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"font\" && !keywordSets.fontShorthandKeywords.has(valueLowerCase) && !keywordSets.fontFamilyKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"font-family\" && !keywordSets.fontFamilyKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"counter-increment\" && isCounterIncrementCustomIdentValue(valueLowerCase)) {\n          return\n        }\n        if (prop === \"counter-reset\" && isCounterResetCustomIdentValue(valueLowerCase)) {\n          return\n        }\n        if (prop === \"grid-row\" && !keywordSets.gridRowKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"grid-column\" && !keywordSets.gridColumnKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"grid-area\" && !keywordSets.gridAreaKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"list-style\" && !keywordSets.listStyleShorthandKeywords.has(valueLowerCase) && !keywordSets.listStyleTypeKeywords.has(valueLowerCase)) {\n          return\n        }\n        if (prop === \"list-style-type\" && !keywordSets.listStyleTypeKeywords.has(valueLowerCase)) {\n          return\n        }\n\n        const ignoreKeywords = options && options.ignoreKeywords || []\n\n        if (ignoreKeywords.length > 0 && matchesStringOrRegExp(keyword, ignoreKeywords)) {\n          return\n        }\n\n        const keywordLowerCase = keyword.toLocaleLowerCase()\n        let expectedKeyword = null\n\n        if (expectation === \"lower\" && mapLowercaseKeywordsToCamelCase.has(keywordLowerCase)) {\n          expectedKeyword = mapLowercaseKeywordsToCamelCase.get(keywordLowerCase)\n        } else if (expectation === \"lower\") {\n          expectedKeyword = keyword.toLowerCase()\n        } else {\n          expectedKeyword = keyword.toUpperCase()\n        }\n\n        if (keyword === expectedKeyword) {\n          return\n        }\n\n        report({\n          message: messages.expected(keyword, expectedKeyword),\n          node: decl,\n          index: declarationValueIndex(decl) + node.sourceIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isCounterIncrementCustomIdentValue.js":"/* @flow */\n\"use strict\"\n\nconst keywordSets = require(\"../reference/keywordSets\")\nconst _ = require(\"lodash\")\n\n/**\n * Check value is a custom ident\n */\n\nmodule.exports = function (value/*: string*/)/*: boolean*/ {\n  const valueLowerCase = value.toLowerCase()\n\n  if (keywordSets.counterIncrementKeywords.has(valueLowerCase) || _.isFinite(parseInt(valueLowerCase))) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/isCounterResetCustomIdentValue.js":"/* @flow */\n\"use strict\"\n\nconst keywordSets = require(\"../reference/keywordSets\")\nconst _ = require(\"lodash\")\n\n/**\n * Check value is a custom ident\n */\n\nmodule.exports = function (value/*: string*/)/*: boolean*/ {\n  const valueLowerCase = value.toLowerCase()\n\n  if (keywordSets.counterResetKeywords.has(valueLowerCase) || _.isFinite(parseInt(valueLowerCase))) {\n    return false\n  }\n\n  return true\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-list-comma-newline-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst valueListCommaWhitespaceChecker = require(\"../valueListCommaWhitespaceChecker\")\n\nconst ruleName = \"value-list-comma-newline-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected newline after \\\",\\\"\",\n  expectedAfterMultiLine: () => \"Expected newline after \\\",\\\" in a multi-line list\",\n  rejectedAfterMultiLine: () => \"Unexpected whitespace after \\\",\\\" in a multi-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    valueListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.afterOneOnly,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/valueListCommaWhitespaceChecker.js":"\"use strict\"\n\nconst isStandardSyntaxDeclaration = require(\"../utils/isStandardSyntaxDeclaration\")\nconst isStandardSyntaxProperty = require(\"../utils/isStandardSyntaxProperty\")\nconst report = require(\"../utils/report\")\nconst styleSearch = require(\"style-search\")\n\nmodule.exports = function (opts) {\n  opts.root.walkDecls(decl => {\n    if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop)) {\n      return\n    }\n    styleSearch({\n      source: decl.toString(),\n      target: \",\",\n      functionArguments: \"skip\",\n    }, match => {\n      checkComma(decl.toString(), match.startIndex, decl)\n    })\n  })\n\n  function checkComma(source, index, node) {\n    opts.locationChecker({\n      source,\n      index,\n      err: m => {\n        report({\n          message: m,\n          node,\n          index,\n          result: opts.result,\n          ruleName: opts.checkedRuleName,\n        })\n      },\n    })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-list-comma-newline-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst valueListCommaWhitespaceChecker = require(\"../valueListCommaWhitespaceChecker\")\n\nconst ruleName = \"value-list-comma-newline-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected newline before \\\",\\\"\",\n  expectedBeforeMultiLine: () => \"Expected newline before \\\",\\\" in a multi-line list\",\n  rejectedBeforeMultiLine: () => \"Unexpected whitespace before \\\",\\\" in a multi-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"newline\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"always-multi-line\",\n        \"never-multi-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    valueListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.beforeAllowingIndentation,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-list-comma-space-after/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst valueListCommaWhitespaceChecker = require(\"../valueListCommaWhitespaceChecker\")\n\nconst ruleName = \"value-list-comma-space-after\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedAfter: () => \"Expected single space after \\\",\\\"\",\n  rejectedAfter: () => \"Unexpected whitespace after \\\",\\\"\",\n  expectedAfterSingleLine: () => \"Expected single space after \\\",\\\" in a single-line list\",\n  rejectedAfterSingleLine: () => \"Unexpected whitespace after \\\",\\\" in a single-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    valueListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.after,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-list-comma-space-before/index.js":"\"use strict\"\n\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst whitespaceChecker = require(\"../../utils/whitespaceChecker\")\nconst valueListCommaWhitespaceChecker = require(\"../valueListCommaWhitespaceChecker\")\n\nconst ruleName = \"value-list-comma-space-before\"\n\nconst messages = ruleMessages(ruleName, {\n  expectedBefore: () => \"Expected single space before \\\",\\\"\",\n  rejectedBefore: () => \"Unexpected whitespace before \\\",\\\"\",\n  expectedBeforeSingleLine: () => \"Unexpected whitespace before \\\",\\\" in a single-line list\",\n  rejectedBeforeSingleLine: () => \"Unexpected whitespace before \\\",\\\" in a single-line list\",\n})\n\nconst rule = function (expectation) {\n  const checker = whitespaceChecker(\"space\", expectation, messages)\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: expectation,\n      possible: [\n        \"always\",\n        \"never\",\n        \"always-single-line\",\n        \"never-single-line\",\n      ],\n    })\n    if (!validOptions) {\n      return\n    }\n\n    valueListCommaWhitespaceChecker({\n      root,\n      result,\n      locationChecker: checker.before,\n      checkedRuleName: ruleName,\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-list-max-empty-lines/index.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"value-list-max-empty-lines\"\n\nconst messages = ruleMessages(ruleName, {\n  expected: max => `Expected no more than ${max} empty line(s)`,\n})\n\nconst rule = function (max) {\n  const maxAdjacentNewlines = max + 1\n\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, {\n      actual: max,\n      possible: _.isNumber,\n    })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      const value = decl.value\n      const repeatLFNewLines = _.repeat(\"\\n\", maxAdjacentNewlines)\n      const repeatCRLFNewLines = _.repeat(\"\\r\\n\", maxAdjacentNewlines)\n\n      styleSearch({ source: value, target: \"\\n\" }, match => {\n        if (value.substr(match.startIndex + 1, maxAdjacentNewlines) === repeatLFNewLines || value.substr(match.startIndex + 1, maxAdjacentNewlines * 2) === repeatCRLFNewLines) {\n          // Put index at `\\r` if it's CRLF, otherwise leave it at `\\n`\n          let index = match.startIndex\n          if (value[index - 1] === \"\\r\") {\n            index -= 1\n          }\n\n          report({\n            message: messages.expected(max),\n            node: decl,\n            index,\n            result,\n            ruleName,\n          })\n        }\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/rules/value-no-vendor-prefix/index.js":"\"use strict\"\n\nconst isAutoprefixable = require(\"../../utils/isAutoprefixable\")\nconst isStandardSyntaxDeclaration = require(\"../../utils/isStandardSyntaxDeclaration\")\nconst isStandardSyntaxProperty = require(\"../../utils/isStandardSyntaxProperty\")\nconst report = require(\"../../utils/report\")\nconst ruleMessages = require(\"../../utils/ruleMessages\")\nconst validateOptions = require(\"../../utils/validateOptions\")\nconst styleSearch = require(\"style-search\")\n\nconst ruleName = \"value-no-vendor-prefix\"\n\nconst messages = ruleMessages(ruleName, {\n  rejected: value => `Unexpected vendor-prefix \"${value}\"`,\n})\n\nconst valuePrefixes = [\n  \"-webkit-\",\n  \"-moz-\",\n  \"-ms-\",\n  \"-o-\",\n]\n\nconst rule = function (actual) {\n  return (root, result) => {\n    const validOptions = validateOptions(result, ruleName, { actual })\n    if (!validOptions) {\n      return\n    }\n\n    root.walkDecls(decl => {\n      if (!isStandardSyntaxDeclaration(decl) || !isStandardSyntaxProperty(decl.prop) || decl.value[0] !== \"-\") {\n        return\n      }\n\n      const prop = decl.prop,\n        value = decl.value\n\n      // Search the full declaration in order to get an accurate index\n\n      styleSearch({ source: value.toLowerCase(), target: valuePrefixes }, match => {\n        const fullIdentifier = /^(-[a-z-]+)\\b/i.exec(value.slice(match.startIndex))[1]\n        if (!isAutoprefixable.propertyValue(prop, fullIdentifier)) {\n          return\n        }\n\n        report({\n          message: messages.rejected(fullIdentifier),\n          node: decl,\n          index: prop.length + (decl.raws.between || \"\").length + match.startIndex,\n          result,\n          ruleName,\n        })\n      })\n    })\n  }\n}\n\nrule.ruleName = ruleName\nrule.messages = messages\nmodule.exports = rule\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/createPlugin.js":"\"use strict\"\n\nmodule.exports = function (ruleName, rule) {\n  return {\n    ruleName,\n    rule,\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/testUtils/createRuleTester.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst assignDisabledRanges = require(\"../assignDisabledRanges\")\nconst basicChecks = require(\"./basicChecks\")\nconst lessSyntax = require(\"postcss-less\")\nconst normalizeRuleSettings = require(\"../normalizeRuleSettings\")\nconst postcss = require(\"postcss\")\nconst scssSyntax = require(\"postcss-scss\")\nconst sugarss = require(\"sugarss\")\n\n/**\n * Create a stylelint rule testing function.\n *\n * Pass in an `equalityCheck` function. Given some information,\n * this checker should use Whatever Test Runner to perform\n * equality checks.\n *\n * `equalityCheck` should accept two arguments:\n * - `processCss` {Promise}: A Promise that resolves with an array of\n *   comparisons that you need to check (documented below).\n * - `context` {object}: An object that contains additional information\n *   you may need:\n *   - `caseDescription` {string}: A description of the test case as a whole.\n *   \t Will look like this:\n *   \t   > rule: value-list-comma-space-before\n *   \t   > config: \"always-single-line\"\n *   \t   > code: \"a { background-size: 0 ,0;\\n}\"\n *   - `comparisonCount` {number}: The number of comparisons that\n *     will need to be performed (e.g. useful for tape).\n *   - `completeAssertionDescription` {string}: While each individual\n *   \t comparison may have its own description, this is a description\n *   \t of the whole assertion (e.g. useful for Mocha).\n *   - `only` {boolean}: If `true`, the test runner should only run this\n *     test case (e.g. `test.only` in tape, `describe.only` in Mocha).\n *\n * `processCss` is a Promsie that resolves with an array of comparisons.\n * Each comparison has the following properties:\n * - `actual` {any}: Some actual value.\n * - `expected` {any}: Some expected value.\n * - `description` {string}: A (possibly empty) description of the comparison.\n *\n * Within `equalityCheck`, you need to ensure that you:\n * - Set up the test case.\n * - When `processCss` resolves, loop through every comparison.\n * - For each comparison, make an assertion checking that `actual === expected`.\n *\n * The `testRule` function that you get has a simple signature:\n * `testRule(rule, testGroupDescription)`.\n *\n * `rule` is just the rule that you are testing (a function).\n *\n * `testGroupDescription` is an object fitting the following schema.\n *\n * Required properties:\n * - `ruleName` {string}: The name of the rule. Used in descriptions.\n * - `config` {any}: The rule's configuration for this test group.\n *   Should match the format you'd use in `.stylelintrc`.\n * - `accept` {array}: An array of objects describing test cases that\n *   should not violate the rule. Each object has these properties:\n *   - `code` {string}: The source CSS to check.\n *   - `description` {[string]}: An optional description of the case.\n * - `reject` {array}: An array of objects describing test cases that\n *   should violate the rule once. Each object has these properties:\n *   - `code` {string}: The source CSS to check.\n *   - `message` {string}: The message of the expected violation.\n *   - `line` {[number]}: The expected line number of the violation.\n *     If this is left out, the line won't be checked.\n *   - `column` {[number]}: The expected column number of the violation.\n *     If this is left out, the column won't be checked.\n *   - `description` {[string]}: An optional description of the case.\n *\n * Optional properties:\n * - `syntax` {\"css\"|\"scss\"|\"less\"|\"sugarss\"}: Defaults to `\"css\"`.\n * - `skipBasicChecks` {boolean}: Defaults to `false`. If `true`, a\n *   few rudimentary checks (that should almost always be included)\n *   will not be performed.\n * - `preceedingPlugins` {array}: An array of PostCSS plugins that\n *   should be run before the CSS is tested.\n *\n * @param {function} equalityCheck - Described above\n * @return {function} testRule - Decsribed above\n */\nlet onlyTest\n\nfunction checkCaseForOnly(caseType, testCase) {\n  if (!testCase.only) {\n    return\n  }\n  /* istanbul ignore next */\n  if (onlyTest) {\n    throw new Error(\"Cannot use `only` on multiple test cases\")\n  }\n  onlyTest = { case: testCase, type: caseType }\n}\n\nmodule.exports = function (equalityCheck) {\n  return function (rule, schema) {\n    const alreadyHadOnlyTest = !!onlyTest\n    if (schema.accept) {\n      schema.accept.forEach(_.partial(checkCaseForOnly, \"accept\"))\n    }\n\n    if (schema.reject) {\n      schema.reject.forEach(_.partial(checkCaseForOnly, \"reject\"))\n    }\n\n    if (onlyTest) {\n      schema = _.assign(_.omit(schema, [ \"accept\", \"reject\" ]), {\n        skipBasicChecks: true,\n        [onlyTest.type]: [onlyTest.case],\n      })\n    }\n\n    if (!alreadyHadOnlyTest) {\n      process.nextTick(() => {\n        processGroup(rule, schema, equalityCheck)\n      })\n    }\n  }\n}\n\nfunction processGroup(rule, schema, equalityCheck) {\n  const ruleName = schema.ruleName\n\n  const ruleOptions = normalizeRuleSettings(schema.config, ruleName)\n  const rulePrimaryOptions = ruleOptions[0]\n  const ruleSecondaryOptions = ruleOptions[1]\n\n  let printableConfig = rulePrimaryOptions ? JSON.stringify(rulePrimaryOptions) : \"\"\n  if (printableConfig && ruleSecondaryOptions) {\n    printableConfig += \", \" + JSON.stringify(ruleSecondaryOptions)\n  }\n\n  function createCaseDescription(code) {\n    let text = `\\n> rule: ${ruleName}\\n`\n    text += `> config: ${printableConfig}\\n`\n    text += `> code: ${JSON.stringify(code)}\\n`\n    return text\n  }\n\n  // Process the code through the rule and return\n  // the PostCSS LazyResult promise\n  function postcssProcess(code) {\n    const postcssProcessOptions = {}\n\n    switch (schema.syntax) {\n      case \"scss\":\n        postcssProcessOptions.syntax = scssSyntax\n        break\n      case \"less\":\n        postcssProcessOptions.syntax = lessSyntax\n        break\n      case \"sugarss\":\n        postcssProcessOptions.syntax = sugarss\n        break\n    }\n\n    const processor = postcss()\n    processor.use(assignDisabledRanges)\n\n    if (schema.preceedingPlugins) {\n      schema.preceedingPlugins.forEach(plugin => processor.use(plugin))\n    }\n\n    return processor.use(rule(rulePrimaryOptions, ruleSecondaryOptions)).process(code, postcssProcessOptions)\n  }\n\n  // Apply the basic positive checks unless\n  // explicitly told not to\n  const passingTestCases = schema.skipBasicChecks ? schema.accept : basicChecks.concat(schema.accept)\n\n  if (passingTestCases && passingTestCases.length) {\n    passingTestCases.forEach(acceptedCase => {\n      if (!acceptedCase) {\n        return\n      }\n      const assertionDescription = spaceJoin(acceptedCase.description, \"should be accepted\")\n      const resultPromise = postcssProcess(acceptedCase.code).then(postcssResult => {\n        const warnings = postcssResult.warnings()\n        return [{\n          expected: 0,\n          actual: warnings.length,\n          description: assertionDescription,\n        }]\n      }).catch(err => console.log(err.stack)) // eslint-disable-line no-console\n\n      equalityCheck(resultPromise, {\n        comparisonCount: 1,\n        caseDescription: createCaseDescription(acceptedCase.code),\n        completeAssertionDescription: assertionDescription,\n      })\n    })\n  }\n\n  if (schema.reject && schema.reject.length) {\n    schema.reject.forEach(rejectedCase => {\n      let completeAssertionDescription = \"should register one warning\"\n      let comparisonCount = 1\n      if (rejectedCase.line) {\n        comparisonCount++\n        completeAssertionDescription += ` on line ${rejectedCase.line}`\n      }\n      if (rejectedCase.column !== undefined) {\n        comparisonCount++\n        completeAssertionDescription += ` on column ${rejectedCase.column}`\n      }\n      if (rejectedCase.message) {\n        comparisonCount++\n        completeAssertionDescription += ` with message \"${rejectedCase.message}\"`\n      }\n\n      const resultPromise = postcssProcess(rejectedCase.code).then(postcssResult => {\n        const warnings = postcssResult.warnings()\n        const warning = warnings[0]\n\n        const comparisons = [{\n          expected: 1,\n          actual: warnings.length,\n          description: spaceJoin(rejectedCase.description, \"should register one warning\"),\n        }]\n\n        if (rejectedCase.line) {\n          comparisons.push({\n            expected: rejectedCase.line,\n            actual: _.get(warning, \"line\"),\n            description: spaceJoin(rejectedCase.description, `should warn on line ${rejectedCase.line}`),\n          })\n        }\n        if (rejectedCase.column !== undefined) {\n          comparisons.push({\n            expected: rejectedCase.column,\n            actual: _.get(warning, \"column\"),\n            description: spaceJoin(rejectedCase.description, `should warn on column ${rejectedCase.column}`),\n          })\n        }\n        if (rejectedCase.message) {\n          comparisons.push({\n            expected: rejectedCase.message,\n            actual: _.get(warning, \"text\"),\n            description: spaceJoin(rejectedCase.description, `should warn with message ${rejectedCase.message}`),\n          })\n        }\n        return comparisons\n      }).catch(err => console.log(err.stack)) // eslint-disable-line no-console\n\n      equalityCheck(resultPromise, {\n        comparisonCount,\n        completeAssertionDescription,\n        caseDescription: createCaseDescription(rejectedCase.code),\n        only: rejectedCase.only,\n      })\n    })\n  }\n}\n\nfunction spaceJoin() {\n  return _.compact(Array.from(arguments)).join(\" \")\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/assignDisabledRanges.js":"/* @flow */\n\"use strict\"\nconst _ = require(\"lodash\")\n\nconst COMMAND_PREFIX = \"stylelint-\"\nconst disableCommand = COMMAND_PREFIX + \"disable\"\nconst enableCommand = COMMAND_PREFIX + \"enable\"\nconst disableLineCommand = COMMAND_PREFIX + \"disable-line\"\nconst disableNextLineCommand = COMMAND_PREFIX + \"disable-next-line\"\nconst ALL_RULES = \"all\"\n\n/*:: type disabledRangeObject = {\n  [ruleName: string]: Array<{\n    start: number,\n    end?: number,\n  }>\n}*/\n\n// Run it like a plugin ...\nmodule.exports = function (\n  root/*: Object*/,\n  result/*: Object*/\n)/*: postcss$result*/ {\n  result.stylelint = result.stylelint || {}\n\n  // Most of the functions below work via side effects mutating\n  // this object\n  const disabledRanges/*: disabledRangeObject*/ = {\n    all: [],\n  }\n  result.stylelint.disabledRanges = disabledRanges\n  root.walkComments(checkComment)\n\n  return result\n\n  function processDisableLineCommand(comment/*: postcss$comment*/) {\n    getCommandRules(disableLineCommand, comment.text).forEach(ruleName => {\n      disableLine(comment.source.start.line, ruleName, comment)\n    })\n  }\n\n  function processDisableNextLineCommand(comment/*: postcss$comment*/) {\n    getCommandRules(disableNextLineCommand, comment.text).forEach(ruleName => {\n      disableLine(comment.source.start.line + 1, ruleName, comment)\n    })\n  }\n\n  function disableLine(\n    line/*: number*/,\n    ruleName/*: string*/,\n    comment/*: postcss$comment*/\n  ) {\n    if (ruleIsDisabled(ALL_RULES)) {\n      throw comment.error(\"All rules have already been disabled\", { plugin: \"stylelint\" })\n    }\n    if (ruleIsDisabled(ruleName)) {\n      throw comment.error(`\"${ruleName}\" has already been disabled`, { plugin: \"stylelint\" })\n    }\n    if (ruleName === ALL_RULES) {\n      Object.keys(disabledRanges).forEach(disabledRuleName => {\n        startDisabledRange(line, disabledRuleName)\n        endDisabledRange(line, disabledRuleName)\n      })\n    } else {\n      startDisabledRange(line, ruleName)\n      endDisabledRange(line, ruleName)\n    }\n  }\n\n  function processDisableCommand(comment/*: postcss$comment*/) {\n    getCommandRules(disableCommand, comment.text).forEach(ruleToDisable => {\n      if (ruleToDisable === ALL_RULES) {\n        if (ruleIsDisabled(ALL_RULES)) {\n          throw comment.error(\"All rules have already been disabled\", { plugin: \"stylelint\" })\n        }\n        Object.keys(disabledRanges).forEach(ruleName => {\n          startDisabledRange(comment.source.start.line, ruleName)\n        })\n        return\n      }\n\n      if (ruleIsDisabled(ruleToDisable)) {\n        throw comment.error(`\"${ruleToDisable}\" has already been disabled`, { plugin: \"stylelint\" })\n      }\n      startDisabledRange(comment.source.start.line, ruleToDisable)\n    })\n  }\n\n  function processEnableCommand(comment/*: postcss$comment*/) {\n    getCommandRules(enableCommand, comment.text).forEach(ruleToEnable => {\n      if (ruleToEnable === ALL_RULES) {\n        if (_.values(disabledRanges).every(ranges => _.isEmpty(ranges) || !!_.last(ranges.end))) {\n          throw comment.error(\"No rules have been disabled\", { plugin: \"stylelint\" })\n        }\n        Object.keys(disabledRanges).forEach(ruleName => {\n          if (!_.get(_.last(disabledRanges[ruleName]), \"end\")) {\n            endDisabledRange(comment.source.end.line, ruleName)\n          }\n        })\n        return\n      }\n\n      if (ruleIsDisabled(ALL_RULES) && disabledRanges[ruleToEnable] === undefined) {\n        // Get a starting point from the where all rules were disabled\n        if (!disabledRanges[ruleToEnable]) {\n          disabledRanges[ruleToEnable] = _.cloneDeep(disabledRanges.all)\n        } else {\n          disabledRanges[ruleToEnable].push(_.clone(_.last(disabledRanges[ALL_RULES])))\n        }\n        endDisabledRange(comment.source.end.line, ruleToEnable)\n        return\n      }\n\n      if (ruleIsDisabled(ruleToEnable)) {\n        endDisabledRange(comment.source.end.line, ruleToEnable)\n        return\n      }\n\n      throw comment.error(`\"${ruleToEnable}\" has not been disabled`, { plugin: \"stylelint\" })\n    })\n  }\n\n  function checkComment(comment/*: postcss$comment*/) {\n    const text = comment.text\n\n    // Ignore comments that are not relevant commands\n\n    if (text.indexOf(COMMAND_PREFIX) !== 0) {\n      return result\n    }\n\n    if (text.indexOf(disableLineCommand) === 0) {\n      processDisableLineCommand(comment)\n    } else if (text.indexOf(disableNextLineCommand) === 0) {\n      processDisableNextLineCommand(comment)\n    } else if (text.indexOf(disableCommand) === 0) {\n      processDisableCommand(comment)\n    } else if (text.indexOf(enableCommand) === 0) {\n      processEnableCommand(comment)\n    }\n  }\n\n  function getCommandRules(\n    command/*: string*/,\n    fullText/*: string*/\n  )/*: Array<string>*/ {\n    const rules = _.compact(fullText.slice(command.length).split(\",\")).map(r => r.trim())\n    if (_.isEmpty(rules)) {\n      return [ALL_RULES]\n    }\n    return rules\n  }\n\n  function startDisabledRange(line/*: number*/, ruleName/*: string*/) {\n    const rangeObj = { start: line }\n    ensureRuleRanges(ruleName)\n    disabledRanges[ruleName].push(rangeObj)\n  }\n\n  function endDisabledRange(line/*: number*/, ruleName/*: string*/) {\n    const lastRangeForRule = _.last(disabledRanges[ruleName])\n    if (!lastRangeForRule) {\n      return\n    }\n    // Add an `end` prop to the last range of that rule\n    lastRangeForRule.end = line\n  }\n\n  function ensureRuleRanges(ruleName/*: string*/) {\n    if (!disabledRanges[ruleName]) {\n      disabledRanges[ruleName] = _.cloneDeep(disabledRanges.all)\n    }\n  }\n\n  function ruleIsDisabled(ruleName/*: string*/)/*: boolean*/ {\n    if (disabledRanges[ruleName] === undefined) return false\n    if (_.last(disabledRanges[ruleName]) === undefined) return false\n    if (_.get(_.last(disabledRanges[ruleName]), \"end\") === undefined) return true\n    return false\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/testUtils/basicChecks.js":"\"use strict\"\n\n// These should pass for *almost* every rule\nmodule.exports = [ {\n  code: \"\",\n  description: \"empty stylesheet\",\n}, {\n  code: \"a {}\",\n  description: \"empty rule\",\n}, {\n  code: \"@import \\\"foo.css\\\";\",\n  description: \"blockless statement\",\n}, {\n  code: \":global {}\",\n  description: \"CSS Modules global empty rule set\",\n} ]\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/createStylelint.js":"/* @flow */\n\"use strict\"\nconst augmentConfig = require(\"./augmentConfig\")\nconst _ = require(\"lodash\")\nconst cosmiconfig = require(\"cosmiconfig\")\nconst createStylelintResult = require(\"./createStylelintResult\")\nconst getConfigForFile = require(\"./getConfigForFile\")\nconst getPostcssResult = require(\"./getPostcssResult\")\nconst isPathIgnored = require(\"./isPathIgnored\")\nconst lintSource = require(\"./lintSource\")\n\n// The stylelint \"internal API\" is passed among functions\n// so that methods on a stylelint instance can invoke\n// each other while sharing options and caches\nmodule.exports = function (options/*: stylelint$options*/)/*: stylelint$internalApi*/ {\n  options = options || {}\n  const stylelint/*: Object*/ = { _options: options }\n\n  // Two separate explorers so they can each have their own transform\n  // function whose results are cached by cosmiconfig\n  stylelint._fullExplorer = cosmiconfig(\"stylelint\", {\n    argv: false,\n    rcExtensions: true,\n    transform: _.partial(augmentConfig.augmentConfigFull, stylelint),\n  })\n  stylelint._extendExplorer = cosmiconfig(null, {\n    argv: false,\n    transform: _.partial(augmentConfig.augmentConfigExtended, stylelint),\n  })\n\n  stylelint._specifiedConfigCache = new Map()\n  stylelint._postcssResultCache = new Map()\n  stylelint._createStylelintResult = _.partial(createStylelintResult, stylelint)\n  stylelint._getPostcssResult = _.partial(getPostcssResult, stylelint)\n  stylelint._lintSource = _.partial(lintSource, stylelint)\n\n  stylelint.getConfigForFile = _.partial(getConfigForFile, stylelint)\n  stylelint.isPathIgnored = _.partial(isPathIgnored, stylelint)\n\n  return stylelint\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/augmentConfig.js":"/* @flow */\n\"use strict\"\nconst configurationError = require(\"./utils/configurationError\")\nconst getModulePath = require(\"./utils/getModulePath\")\nconst _ = require(\"lodash\")\nconst fs = require(\"fs\")\nconst globjoin = require(\"globjoin\")\nconst normalizeRuleSettings = require(\"./normalizeRuleSettings\")\nconst path = require(\"path\")\nconst rules = require(\"./rules\")\nconst dynamicRequire = require(\"./dynamicRequire\")\n\nconst DEFAULT_IGNORE_FILENAME = \".stylelintignore\"\nconst FILE_NOT_FOUND_ERROR_CODE = \"ENOENT\"\n\n// - Merges config and configOverrides\n// - Makes all paths absolute\n// - Merges extends\nfunction augmentConfigBasic(\n  stylelint/*: stylelint$internalApi*/,\n  config/*: stylelint$config*/,\n  configDir/*: string*/,\n  allowOverrides/*:: ?: boolean*/\n)/*: Promise<stylelint$config>*/ {\n  return Promise.resolve().then(() => {\n    if (!allowOverrides) return config\n    return _.merge(config, stylelint._options.configOverrides)\n  }).then(augmentedConfig => {\n    return extendConfig(stylelint, augmentedConfig, configDir)\n  }).then(augmentedConfig => {\n    return absolutizePaths(augmentedConfig, configDir)\n  })\n}\n\n// Extended configs need to be run through augmentConfigBasic\n// but do not need the full treatment. Things like pluginFunctions\n// will be resolved and added by the parent config.\nfunction augmentConfigExtended(\n  stylelint/*: stylelint$internalApi*/,\n  cosmiconfigResultArg/*: ?{\n     config: stylelint$config,\n     filepath: string,\n   }*/\n )/*: Promise<?{ config: stylelint$config, filepath: string }>*/ {\n  const cosmiconfigResult = cosmiconfigResultArg // Lock in for Flow\n  if (!cosmiconfigResult) return Promise.resolve(null)\n\n  const configDir = path.dirname(cosmiconfigResult.filepath || \"\")\n  const cleanedConfig = _.omit(cosmiconfigResult.config, \"ignoreFiles\")\n  return augmentConfigBasic(stylelint, cleanedConfig, configDir).then(augmentedConfig => {\n    return {\n      config: augmentedConfig,\n      filepath: cosmiconfigResult.filepath,\n    }\n  })\n}\n\nfunction augmentConfigFull(\n  stylelint/*: stylelint$internalApi*/,\n   cosmiconfigResultArg/*: ?{\n   config: stylelint$config,\n   filepath: string,\n  }*/\n)/*: Promise<?{ config: stylelint$config, filepath: string }>*/ {\n  const cosmiconfigResult = cosmiconfigResultArg // Lock in for Flow\n  if (!cosmiconfigResult) return Promise.resolve(null)\n\n  const config = cosmiconfigResult.config,\n    filepath = cosmiconfigResult.filepath\n\n  const configDir = stylelint._options.configBasedir || path.dirname(filepath || \"\")\n\n  return augmentConfigBasic(stylelint, config, configDir, true).then(augmentedConfig => {\n    return addIgnorePatterns(stylelint, augmentedConfig)\n  }).then(augmentedConfig => {\n    return addPluginFunctions(augmentedConfig)\n  }).then(augmentedConfig => {\n    return addProcessorFunctions(augmentedConfig)\n  }).then(augmentedConfig => {\n    if (!augmentedConfig.rules) {\n      throw configurationError(\"No rules found within configuration. Have you provided a \\\"rules\\\" property?\")\n    }\n\n    return normalizeAllRuleSettings(augmentedConfig)\n  }).then(augmentedConfig => {\n    return {\n      config: augmentedConfig,\n      filepath: cosmiconfigResult.filepath,\n    }\n  })\n}\n\n// Load a file ignore ignore patterns, if there is one;\n// then add them to the config as an ignorePatterns property\nfunction addIgnorePatterns(\n  stylelint/*: stylelint$internalApi*/,\n  config/*: stylelint$config*/\n)/*: Promise<stylelint$config>*/ {\n  const ignoreFilePath = stylelint._options.ignorePath || DEFAULT_IGNORE_FILENAME\n  const absoluteIgnoreFilePath = path.isAbsolute(ignoreFilePath) ? ignoreFilePath : path.resolve(process.cwd(), ignoreFilePath)\n\n  return new Promise((resolve, reject) => {\n    fs.readFile(absoluteIgnoreFilePath, \"utf8\", (err, data) => {\n      if (err) {\n        // If the file's not found, fine, we'll just\n        // consider it an empty array of globs\n        if (err.code === FILE_NOT_FOUND_ERROR_CODE) {\n          return resolve(config)\n        }\n        return reject(err)\n      }\n      // Add an ignorePatterns property to the config, containing the\n      // .gitignore-patterned globs loaded from .stylelintignore\n      const augmentedConfig/*: stylelint$config*/ = Object.assign({}, config, {\n        ignorePatterns: data,\n      })\n      resolve(augmentedConfig)\n    })\n  })\n}\n\n// Make all paths in the config absolute:\n// - ignoreFiles\n// - plugins\n// - processors\n// (extends handled elsewhere)\nfunction absolutizePaths(\n  config/*: stylelint$config*/,\n  configDir/*: string*/\n)/*: stylelint$config*/ {\n  if (config.ignoreFiles) {\n    config.ignoreFiles = [].concat(config.ignoreFiles).map(glob => {\n      if (path.isAbsolute(glob.replace(/^!/, \"\"))) return glob\n      return globjoin(configDir, glob)\n    })\n  }\n\n  if (config.plugins) {\n    config.plugins = [].concat(config.plugins).map(lookup => {\n      return getModulePath(configDir, lookup)\n    })\n  }\n\n  if (config.processors) {\n    config.processors = absolutizeProcessors(config.processors, configDir)\n  }\n\n  return config\n}\n\n// Processors are absolutized in their own way because\n// they can be and return a string or an array\nfunction absolutizeProcessors(\n  processors/*: stylelint$configProcessors*/,\n  configDir/*: string*/\n)/*: stylelint$configProcessors*/ {\n  const normalizedProcessors = Array.isArray(processors) ? processors : [processors]\n\n  return normalizedProcessors.map(item => {\n    if (typeof item === \"string\") {\n      return getModulePath(configDir, item)\n    }\n\n    return [ getModulePath(configDir, item[0]), item[1] ]\n  })\n}\n\nfunction extendConfig(\n  stylelint/*: stylelint$internalApi*/,\n  config/*: stylelint$config*/,\n  configDir/*: string*/\n)/*: Promise<stylelint$config>*/ {\n  if (config.extends === undefined) return Promise.resolve(config)\n  const normalizedExtends = Array.isArray(config.extends) ? config.extends : [config.extends]\n\n  const originalWithoutExtends = _.omit(config, \"extends\")\n  const loadExtends = normalizedExtends.reduce((resultPromise, extendLookup) => {\n    return resultPromise.then(resultConfig => {\n      return loadExtendedConfig(stylelint, resultConfig, configDir, extendLookup).then(extendResult => {\n        if (!extendResult) return resultConfig\n        return mergeConfigs(resultConfig, extendResult.config)\n      })\n    })\n  }, Promise.resolve(originalWithoutExtends))\n\n  return loadExtends.then(resultConfig => {\n    return mergeConfigs(resultConfig, originalWithoutExtends)\n  })\n}\n\nfunction loadExtendedConfig(\n  stylelint/*: stylelint$internalApi*/,\n  config/*: stylelint$config*/,\n  configDir/*: string*/,\n  extendLookup/*: string*/\n)/*: Promise<?{ config: stylelint$config, filepath: string }>*/ {\n  const extendPath = getModulePath(configDir, extendLookup)\n  return stylelint._extendExplorer.load(null, extendPath)\n}\n\n// When merging configs (via extends)\n// - plugin and processor arrays are joined\n// - rules are merged via Object.assign, so there is no attempt made to\n//   merge any given rule's settings. If b contains the same rule as a,\n//   b's rule settings will override a's rule settings entirely.\n// - Everything else is merged via Object.assign\nfunction mergeConfigs(a/*: stylelint$config*/, b/*: stylelint$config*/)/*: stylelint$config*/ {\n  const pluginMerger = {}\n  if (a.plugins || b.plugins) {\n    pluginMerger.plugins = []\n    if (a.plugins) {\n      pluginMerger.plugins = pluginMerger.plugins.concat(a.plugins)\n    }\n    if (b.plugins) {\n      pluginMerger.plugins = _.uniq(pluginMerger.plugins.concat(b.plugins))\n    }\n  }\n\n  const processorMerger = {}\n  if (a.processors || b.processors) {\n    processorMerger.processors = []\n    if (a.processors) {\n      processorMerger.processors = processorMerger.processors.concat(a.processors)\n    }\n    if (b.processors) {\n      processorMerger.processors = _.uniq(processorMerger.processors.concat(b.processors))\n    }\n  }\n\n  const rulesMerger = {}\n  if (a.rules || b.rules) {\n    rulesMerger.rules = Object.assign({}, a.rules, b.rules)\n  }\n\n  const result = Object.assign({}, a, b, processorMerger, pluginMerger, rulesMerger)\n  return result\n}\n\nfunction addPluginFunctions(config/*: stylelint$config*/)/*: stylelint$config*/ {\n  if (!config.plugins) return config\n\n  const normalizedPlugins = Array.isArray(config.plugins) ? config.plugins : [config.plugins]\n\n  const pluginFunctions = normalizedPlugins.reduce((result, pluginLookup) => {\n    let pluginImport = dynamicRequire(pluginLookup)\n    // Handle either ES6 or CommonJS modules\n    pluginImport = pluginImport.default || pluginImport\n\n    // A plugin can export either a single rule definition\n    // or an array of them\n    const normalizedPluginImport = Array.isArray(pluginImport) ? pluginImport : [pluginImport]\n\n    normalizedPluginImport.forEach(pluginRuleDefinition => {\n      if (!pluginRuleDefinition.ruleName) {\n        throw configurationError(\"stylelint v3+ requires plugins to expose a ruleName. \" + `The plugin \"${pluginLookup}\" is not doing this, so will not work ` + \"with stylelint v3+. Please file an issue with the plugin.\")\n      }\n\n      if (!_.includes(pluginRuleDefinition.ruleName, \"/\")) {\n        throw configurationError(\"stylelint v7+ requires plugin rules to be namspaced, \" + \"i.e. only `plugin-namespace/plugin-rule-name` plugin rule names are supported. \" + `The plugin rule \"${pluginRuleDefinition.ruleName}\" does not do this, so will not work. ` + \"Please file an issue with the plugin.\")\n      }\n\n      result[pluginRuleDefinition.ruleName] = pluginRuleDefinition.rule\n    })\n\n    return result\n  }, {})\n\n  config.pluginFunctions = pluginFunctions\n  return config\n}\n\nfunction normalizeAllRuleSettings(config/*: stylelint$config*/)/*: stylelint$config*/ {\n  const normalizedRules = {}\n  if (!config.rules) return config\n  Object.keys(config.rules).forEach(ruleName => {\n    const rawRuleSettings = _.get(config, [ \"rules\", ruleName ])\n    const rule = rules[ruleName] || _.get(config, [ \"pluginFunctions\", ruleName ])\n    if (!rule) {\n      throw configurationError(`Undefined rule ${ruleName}`)\n    }\n    normalizedRules[ruleName] = normalizeRuleSettings(rawRuleSettings, ruleName, _.get(rule, \"primaryOptionArray\"))\n  })\n  config.rules = normalizedRules\n  return config\n}\n\n// Given an array of processors strings, we want to add two\n// properties to the augmented config:\n// - codeProcessors: functions that will run on code as it comes in\n// - resultProcessors: functions that will run on results as they go out\n//\n// To create these properties, we need to:\n// - Find the processor module\n// - Intialize the processor module by calling its functions with any\n//   provided options\n// - Push the processor's code and result processors to their respective arrays\nconst processorCache = new Map()\nfunction addProcessorFunctions(config/*: stylelint$config*/)/*: stylelint$config*/ {\n  if (!config.processors) return config\n\n  const codeProcessors = []\n  const resultProcessors = []\n\n  ;[].concat(config.processors).forEach(processorConfig => {\n    const processorKey = JSON.stringify(processorConfig)\n\n    let initializedProcessor\n    if (processorCache.has(processorKey)) {\n      initializedProcessor = processorCache.get(processorKey)\n    } else {\n      processorConfig = [].concat(processorConfig)\n      const processorLookup = processorConfig[0]\n      const processorOptions = processorConfig[1]\n      let processor = dynamicRequire(processorLookup)\n      processor = processor.default || processor\n      initializedProcessor = processor(processorOptions)\n      processorCache.set(processorKey, initializedProcessor)\n    }\n\n    if (initializedProcessor && initializedProcessor.code) {\n      codeProcessors.push(initializedProcessor.code)\n    }\n    if (initializedProcessor && initializedProcessor.result) {\n      resultProcessors.push(initializedProcessor.result)\n    }\n  })\n\n  config.codeProcessors = codeProcessors\n  config.resultProcessors = resultProcessors\n  return config\n}\n\nmodule.exports = { augmentConfigExtended, augmentConfigFull }\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/getModulePath.js":"/* @flow */\n\"use strict\"\n\nconst configurationError = require(\"./configurationError\")\nconst resolveFrom = require(\"resolve-from\")\n\nmodule.exports = function (basedir/*: string*/, lookup/*: string*/)/*: string*/ {\n  // First try to resolve from the provided directory,\n  // then try to resolve from process.cwd.\n  let path = resolveFrom(basedir, lookup)\n  if (!path) {\n    path = resolveFrom(process.cwd(), lookup)\n  }\n  if (!path) {\n    throw configurationError(`Could not find \"${lookup}\". Do you need a \\`configBasedir\\`?`)\n  }\n  return path\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/dynamicRequire.js":"\"use strict\"\n// This file exists to remove the need for Flow's ignore_non_literal_requires option\n\nmodule.exports = function (name) {\n  return require(name)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/createStylelintResult.js":"/* @flow */\n\"use strict\"\nconst _ = require(\"lodash\")\n\nmodule.exports = function (\n  stylelint/*: stylelint$internalApi*/,\n  postcssResult/*: Object*/,\n  filePath/*:: ?: string*/\n)/*: Promise<stylelint$result>*/ {\n  const source = !postcssResult.root.source ? undefined : postcssResult.root.source.input.file || postcssResult.root.source.input.id\n\n  // Strip out deprecation warnings from the messages\n  const deprecationMessages = _.remove(postcssResult.messages, { stylelintType: \"deprecation\" })\n  const deprecations = deprecationMessages.map(deprecationMessage => {\n    return {\n      text: deprecationMessage.text,\n      reference: deprecationMessage.stylelintReference,\n    }\n  })\n\n  // Also strip out invalid options\n  const invalidOptionMessages = _.remove(postcssResult.messages, { stylelintType: \"invalidOption\" })\n  const invalidOptionWarnings = invalidOptionMessages.map(invalidOptionMessage => {\n    return {\n      text: invalidOptionMessage.text,\n    }\n  })\n\n  // This defines the stylelint result object that formatters receive\n  let stylelintResult = {\n    source,\n    deprecations,\n    invalidOptionWarnings,\n    errored: postcssResult.stylelint.stylelintError,\n    warnings: postcssResult.messages.map(message => {\n      return {\n        line: message.line,\n        column: message.column,\n        rule: message.rule,\n        severity: message.severity,\n        text: message.text,\n      }\n    }),\n    ignored: postcssResult.stylelint.ignored,\n    _postcssResult: postcssResult,\n  }\n\n  return stylelint.getConfigForFile(filePath).then((result) => {\n    const config = result.config\n\n    if (config.resultProcessors) {\n      config.resultProcessors.forEach(resultProcessor => {\n        // Result processors might just mutate the result object,\n        // or might return a new one\n        const returned = resultProcessor(stylelintResult, source)\n        if (returned) {\n          stylelintResult = returned\n        }\n      })\n    }\n\n    return stylelintResult\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/getConfigForFile.js":"/* @flow */\n\"use strict\"\nconst augmentConfigFull = require(\"./augmentConfig\").augmentConfigFull\nconst configurationError = require(\"./utils/configurationError\")\nconst path = require(\"path\")\n\nmodule.exports = function (\n  stylelint/*: stylelint$internalApi*/,\n  searchPath/*:: ?: string*/\n)/*: Promise<?{ config: stylelint$config, filepath: string }>*/ {\n  searchPath = searchPath || process.cwd()\n\n  const optionsConfig = stylelint._options.config\n\n  if (optionsConfig !== undefined) {\n    const cached = stylelint._specifiedConfigCache.get(optionsConfig)\n    if (cached) return cached\n\n    // stylelint._fullExplorer (cosmiconfig) is already configured to\n    // run augmentConfigFull; but since we're making up the result here,\n    // we need to manually run the transform\n    const augmentedResult = augmentConfigFull(stylelint, {\n      config: optionsConfig,\n      // Add the extra path part so that we can get the directory without being\n      // confused\n      filepath: path.join(process.cwd(), \"argument-config\"),\n    })\n    stylelint._specifiedConfigCache.set(optionsConfig, augmentedResult)\n    return augmentedResult\n  }\n\n  return stylelint._fullExplorer.load(searchPath, stylelint._options.configFile).then(config => {\n    // If no config was found, try looking from process.cwd\n    if (!config) return stylelint._fullExplorer.load(process.cwd())\n    return config\n  }).then(config => {\n    if (!config) {\n      const ending = searchPath ? ` for ${searchPath}` : \"\"\n      throw configurationError(`No configuration provided${ending}`)\n    }\n    return config\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/getPostcssResult.js":"/* @flow */\n\"use strict\"\n\nconst fs = require(\"fs\")\nconst lessSyntax = require(\"postcss-less\")\nconst path = require(\"path\")\nconst postcss = require(\"postcss\")\nconst scssSyntax = require(\"postcss-scss\")\nconst sugarssSyntax = require(\"sugarss\")\nconst dynamicRequire = require(\"./dynamicRequire\")\n\nconst postcssProcessor = postcss()\n\nmodule.exports = function (stylelint/*: stylelint$internalApi*/)/*: Promise<?Object>*/ {\n  const options/*: {\n    code?: string,\n    codeFilename?: string,\n    filePath?: string,\n    codeProcessors?: Array<Function>,\n    syntax?: stylelint$syntaxes,\n    customSyntax?: string\n  }*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}\n\n  const cached/*: ?postcss$result*/ = stylelint._postcssResultCache.get(options.filePath)\n  if (cached) return Promise.resolve(cached)\n\n  let getCode\n  if (options.code !== undefined) {\n    getCode = Promise.resolve(options.code)\n  } else if (options.filePath) {\n    getCode = readFile(options.filePath)\n  }\n\n  if (!getCode) {\n    throw new Error(\"code or filePath required\")\n  }\n\n  return getCode.then(code => {\n    const customSyntax = stylelint._options.customSyntax\n    let syntax = stylelint._options.syntax\n\n    if (customSyntax) {\n      try {\n        syntax = dynamicRequire(customSyntax)\n      } catch (e) {\n        throw new Error(`Cannot resolve custom syntax module ${customSyntax}`)\n      }\n    } else {\n      const fileExtension = path.extname(options.filePath || \"\")\n      if (syntax === \"scss\" || !syntax && fileExtension === \".scss\") {\n        syntax = scssSyntax\n      } else if (syntax === \"less\" || !syntax && fileExtension === \".less\") {\n        syntax = lessSyntax\n      } else if (syntax === \"sugarss\" || !syntax && fileExtension === \".sss\") {\n        syntax = sugarssSyntax\n      } else if (syntax) {\n        throw new Error(\"You must use a valid syntax option, either: scss, less or sugarss\")\n      }\n    }\n\n    const postcssOptions/*: postcss$options*/ = {}\n\n    postcssOptions.from = options.filePath\n\n    /*\n     * PostCSS allows for syntaxes that only contain a parser, however,\n     * it then expects the syntax to be set as the `parser` option rather than `syntax.\n     */\n    if (syntax && !syntax.stringify) {\n      postcssOptions.parser = syntax\n    } else {\n      postcssOptions.syntax = syntax\n    }\n\n    const source = options.code ? options.codeFilename : options.filePath\n    let preProcessedCode = code\n    if (options.codeProcessors) {\n      options.codeProcessors.forEach(codeProcessor => {\n        preProcessedCode = codeProcessor(preProcessedCode, source)\n      })\n    }\n\n    return postcssProcessor.process(preProcessedCode, postcssOptions)\n  }).then(postcssResult => {\n    stylelint._postcssResultCache.set(options.filePath, postcssResult)\n    return postcssResult\n  })\n}\n\nfunction readFile(filePath/*: string*/)/*: Promise<string>*/ {\n  return new Promise((resolve, reject) => {\n    fs.readFile(filePath, \"utf8\", (err, content) => {\n      if (err) {\n        return reject(err)\n      }\n      resolve(content)\n    })\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/isPathIgnored.js":"/* @flow */\n\"use strict\"\nconst ignore = require(\"ignore\")\nconst micromatch = require(\"micromatch\")\nconst path = require(\"path\")\n\nconst alwaysIgnoredGlobs = require(\"./alwaysIgnoredGlobs\")\n\n// To find out if a path is ignored, we need to load the config,\n// which may have an ignoreFiles property,\n// and will have incorporated any .stylelintignore file that was found\n// into its ignorePatterns property. We then check the path\n// against these.\nmodule.exports = function (\n  stylelint/*: stylelint$internalApi*/,\n  filePathArg/*:: ?: string*/\n)/*: Promise<boolean>*/ {\n  const filePath = filePathArg // to please Flow\n  if (!filePath) {\n    return Promise.resolve(false)\n  }\n\n  return stylelint.getConfigForFile(filePath).then((result) => {\n    const config = result.config\n\n    const absoluteFilePath = path.isAbsolute(filePath) ? filePath : path.resolve(process.cwd(), filePath)\n\n    const ignoreFiles = alwaysIgnoredGlobs.concat(config.ignoreFiles || [])\n    if (micromatch(absoluteFilePath, ignoreFiles).length) {\n      return true\n    }\n\n    const ignorePatternsFilter = ignore().add(config.ignorePatterns).createFilter()\n\n    const filepathRelativeToCwd = path.relative(process.cwd(), filePath)\n\n    if (ignorePatternsFilter && !ignorePatternsFilter(filepathRelativeToCwd)) {\n      return true\n    }\n\n    return false\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/alwaysIgnoredGlobs.js":"/* @flow */\n\"use strict\"\n\nconst alwaysIgnoredGlobs/*: Array<string>*/ = [ \"**/node_modules/**\", \"**/bower_components/**\" ]\n\nmodule.exports = alwaysIgnoredGlobs\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/lintSource.js":"/* @flow */\n\"use strict\"\nconst _ = require(\"lodash\")\nconst assignDisabledRanges = require(\"./assignDisabledRanges\")\nconst configurationError = require(\"./utils/configurationError\")\nconst path = require(\"path\")\nconst ruleDefinitions = require(\"./rules\")\n\n// Run stylelint on a PostCSS Result, either one that is provided\n// or one that we create\nmodule.exports = function (\n  stylelint/*: stylelint$internalApi*/,\n  options/*: {\n    code?: string,\n    codeFilename?: string, // Must be an absolute file path\n    filePath?: string, // Must be an absolute file path\n    existingPostcssResult?: Object,\n  }*/\n)/*: Promise<Object>*/ {\n  options = options || {}\n\n  if (!options.filePath && options.code === undefined && !options.existingPostcssResult) {\n    return Promise.reject(new Error(\"You must provide filePath, code, or existingPostcssResult\"))\n  }\n\n  const isCodeNotFile = options.code !== undefined\n\n  const inputFilePath = isCodeNotFile ? options.codeFilename : options.filePath\n  if (inputFilePath !== undefined && !path.isAbsolute(inputFilePath)) {\n    if (isCodeNotFile) {\n      return Promise.reject(new Error(\"codeFilename must be an absolute path\"))\n    } else {\n      return Promise.reject(new Error(\"filePath must be an absolute path\"))\n    }\n  }\n\n  const getIsIgnored = stylelint.isPathIgnored(inputFilePath).catch(err => {\n    if (isCodeNotFile && err.code === \"ENOENT\") return false\n    throw err\n  })\n\n  return getIsIgnored.then(isIgnored => {\n    if (isIgnored) {\n      const postcssResult = options.existingPostcssResult || createEmptyPostcssResult(inputFilePath)\n      postcssResult.stylelint = postcssResult.stylelint || {}\n      postcssResult.stylelint.ignored = true\n      postcssResult.standaloneIgnored = true // TODO: remove need for this\n      return postcssResult\n    }\n\n    const configSearchPath = stylelint._options.configFile || inputFilePath\n\n    const getConfig = stylelint.getConfigForFile(configSearchPath).catch(err => {\n      if (isCodeNotFile && err.code === \"ENOENT\") return stylelint.getConfigForFile(process.cwd())\n      throw err\n    })\n\n    return getConfig.then((result) => {\n      const config = result.config\n      const existingPostcssResult = options.existingPostcssResult\n\n      if (existingPostcssResult) {\n        return lintPostcssResult(stylelint, existingPostcssResult, config).then(() => existingPostcssResult)\n      }\n\n      return stylelint._getPostcssResult({\n        code: options.code,\n        codeFilename: options.codeFilename,\n        filePath: inputFilePath,\n        codeProcessors: config.codeProcessors,\n      }).then(postcssResult => {\n        return lintPostcssResult(stylelint, postcssResult, config).then(() => postcssResult)\n      })\n    })\n  })\n}\n\nfunction lintPostcssResult(\n  stylelint/*: stylelint$internalApi*/,\n  postcssResult/*: Object*/,\n  config/*: stylelint$config*/\n)/*: Promise<>*/ {\n  postcssResult.stylelint = postcssResult.stylelint || {}\n  postcssResult.stylelint.ruleSeverities = {}\n  postcssResult.stylelint.customMessages = {}\n  postcssResult.stylelint.quiet = config.quiet\n\n  const postcssRoot = postcssResult.root\n  assignDisabledRanges(postcssRoot, postcssResult)\n  if (stylelint._options.reportNeedlessDisables || stylelint._options.ignoreDisables) {\n    postcssResult.stylelint.ignoreDisables = true\n  }\n\n  // Promises for the rules. Although the rule code runs synchronously now,\n  // the use of Promises makes it compatible with the possibility of async\n  // rules down the line.\n  const performRules = []\n\n  const rules = config.rules ? Object.keys(config.rules) : []\n\n  rules.forEach(ruleName => {\n    const ruleFunction = ruleDefinitions[ruleName] || _.get(config, [ \"pluginFunctions\", ruleName ])\n\n    if (ruleFunction === undefined) {\n      throw configurationError(`Undefined rule ${ruleName}`)\n    }\n\n    const ruleSettings = _.get(config, [ \"rules\", ruleName ])\n    if (ruleSettings === null || ruleSettings[0] === null) {\n      return\n    }\n\n    const primaryOption = ruleSettings[0]\n    const secondaryOptions = ruleSettings[1]\n\n    // Log the rule's severity in the PostCSS result\n    const defaultSeverity = config.defaultSeverity || \"error\"\n    postcssResult.stylelint.ruleSeverities[ruleName] = _.get(secondaryOptions, \"severity\", defaultSeverity)\n    postcssResult.stylelint.customMessages[ruleName] = _.get(secondaryOptions, \"message\")\n\n    const performRule = Promise.resolve().then(() => {\n      return ruleFunction(primaryOption, secondaryOptions)(postcssRoot, postcssResult)\n    })\n    performRules.push(performRule)\n  })\n\n  return Promise.all(performRules)\n}\n\nfunction createEmptyPostcssResult(filePath/*:: ?: string*/)/*: Object*/ {\n  return {\n    root: {\n      source: {\n        input: { file: filePath },\n      },\n    },\n    messages: [],\n    stylelint: { stylelintError: null },\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/postcssPlugin.js":"/* @flow */\n\"use strict\"\nconst _ = require(\"lodash\")\nconst createStylelint = require(\"./createStylelint\")\nconst postcss = require(\"postcss\")\nconst path = require(\"path\")\n\nmodule.exports = postcss.plugin(\"stylelint\", function (options) {\n  options = options || {}\n\n  const tailoredOptions/*: Object*/ = options.rules\n    ? { config: options }\n    : options\n  const stylelint = createStylelint(tailoredOptions)\n\n  return (root, result) => {\n    let filePath = options.from || _.get(root, \"source.input.file\")\n    if (filePath !== undefined && !path.isAbsolute(filePath)) {\n      filePath = path.join(process.cwd(), filePath)\n    }\n\n    return stylelint._lintSource({\n      filePath,\n      existingPostcssResult: result,\n    })\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/formatters/index.js":"\"use strict\"\n\nmodule.exports = {\n  json: require(\"./jsonFormatter\"),\n  string: require(\"./stringFormatter\"),\n  verbose: require(\"./verboseFormatter\"),\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/formatters/jsonFormatter.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\n\n// Omit any properties starting with `_`, which are fake-private\nmodule.exports = function (results) {\n  const cleanedResults = results.map(result => {\n    return _.omitBy(result, (value, key) => key[0] === \"_\")\n  })\n  return JSON.stringify(cleanedResults)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/formatters/stringFormatter.js":"\"use strict\"\n\nconst table = require(\"table\")\nconst _ = require(\"lodash\")\nconst chalk = require(\"chalk\")\nconst path = require(\"path\")\nconst stringWidth = require(\"string-width\")\nconst symbols = require(\"log-symbols\")\nconst utils = require(\"postcss-reporter/lib/util\")\n\nconst MARGIN_WIDTHS = 9\n\nconst levelColors = {\n  info: \"blue\",\n  warning: \"yellow\",\n  error: \"red\",\n}\n\nfunction deprecationsFormatter(results) {\n  const allDeprecationWarnings = _.flatMap(results, \"deprecations\")\n  const uniqueDeprecationWarnings = _.uniqBy(allDeprecationWarnings, \"text\")\n\n  if (!uniqueDeprecationWarnings || !uniqueDeprecationWarnings.length) {\n    return \"\"\n  }\n\n  return uniqueDeprecationWarnings.reduce((output, warning) => {\n    output += chalk.yellow(\"Deprecation Warning: \")\n    output += warning.text\n    if (warning.reference) {\n      output += chalk.dim(\" See: \")\n      output += chalk.dim.underline(warning.reference)\n    }\n    return output + \"\\n\"\n  }, \"\\n\")\n}\n\nfunction invalidOptionsFormatter(results) {\n  const allInvalidOptionWarnings = _.flatMap(results, r => r.invalidOptionWarnings.map(w => w.text))\n  const uniqueInvalidOptionWarnings = _.uniq(allInvalidOptionWarnings)\n\n  return uniqueInvalidOptionWarnings.reduce((output, warning) => {\n    output += chalk.red(\"Invalid Option: \")\n    output += warning\n    return output + \"\\n\"\n  }, \"\\n\")\n}\n\nfunction logFrom(fromValue) {\n  if (fromValue.charAt(0) === \"<\") return fromValue\n  return path.relative(process.cwd(), fromValue).split(path.sep).join(\"/\")\n}\n\nfunction getMessageWidth(columnWidths) {\n  if (!process.stdout.isTTY) {\n    return columnWidths[3]\n  }\n\n  const availableWidth = process.stdout.columns < 80 ? 80 : process.stdout.columns\n  const fullWidth = _.sum(_.values(columnWidths))\n\n  // If there is no reason to wrap the text, we won't align the last column to the right\n  if (availableWidth > fullWidth + MARGIN_WIDTHS) {\n    return columnWidths[3]\n  }\n\n  return availableWidth - (fullWidth - columnWidths[3] + MARGIN_WIDTHS)\n}\n\nfunction formatter(messages, source) {\n  if (!messages.length) return \"\"\n\n  const orderedMessages = _.sortBy(messages, m => m.line ? 2 : 1, // positionless first\n  m => m.line, m => m.column)\n\n  // Create a list of column widths, needed to calculate\n  // the size of the message column and if needed wrap it.\n  const columnWidths = { 0: 1, 1: 1, 2: 1, 3: 1, 4: 1 }\n\n  const calculateWidths = function (columns) {\n    _.forOwn(columns, (value, key) => {\n      const normalisedValue = value ? value.toString() : value\n      columnWidths[key] = Math.max(columnWidths[key], stringWidth(normalisedValue))\n    })\n\n    return columns\n  }\n\n  let output = \"\\n\"\n\n  if (source) {\n    output += chalk.underline(logFrom(source)) + \"\\n\"\n  }\n\n  const cleanedMessages = orderedMessages.map(message => {\n    const location = utils.getLocation(message)\n    const severity = message.severity\n    const row = [ location.line || \"\", location.column || \"\", symbols[severity] ? chalk[levelColors[severity]](symbols[severity]) : severity, message.text\n    // Remove all control characters (newline, tab and etc)\n    .replace(/[\\x01-\\x1A]+/g, \" \") // eslint-disable-line\n    .replace(/\\.$/, \"\").replace(new RegExp(_.escapeRegExp(\"(\" + message.rule + \")\") + \"$\"), \"\"), chalk.dim(message.rule || \"\") ]\n\n    calculateWidths(row)\n\n    return row\n  })\n\n  output += table.table(cleanedMessages, {\n    border: table.getBorderCharacters(\"void\"),\n    columns: {\n      0: { alignment: \"right\", width: columnWidths[0], paddingRight: 0 },\n      1: { alignment: \"left\", width: columnWidths[1] },\n      2: { alignment: \"center\", width: columnWidths[2] },\n      3: { alignment: \"left\", width: getMessageWidth(columnWidths), wrapWord: true },\n      4: { alignment: \"left\", width: columnWidths[4], paddingRight: 0 },\n    },\n    drawHorizontalLine: () => false,\n  }).split(\"\\n\").map(el => el.replace(/(\\d+)\\s+(\\d+)/, (m, p1, p2) => chalk.dim(p1 + \":\" + p2))).join(\"\\n\")\n\n  return output\n}\n\nmodule.exports = function (results) {\n  let output = invalidOptionsFormatter(results)\n  output += deprecationsFormatter(results)\n\n  output = results.reduce((output, result) => {\n    output += formatter(result.warnings, result.source)\n    return output\n  }, output)\n\n  // Ensure consistent padding\n  output = output.trim()\n\n  if (output !== \"\") {\n    output = \"\\n\" + output + \"\\n\\n\"\n  }\n\n  return output\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/formatters/verboseFormatter.js":"\"use strict\"\n\nconst _ = require(\"lodash\")\nconst chalk = require(\"chalk\")\nconst stringFormatter = require(\"./stringFormatter\")\n\nmodule.exports = function (results) {\n  let output = stringFormatter(results)\n\n  if (output === \"\") {\n    output = \"\\n\"\n  }\n\n  const sourceWord = results.length > 1 ? \"sources\" : \"source\"\n  const ignoredCount = results.filter(result => result.ignored).length\n  const checkedDisplay = ignoredCount ? `${results.length - ignoredCount} of ${results.length}` : results.length\n  output += chalk.underline(`${checkedDisplay} ${sourceWord} checked\\n`)\n  results.forEach(result => {\n    let formatting = \"green\"\n    if (result.errored) {\n      formatting = \"red\"\n    } else if (result.warnings.length) {\n      formatting = \"yellow\"\n    } else if (result.ignored) {\n      formatting = \"dim\"\n    }\n    let sourceText = `${result.source}`\n    if (result.ignored) {\n      sourceText += \" (ignored)\"\n    }\n    output += _.get(chalk, formatting)(` ${sourceText}\\n`)\n  })\n\n  const warnings = _.flatten(results.map(r => r.warnings))\n  const warningsBySeverity = _.groupBy(warnings, \"severity\")\n  const problemWord = warnings.length === 1 ? \"problem\" : \"problems\"\n\n  output += chalk.underline(`\\n${warnings.length} ${problemWord} found\\n`)\n\n  _.forOwn(warningsBySeverity, (warningList, severityLevel) => {\n    const warningsByRule = _.groupBy(warningList, \"rule\")\n    output += ` severity level \"${severityLevel}\": ${warningList.length}\\n`\n    _.forOwn(warningsByRule, (list, rule) => {\n      output += chalk.dim(`  ${rule}: ${list.length}\\n`)\n    })\n  })\n\n  return output + \"\\n\"\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/standalone.js":"/* @flow */\n\"use strict\"\nconst path = require(\"path\")\nconst formatters/*: Object*/ = require(\"./formatters\")\nconst createStylelint = require(\"./createStylelint\")\nconst globby/*: Function*/ = require(\"globby\")\nconst needlessDisables/*: Function*/ = require(\"./needlessDisables\")\nconst alwaysIgnoredGlobs = require(\"./alwaysIgnoredGlobs\")\nconst FileCache = require(\"./utils/FileCache\")\nconst debug = require(\"debug\")(\"stylelint:standalone\")\nconst pkg = require(\"../package.json\")\nconst hash = require(\"./utils/hash\")\n\n/*::type CssSyntaxErrorT = {\n  column: number;\n  file?: string;\n  input: {\n    column: number;\n    file?: string;\n    line: number;\n    source: string;\n  };\n  line: number;\n  message: string;\n  name: string;\n  reason: string;\n  source: string;\n}*/\n\nmodule.exports = function (options/*: stylelint$standaloneOptions */)/*: Promise<stylelint$standaloneReturnValue>*/ {\n  const files = options.files\n  const code = options.code\n  const codeFilename = options.codeFilename\n  const config = options.config\n  const configFile = options.configFile\n  const configBasedir = options.configBasedir\n  const configOverrides = options.configOverrides\n  const ignoreDisables = options.ignoreDisables\n  const ignorePath = options.ignorePath\n  const reportNeedlessDisables = options.reportNeedlessDisables\n  const formatter = options.formatter\n  const syntax = options.syntax\n  const customSyntax = options.customSyntax\n  const allowEmptyInput = options.allowEmptyInput\n  const cacheLocation = options.cacheLocation\n  const useCache = options.cache || false\n  let fileCache\n\n  const startTime = Date.now()\n\n  const isValidCode = typeof code === \"string\"\n  if (!files && !isValidCode || files && (code || isValidCode)) {\n    throw new Error(\"You must pass stylelint a `files` glob or a `code` string, though not both\")\n  }\n\n  let formatterFunction\n  if (typeof formatter === \"string\") {\n    formatterFunction = formatters[formatter]\n    if (formatterFunction === undefined) {\n      return Promise.reject(new Error(\"You must use a valid formatter option: 'json', 'string', 'verbose', or a function\"))\n    }\n  } else if (typeof formatter === \"function\") {\n    formatterFunction = formatter\n  } else {\n    formatterFunction = formatters.json\n  }\n\n  const stylelint = createStylelint({\n    config,\n    configFile,\n    configBasedir,\n    configOverrides,\n    ignoreDisables,\n    ignorePath,\n    reportNeedlessDisables,\n    syntax,\n    customSyntax,\n  })\n\n  if (!files) {\n    const absoluteCodeFilename = (codeFilename !== undefined && !path.isAbsolute(codeFilename))\n      ? path.join(process.cwd(), codeFilename)\n      : codeFilename\n    return stylelint._lintSource({\n      code,\n      codeFilename: absoluteCodeFilename,\n    }).then(postcssResult => {\n      return stylelint._createStylelintResult(postcssResult)\n    }).catch(handleError).then(stylelintResult => {\n      return prepareReturnValue([stylelintResult])\n    })\n  }\n\n  let fileList = files\n  if (typeof fileList === \"string\") {\n    fileList = [fileList]\n  }\n  fileList = fileList.concat(\n    alwaysIgnoredGlobs.map(file => \"!\" + file)\n  )\n\n  if (useCache) {\n    const stylelintVersion = pkg.version\n    const hashOfConfig = hash(`${stylelintVersion}_${JSON.stringify(config)}`)\n    fileCache = new FileCache(cacheLocation, hashOfConfig)\n  } else {\n    // No need to calculate hash here, we just want to delete cache file.\n    fileCache = new FileCache(cacheLocation)\n    // Remove cache file if cache option is disabled\n    fileCache.destroy()\n  }\n\n  return globby(fileList).then(filePaths => {\n    if (!filePaths.length) {\n      if (allowEmptyInput === undefined || !allowEmptyInput) {\n        const message = (files => {\n          if (typeof files === \"string\") {\n            return `${files} does`\n          }\n          // seperate files into last (last file) and initial) all the others\n          const initial = files.slice(0)\n          const last = initial.pop()\n          // join into a comma seperated string of file names\n          const ending = (files.length > 1 ? `and ${last} do` : `${last} does`)\n          return `${initial.join(\", \")} ${ending}`.trim()\n        })(files) + \" not match any files\"\n\n        const err/*: Object*/ = new Error(message)\n        err.code = 80\n        throw err\n      } else {\n        return Promise.all([])\n      }\n    }\n\n    let absoluteFilePaths = filePaths.map(filePath => {\n      const absoluteFilepath = (!path.isAbsolute(filePath))\n        ? path.join(process.cwd(), filePath)\n        : path.normalize(filePath)\n      return absoluteFilepath\n    })\n\n    if (useCache) {\n      absoluteFilePaths = absoluteFilePaths.filter(fileCache.hasFileChanged.bind(fileCache))\n    }\n\n    const getStylelintResults = absoluteFilePaths.map(absoluteFilepath => {\n      debug(`Processing ${absoluteFilepath}`)\n      return stylelint._lintSource({\n        filePath: absoluteFilepath,\n      }).then(postcssResult => {\n        if (postcssResult.stylelint.stylelintError && useCache) {\n          debug(`${absoluteFilepath} contains linting errors and will not be cached.`)\n          fileCache.removeEntry(absoluteFilepath)\n        }\n        return stylelint._createStylelintResult(postcssResult, absoluteFilepath)\n      }).catch(handleError)\n    })\n\n    return Promise.all(getStylelintResults)\n  }).then(prepareReturnValue)\n\n  function prepareReturnValue(stylelintResults/*: Array<stylelint$result>*/)/*: stylelint$standaloneReturnValue*/ {\n    const errored = stylelintResults.some(result => result.errored)\n    const returnValue/*: stylelint$standaloneReturnValue*/ = {\n      errored,\n      output: formatterFunction(stylelintResults),\n      results: stylelintResults,\n    }\n    if (reportNeedlessDisables) {\n      returnValue.needlessDisables = needlessDisables(stylelintResults)\n    }\n    if (useCache) {\n      fileCache.reconcile()\n    }\n    debug(`Linting complete in ${Date.now() - startTime}ms`)\n    return returnValue\n  }\n}\n\nfunction handleError(error/*: Object*/) {\n  if (error.name === \"CssSyntaxError\") {\n    return convertCssSyntaxErrorToResult(error)\n  } else {\n    throw error\n  }\n}\n\n// By converting syntax errors to stylelint results,\n// we can control their appearance in the formatted output\n// and other tools like editor plugins can decide how to\n// present them, as well\nfunction convertCssSyntaxErrorToResult(error/*: CssSyntaxErrorT*/)/*: stylelint$result*/ {\n  if (error.name !== \"CssSyntaxError\") {\n    throw error\n  }\n\n  return {\n    source: error.file || \"<input css 1>\",\n    deprecations: [],\n    invalidOptionWarnings: [],\n    errored: true,\n    warnings: [{\n      line: error.line,\n      column: error.column,\n      rule: error.name,\n      severity: \"error\",\n      text: error.reason + \" (\" + error.name + \")\",\n    }],\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/needlessDisables.js":"/* @flow */\n\"use strict\"\n\nconst _ = require(\"lodash\")\n\nmodule.exports = function (results/*: Array<stylelint$result>*/)/*: stylelint$needlessDisablesReport*/ {\n  const report = []\n\n  results.forEach(result => {\n    // File with `CssSyntaxError` have not `_postcssResult`\n    if (!result._postcssResult) {\n      return\n    }\n\n    const unused = { source: result.source, ranges: [] }\n    const rangeData = _.cloneDeep(result._postcssResult.stylelint.disabledRanges)\n\n    if (!rangeData) {\n      return\n    }\n\n    result.warnings.forEach(warning => {\n      const rule/*: string*/ = warning.rule\n\n      const ruleRanges = rangeData[rule]\n      if (ruleRanges) {\n        // Back to front so we get the *last* range that applies to the warning\n        for (const range of ruleRanges.reverse()) {\n          if (isWarningInRange(warning, range)) {\n            range.used = true\n            return\n          }\n        }\n      }\n\n      for (const range of rangeData.all.reverse()) {\n        if (isWarningInRange(warning, range)) {\n          range.used = true\n          return\n        }\n      }\n    })\n\n    Object.keys(rangeData).forEach(rule => {\n      rangeData[rule].forEach(range => {\n        // Is an equivalent range already marked as unused?\n        const alreadyMarkedUnused = unused.ranges.find(unusedRange => {\n          return unusedRange.start === range.start && unusedRange.end === range.end\n        })\n\n        // If this range is unused and no equivalent is marked,\n        // mark this range as unused\n        if (!range.used && !alreadyMarkedUnused) {\n          unused.ranges.push(range)\n        }\n\n        // If this range is used but an equivalent has been marked as unused,\n        // remove that equivalent. This can happen because of the duplication\n        // of ranges in rule-specific range sets and the \"all\" range set\n        if (range.used && alreadyMarkedUnused) {\n          _.remove(unused.ranges, alreadyMarkedUnused)\n        }\n      })\n    })\n\n    unused.ranges = _.sortBy(unused.ranges, [ \"start\", \"end\" ])\n\n    report.push(unused)\n  })\n\n  return report\n}\n\nfunction isWarningInRange(\n  warning/*: {\n    rule: string,\n    line: number,\n  }*/,\n  range/*: {\n    rules?: Array<string>,\n    start: number,\n    end?: number,\n  }*/\n)/*: boolean*/ {\n  const rule = warning.rule,\n    line = warning.line\n\n  // Need to check if range.end exist, because line number type cannot be compared to undefined\n  return range.start <= line && (range.end !== undefined && range.end >= line || range.end === undefined) && (!range.rules || range.rules.indexOf(rule) !== -1)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/FileCache.js":"/* @flow */\n\"use strict\"\n\nconst fileEntryCache = require(\"file-entry-cache\")\nconst path = require(\"path\")\nconst debug = require(\"debug\")(\"stylelint:file-cache\")\nconst getCacheFile = require(\"./getCacheFile\")\n\nconst DEFAULT_CACHE_LOCATION = \"./.stylelintcache\"\nconst DEFAULT_HASH = \"\"\n\nfunction FileCache(cacheLocation/*: ?string */, hashOfConfig/*: ?string */) {\n  const cacheFile = path.resolve(getCacheFile(cacheLocation || DEFAULT_CACHE_LOCATION, process.cwd()))\n  debug(`Cache file is created at ${cacheFile}`)\n  this._fileCache = fileEntryCache.create(cacheFile)\n  this._hashOfConfig = hashOfConfig || DEFAULT_HASH\n}\n\nFileCache.prototype.hasFileChanged = function (absoluteFilepath) {\n  // Get file descriptor compares current metadata against cached\n  // one and stores the result to \"changed\" prop.w\n  const descriptor = this._fileCache.getFileDescriptor(absoluteFilepath)\n  const meta = descriptor.meta || {}\n  const changed = descriptor.changed || meta.hashOfConfig !== this._hashOfConfig\n  if (!changed) {\n    debug(`Skip linting ${absoluteFilepath}. File hasn't changed.`)\n  }\n  // Mutate file descriptor object and store config hash to each file.\n  // Running lint with different config should invalidate the cache.\n  if (meta.hashOfConfig !== this._hashOfConfig) {\n    meta.hashOfConfig = this._hashOfConfig\n  }\n  return changed\n}\n\nFileCache.prototype.reconcile = function () {\n  this._fileCache.reconcile()\n}\n\nFileCache.prototype.destroy = function () {\n  this._fileCache.destroy()\n}\n\nFileCache.prototype.removeEntry = function (absoluteFilepath) {\n  this._fileCache.removeEntry(absoluteFilepath)\n}\n\nmodule.exports = FileCache\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/getCacheFile.js":"\"use strict\"\n\nconst hash = require(\"./hash\")\nconst path = require(\"path\")\nconst fs = require(\"fs\")\n/**\n * Return the cacheFile to be used by stylelint, based on whether the provided parameter is\n * a directory or looks like a directory (ends in `path.sep`), in which case the file\n * name will be `cacheFile/.cache_hashOfCWD`.\n *\n * If cacheFile points to a file or looks like a file, then it will just use that file.\n *\n * @param {string} cacheFile - The name of file to be used to store the cache\n * @param {string} cwd - Current working directory. Used for tests\n * @returns {string} Resolved path to the cache file\n */\nmodule.exports = function getCacheFile(cacheFile, cwd) {\n  /*\n   * Make sure path separators are normalized for environment/os.\n   * Also, keep trailing path separator if present.\n   */\n  cacheFile = path.normalize(cacheFile)\n\n  const resolvedCacheFile = path.resolve(cwd, cacheFile)\n  // If the last character passed is a path separator, we assume is a directory.\n  const looksLikeADirectory = cacheFile[cacheFile.length - 1] === path.sep\n\n  /**\n   * Return the default cache file name when provided parameter is a directory.\n   * @returns {string} - Resolved path to the cacheFile\n   */\n  function getCacheFileForDirectory() {\n    return path.join(resolvedCacheFile, `.stylelintcache_${hash(cwd)}`)\n  }\n\n  let fileStats\n\n  try {\n    fileStats = fs.lstatSync(resolvedCacheFile)\n  } catch (ex) {\n    fileStats = null\n  }\n\n  if (looksLikeADirectory || (fileStats && fileStats.isDirectory())) {\n    // Return path to provided directory with generated file name.\n    return getCacheFileForDirectory()\n  }\n\n  // Return normalized path to cache file.\n  return resolvedCacheFile\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/lib/utils/hash.js":"\"use strict\"\nconst murmur = require(\"imurmurhash\")\n\n/**\n * hash the given string\n * @param  {string} str the string to hash\n * @returns {string}    the hash\n */\nmodule.exports = function hash(str) {\n  return murmur(str).result().toString(36)\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/decls/postcss.js":"export type postcss$comment = {\n  text: string,\n  source: {\n    start: {\n      line: number,\n      column: number,\n    },\n    end: {\n      line: number,\n      column: number,\n    },\n  },\n  error(message: string, options: { plugin: string }): void,\n}\n\nexport type postcss$atRule = {\n  name: string,\n  params: string,\n  raw: Function,\n  raws: {\n    afterName: string,\n  },\n  type: string,\n  parent: Object,\n  nodes: Array<Object>,\n}\n\nexport type postcss$rule = {\n  raws: Object,\n  selector: string,\n  type: string,\n  parent: Object,\n  nodes: Array<Object>,\n}\n\nexport type postcss$options = {\n  from?: string,\n  parser?: stylelint$syntaxes,\n  syntax?: stylelint$syntaxes,\n}\n\nexport type postcss$result = {\n  css: string,\n  root: Object,\n  stylelint: {\n    disabledRanges: disabledRangeObject,\n    ruleSeverities?: Object,\n    customMessages?: Object,\n    quiet?: boolean,\n  },\n}\n","/home/travis/build/npmtest/node-npmtest-stylelint/node_modules/stylelint/decls/stylelint.js":"export type stylelint$configExtends = string | Array<string>\nexport type stylelint$configPlugins = string | Array<string>\nexport type stylelint$configProcessors = string | Array<string | [string, Object]>\nexport type stylelint$configIgnoreFiles = string | Array<string>\n\nexport type stylelint$configRuleSettings = any | [any, Object]\nexport type stylelint$configRules = {\n  [ruleName: string]: stylelint$configRuleSettings,\n}\n\nexport type stylelint$config = {\n  extends?: stylelint$configExtends,\n  plugins?: stylelint$configPlugins,\n  pluginFunctions?: {\n    [pluginName: string]: Function\n  },\n  processors?: stylelint$configProcessors,\n  processorFunctions?: Array<Function>,\n  ignoreFiles?: stylelint$configIgnoreFiles,\n  ignorePatterns?: string,\n  rules?: stylelint$configRules,\n  codeProcessors?: Array<Function>,\n  resultProcessors?: Array<Function>,\n  quiet?: boolean\n}\n\nexport type stylelint$syntaxes = \"scss\" | \"less\" | \"sugarss\"\n\nexport type stylelint$options = {\n  config?: stylelint$config,\n  configFile?: string,\n  configBasedir?: string,\n  configOverrides?: Object,\n  ignoreDisables?: boolean,\n  ignorePath?: string,\n  reportNeedlessDisables?: boolean,\n  syntax?: stylelint$syntaxes,\n  customSyntax?: string,\n}\n\nexport type stylelint$internalApi = {\n  _options: stylelint$options,\n  _extendExplorer: { load: Function },\n  _fullExplorer: { load: Function },\n  _configCache: Map<string, Object>,\n  _specifiedConfigCache: Map<string, Object>,\n  _postcssResultCache: Map<string, Object>,\n\n  _augmentConfig: Function,\n  _getPostcssResult: Function,\n  _lintSource: Function,\n  _createStylelintResult: Function,\n  _createEmptyPostcssResult?: Function,\n\n  getConfigForFile: Function,\n  isPathIgnored: Function,\n  lintSource: Function,\n}\n\nexport type stylelint$warning = {\n  line: number,\n  column: number,\n  rule: string,\n  severity: string,\n  text: string,\n}\n\nexport type stylelint$result = {\n  source: string,\n  deprecations: Array<{\n    text: string,\n    reference: string,\n  }>,\n  invalidOptionWarnings: Array<{\n    text: string,\n  }>,\n  errored?: boolean,\n  warnings: Array<stylelint$warning>,\n  ignored?: boolean,\n  _postcssResult?: Object,\n}\n\nexport type stylelint$needlessDisablesReport = Array<{\n  source: string,\n  ranges: Array<{\n    source: string,\n    ranges: Array<{\n      start: number,\n      end?: number,\n    }>,\n  }>,\n}>\n\nexport type stylelint$standaloneReturnValue = {\n  results: Array<stylelint$result>,\n  errored: boolean,\n  output: any,\n  needlessDisables?: stylelint$needlessDisablesReport,\n}\n\nexport type stylelint$standaloneOptions = {\n  files?: string | Array<string>,\n  cache?: bool,\n  cacheLocation?: string,\n  code?: string,\n  codeFilename?: string,\n  config?: stylelint$config,\n  configFile?: string,\n  configBasedir?: string,\n  configOverrides?: Object,\n  ignoreDisables?: boolean,\n  ignorePath?: string,\n  reportNeedlessDisables?: boolean,\n  syntax?: stylelint$syntaxes,\n  customSyntax?: string,\n  formatter?: \"json\" | \"string\" | \"verbose\" | Function,\n  allowEmptyInput?: boolean,\n}\n"}